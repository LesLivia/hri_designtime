<template>
		<name>Human_Recipient</name>
		<parameter>int id, double _v, int p_f, int p_fw, int path,const double arg[n_arg_all],const int arg_ad[nr_argAd], const int SEEAO[nr_seeao_max][nc_seeao], const double importance_entity[nr_impEntity_max], const double importance_sense[nr_impSense_max], const double obj_xye[nr_obj_max][nc_obj]</parameter>
		<declaration>

clock t, F, Fp;
clock tUpd;
clock tExp;

double lambda, mi;
const double passout_th = 1.0;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

meta int v;

bool access() {
    return true;
}

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = **N_P_0.0**
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[**max_neigh**] = **max_neigh_-1**
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = **N_I_false**
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; **max_neigh** &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;**max_neigh**;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    plan_traj();
}

double dist_to_dest;
void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 20.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;

    F = 0;
    Fp = 0;
    t = 0;
    v = fint(_v);

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    }
    else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}
////////////////////////////////////////////////
//extraction declaration code
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

/*
h_b_ultra_cmpc_v1
modello che fa le stesse cose di quello cmpct con una sola funzione

variabili: 
- vettore dei pesi degli eventi
- vettore dei pesi delle azioni
- vettore dei pesi dei sensi
- SEAAO: matrice che lega tutti gli elementi Sense-Entity-Event-Action-Output,
 da n righe = numero di azioni e 5 colonne.
-n_eventi,n_action,n_sense,n_entity
remember: 
- lenght_interval_vector = length_of the id vector, so when we call that function we can use instead of it n_sense, 
n_action, n_events
- lego in modo univoco l'id del senso,dell'evento, dell'entity, e dell'azione finale e dell'output.
- ogni elemento ha il suo id, in modo da aggiornare più facilmente i pesi, che sono univoci rispetto a all'elemento.
*/

    bool id_rows = false; // true NON ANCORA IMPLEMENTATO
                      //per utilizzare la ricerca dell'azione usando la riga =&gt; riga = id azione --&gt;semplifica la ricerca della
                     //outuput id SEAAO [n_riga][4]   
                    // false IMPLEMENTATO 
                    //per avere l'id dell'azione nella matrice e non dato dalla riga --&gt; output dato da selezione 
                    // della riga in base a senso- entità- evento- azione 



    int i,j,k,o,i1,i2,i3,i4,i5,i6,j1,j2,j3,j4; // indexes for the for loops

    const int N_interval = 101; // number for the scale of the the interval vector
    const int N_random = 100; // number to define the scale of the probability
    // li ho settati diversi (dovrebbero essere uguali) perchè è la strada più veloce
    // che mi ha aiutato nel capire che c'è un caso particolare che mi da out of range
    // ho già pensato come risolverlo, lo sto facendo in una versione 1 di questo, per 
    // non mischiare
    // c’è un problema (se N_interval = N_random)
    //quando la somma dei pesi fa tipo 99 e il numero random 
    //che esce è 100, dato che il valore che nell’interval vector non c’è si 
    //ha out of range


    const double upd_weight = arg[0];
    const int caso_upd_weight = fint(arg[1]);
        /*
            * 0 -&gt; nulla
            * 1 -&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm ad ogni ciclo
            * 2--&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm  RANDOMATICAMENTE
        */
    const double stm_weight = arg[2];
    const double ltm_weight = arg[3];
    const int caso_weight_entity = fint(arg[4]);
        /*
            0- nothing; the entity has weight equal to 1;
            1- every entity has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
    const int caso_weight_sense = fint(arg[5]);
          /*
            0- nothing; the sense has weight equal to 1;
            1- every sense has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
  

    // per settare come avviene la modifica del vettore event may happen
    const int caso_event = fint(arg[6]);
        /*
        il vettore event_may_happen diventa 
        0 - uguale a quello initilizzato
        1 - randomico
        2 - in base alla distanza dell'entità con l'umano 
    */ 
    
    const int caso_delay = fint(arg[7]);
        /*
            0- nulla, l'id viene estratto ad ogni chiamata della funzione out_id()
            1- l'id viene estratto ogni n index value 
        */
    const int n_delay_index = fint(arg[8]);
  // ho tolto la costante per fare in modo che le distanze posssano essere cambiate
   // variabili per il valore iniziale (dunque precedente) dell'ultima azione fatta dall'umano
  // è da fare in modo che non sia pari a zero, perchè c'è la possibilità che nel caso in cui tutti i  
   int last_id_extracted_output =fint(arg[9]); // se caso 1,la metto a zero per vedere il suo primo valore
    const int caso_last_id = fint(arg[10]);
    /*
     se 0 - quella iniziale è pari a quella settata sopra ad OGNI ciclo
    se 1 - selezionata randomicamente tra 1 e 4 / n ad OGNI ciclo
    se 2 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
            quando index_cicli &gt; 1 con index_cicli di partenza  = 0;  SOLO per la prima
    se 3 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; ma randomica la scelta di initial_id SOLO per 
        la prima
    */

    const int caso_obj = fint(arg[11]);
    /*
     * 0 -&gt; oggetti fissi secondo la matrice obj_xye
     * 1 -&gt; oggetti che randomicamente cambiano posizione e sono vicini all'umano
     * 2 -&gt; un oggetto, quello selezionato cambia posizione (vicino all'umano), gli altri sono fissi    
    */
    const int obj_selected = fint(arg[12]); 
    // distance treshold
    const double distance_threshold = arg[13];
   // variabili per le funzioni sulla stm and ltm 
    const int caso_stm_ltm = fint(arg[14]);
    /*
    se 0 - parte della perdita di memoria non attiva 
    se 1 - parte della perdita di memoria randomica attiva
    se 2 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) in modo randomico
    se 3 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) quando è piena inizia ad eliminare il primo
    */
    const int n_stm = fint(arg[15]); //massime azioni che si possono memorizzare // se 2 =&gt; n-1 elementi salvati
    const int n_ltm = fint(arg[16]); // posto a 6--&gt; non coincida con id_Action_max = 5 (per la simulazione)
    


    
//////////////////////////////////////////////////////////

//id_entity
const int id_robot=fint(arg[17]);


//id_output
const int id_walk=fint(arg[18]);
const int id_sit=fint(arg[19]);
const int id_run=fint(arg[20]);
const int id_stand=fint(arg[21]);



/////////////////////
const int n_rows = arg_ad[0];
const int n_columns = nc_seeao; //definita a livello globale arg_ad[1]; //5;

const int n_sense=arg_ad[1];//3;
const int n_entity=arg_ad[2];//11;
const int n_event=arg_ad[3];//18;
const int n_action=arg_ad[4];//20;
const int n_output=arg_ad[5];//4;


////////////////////////////////////////
  
  // number of objects in the environment
    // const int n_objects= 5;
 // matrix for the object
   /*
       	N righe = N oggetti 
       	colonna 1 : x-&gt; double
       	colonna 2 : y double 
       	colonna 3 : tipo entità  int (poi tramite conversione double -&gt; int con int = fint(double)) 
   */
const int nr_obj =arg_ad[6];// 7;
//const int nc_obj = 3;//definita a livello globale
double obj_xye_tmp[nr_obj][nc_obj];  
 // altro 
    clock x;

const int nr_obj_dyn = R;// nel Dpa è definita da R
const int nc_obj_dyn = nc_obj; // definita a livello globale
double distance_obj_dyn[nr_obj_dyn];
double obj_xye_dyn[nr_obj_dyn][nc_obj_dyn] ={{0.0,0.0,0.0}};
//int id_robot = 1;

const int nr_object = nr_obj + nr_obj_dyn;

/////////////////////////////////////////////////


//sense importance matrix
//const int n_sense_tot = 5;//in questo momento non ho trovato il modo di legare le info della SEEAO
                          // e questa in cpp, dunque li considero tutti i pesi dei sensi pur sapendo 
                          // che solo i primi 3 vengono usati.
///*
//sense importance matrix
const int n_sense_tot = nr_impSense_max;//definita al livello globale



//entity importance matrix

// in questo momento li posso assegnare in modo con id crescente
    int id_vector_sense[n_sense];
    int id_vector_event[n_event];
    int id_vector_entity[n_entity];
    int id_vector_action[n_action];
    int id_vector_output[n_output];

void init_obj_xye_tmp(int nr, int nc){
        int i = 0;
        int j = 0; 
        for(i  = 0; i &lt; nr; i ++){
            for(j = 0; j &lt; nc; j++){
                obj_xye_tmp[i][j] = obj_xye[i][j];     
            }
        }
    }
    
void id_initialization(){
    for(j1 =0 ; j1&lt;n_sense;j1++){
        id_vector_sense[j1] = j1+1;
    }
    for( j2 =0 ; j2&lt;n_event;j2++){
        id_vector_event[j2] = j2+1;
    }
    for( j3 =0 ; j3&lt;n_action;j3++){
        id_vector_action[j3] = j3+1;
    }
    for( j4 =0 ; j4&lt;n_entity;j4++){
        id_vector_entity[j4] = j4+1;
    }
    for( j4 =0 ; j4&lt;n_output;j4++){
        id_vector_output[j4] = j4+1;
    }

}

void set_to_zero(){//function toset to zero the value of the vectors and the other elements
                    // that are needed to be set to zero 


    }
 


  //matrix for the hb model
 // variabili per la funzione update_weight  
  //variabili per il i pesi dei diversi elementi presenti nel modello
    double action_weight_vector[n_action];//ora si modificano in base agli eventi 
    double sense_weight_vector[n_sense];
    double event_weight_vector[n_event];
    double entity_weight_vector[n_entity];

//variabili per la funzione update_event_may_happen
    int event_may_happen[n_event] ;// {1,1,0,0,1}; // 1 if yes, 0 if no.// it can be modified

    double weight_stm;
    double weight_ltm;
    int stm_action[n_stm];//vettore per memorizzare n_stm output_action
    int ltm_action[n_ltm];
    int stm_index = 0;
    int ltm_index =0;


// variable to count the nnumber of the model iterations over the time
    int index_cycle = 0;


  // variables to memorize the id's extracted
    int id_sense_extracted;
    int id_entity_extracted;
    int id_event_extracted;
    int id_action_extracted;
   // int id_output_extracted;
    int id_out;
    int last_output_id;
    int id_entity;
    int id_sense;
    int id_event;
    int id_action;
  
  
double distance[nr_obj];

void upd_obj_dyn_pos(){
    int i;
    for(i =0 ; i &lt; R; i++){
        obj_xye_dyn[i][0] =robPositionX[i];
        obj_xye_dyn[i][1] =robPositionY[i];
        obj_xye_dyn[i][2] =id_robot;
    }
}

int event_from_entity[n_event];
int id_object;
int neigh[nr_object];
double pos_human;
double pos_object;
// funzione che modifica il event may happen
void update_event_may_happen(){
    int g =0;
    int event_id;
    double numero_random_mh;
    int i;
    int j; 
    int k; 
    double k_th = 0.90;
    double d_th = distance_threshold*k_th; 
    
  // il caso_event definisce se il vettore event_may_happen rimane come fissato(0) o è randomico (=1)
    if(caso_event == 1){
        // associa randomicamente 0(non succede) 1(succede)
        for(g=0; g&lt; n_event; g++){
            numero_random_mh = random(100)+1;
            if(numero_random_mh &lt;= 50){
                event_may_happen[g] = 1;
            }
            else{
                event_may_happen[g] = 0;
            }
        }
    }
    else if(caso_event == 2){
    // initializzo il vettore event_may_happen a zero per fare in modo che poi cambia
    // e non avere problemi che diventino tutti uno 
        for(i = 0; i &lt; n_event; i ++){
            event_may_happen[i] = 0;
        }
        // faccio lo stesso per il vettore event_from_entity per averlo nullo al prossimo ciclo
        // e non dipendente dal ciclo precedente
        for(i = 0; i &lt; n_event; i ++){
            event_from_entity [i] = 0;
        }
      //+ popolo il vettore neighbour per oggetti statici
        for(i = 0; i &lt; nr_obj; i ++){
          //+ verifico la distanza tra entità ed umano
        // ora lo faccio in modo randomico poi posso usare le struct in cui un oggetto
        // è definito da  : object(id,x,y)
            //pos_object = random(N_random)+ 1;
            //pos_human = random(N_random) + 1;
            //pos_object = 4.0;
            //pos_human =3.0;

        // caso 1 della funzione
            init_obj_xye_tmp(nr_obj,nc_obj);
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_tmp[i][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[i][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_tmp[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance[i] = pt_dist(humanPositionX[id -1],obj_xye[i][0],humanPositionY[id -1],obj_xye[i][1]);
        // verifica della condizione sulla distanza 
            if( distance[i] &lt;= distance_threshold){
                id_object =fint(obj_xye[i][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
        
         j = 0;// perchè non faccio più riferimento alla matrice statica ma a quella dynamica che ha 
               // parte da zero come indice e non parte dall'indice finale di quella statica
               // lo faccio soptrattutto per evitare errore di indici perchè accederei a parti della matrice
               // che non esiste
        //+ popolo il vettore neighbour per oggetti dinamici dalla fine degli oggetti statici al numero totale di oggetti
        for(i = nr_obj; i &lt; nr_object; i ++){ // parto da nr_obj perchè il vettore neigh non lo divido tra dinamico
                                              // e statico ma ne mantengo uno solo con dentro sia gli oggetti statici
                                              // che dinamici
        // caso 1 della funzione
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_dyn[j][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[j][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_dyn[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance_obj_dyn[j] = pt_dist(humanPositionX[id -1],obj_xye_dyn[j][0],humanPositionY[id -1],obj_xye_dyn[j][1]);
        // verifica della condizione sulla distanza 
            if( distance_obj_dyn[j] &lt;= distance_threshold){
                id_object =fint(obj_xye_dyn[j][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
      //+ scorro la matrice per associare al vettore event_may_happen il valore 1 per l'entità
      // che rientra nel neighbour
        for(j = 0; j &lt; nr_object; j ++){  
        // scorro la matrice  
            for(i = 0; i &lt; n_rows; i++){
             // trovando l'entità che è nel neighbour of the human
                if(SEEAO[i][1] == neigh[j]){
               // prendo l'evento relativo a quell'entità
                    event_id = SEEAO[i][2];
                // faccio scorrere il vettore degli eventi per attivarli o meno
                    for(k = 0; k &lt; n_event; k++){
                // se trovo un id nel vettore degli id degli eventi uguali, dato che 
                // il vettore event_may_happen ha le stesse celle di quello dell'id_vector
                // prendendo l'indice dell'id_vector event posso porre event_may_happen[k] = 1
                        if(event_id ==id_vector_event[k]){
                           // event_may_happen[k] = 1;
                            
                            // altrimenti posso contare le ricorrenze degli eventi e poi
                            // porre event_may_happen a 1 quando il valore in un vettore che conta 
                            // le ricorrenze è maggiore di zero e gli altri a zero 
                            event_from_entity[k] = event_from_entity[k]+1;
                        }
                    }
                }
            }
        }
        
        // in questo caso l' inizializzazione del vettore event_may_happen non interessa
    // dato che qui vi assegno  ed 1, devo farlo però per il vettore event_from_entity
        for(k = 0; k&lt; n_event; k ++){
            if(event_from_entity[k]&gt;0){
                event_may_happen[k] = 1;
            }
            else{
                event_may_happen[k] = 0;
            }
        }
    }   
}

    //definition of the variable to be used in the update_weight function 
    //defined outside to look what happens over the time for their values
    double event_weight_sum = 0.0;
    double entity_weight_sum = 0.0;
    double sense_weight_sum = 0.0;
    double action_weight_sum = 0.0;

void update_weight(){//funzione per l'update dei pesi     
    int i1=0;
    int o1 = 0;
    // annullare la somma ad ogni inizio della funzione
    event_weight_sum = 0.0;
    entity_weight_sum = 0.0;
    sense_weight_sum = 0.0;
    action_weight_sum = 0.0;
    // setto i vettori dei pesi = 0; mi serve per l'estrazione poi
    for(i1 =0;i1 &lt;n_sense;i1++){
        sense_weight_vector[i1]= 0;
    } 
    i1=0;
    for(i1 =0;i1 &lt;n_entity;i1++){
        entity_weight_vector[i1]= 0;
    }
    i1 =0;    
    for(i1 =0;i1 &lt;n_event;i1++){
        event_weight_vector[i1]= 0;
    }  
    i1 =0;    
    for(i1 =0;i1 &lt;n_action;i1++){
        action_weight_vector[i1]= 0;
    }     
    

    // dal vettore degli eventi che possono succedere definisco quali sono le entità e sensi relativi 
    for(i = 0; i &lt; n_event; i ++){
        if(event_may_happen[i] == 1){
            // definisco l'id dell'evento
                id_event = id_vector_event[i];
                // ricerco nella matrice SEEAO gli eventi con l'id dell'evento che mi interessa, muovendomi lungo le azioni
                for(j= 0; j &lt; n_rows;j ++){
                    if(SEEAO[j][2]==id_event){
                         // assegno gli id_entity ed sense presi dalla matrice nella posizione che  id = id_event
                             id_entity = SEEAO[j][1];
                             id_sense = SEEAO[j][0];
                             id_action = SEEAO[j][3];
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi dell'entità
                            if(caso_weight_entity ==1){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + importance_entity[k];
                                    }
                                }
                            }
                            else if(caso_weight_entity==0){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + 1.00;
                                    }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi per i sense
                            if(caso_weight_sense==1){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] + importance_sense[o];
                                     }
                                }
                            }
                            else if(caso_weight_sense == 0){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] +1.00;
                                     }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi delle azioni
                            for( o1 = 0; o1 &lt; n_action; o1++){
                                 if(id_vector_action[o1]== id_action){
                                        action_weight_vector[o1] = action_weight_vector[o1] + 1.00;
                                        if(caso_upd_weight==1){
                                            // aggiunta pesi dalla stm
                                
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                        else if (caso_upd_weight==2 &amp;&amp; random(N_random)+1 &lt;= upd_weight){
                                            // aggiunta pesi dalla stm
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                 }
                            }

                   }            
              }

        }
    }


    //normalise the weight of the event,
    for( i1 = 0; i1 &lt; n_event; i1 ++ ){
        event_weight_sum = event_weight_sum + event_may_happen[i1];
    }
    for(i2 = 0; i2 &lt; n_event; i2++){
        event_weight_vector[i2] = event_may_happen[i2]/event_weight_sum;
    }
    //normalise the weight of the entity 
    for( i3 = 0; i3 &lt; n_entity; i3++){
        entity_weight_sum = entity_weight_sum + entity_weight_vector[i3];
    }
    for( i4 = 0; i4 &lt; n_entity; i4++){
        entity_weight_vector[i4] = entity_weight_vector[i4]/entity_weight_sum;
    }

    //normalise the weight of the sense 
    for(i5 = 0; i5 &lt; n_sense; i5++){
        sense_weight_sum = sense_weight_sum + sense_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_sense; i6++){
        sense_weight_vector[i6] = sense_weight_vector[i6]/sense_weight_sum;
    }

    // normalise the weight of the action
    for(i5 = 0; i5 &lt; n_action; i5++){
        action_weight_sum = action_weight_sum + action_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_action; i6++){
        action_weight_vector[i6] = action_weight_vector[i6]/action_weight_sum;
    }

}

    // dichirazioni per la sense_id_extraction function (messi fuori perché dentro danno problema di SCN)
    double numero_random_;
    double  interval_vector_sense[n_sense];

// for extraction of the id_sense
int sense_id_extraction(){
    double numero_random = random(N_random)+1;
    
    int q1,q;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int i1 =0;
    int id_selected[n_sense];// vettore di appoggio per i sensi selezionati
    //creare il vettore posso fare come faccio per quello dell’entità considerando solo i sensi che hanno 
    //peso diverso da zero utilizzando un vettore di appoggio per memorizzare i valori degli id di quei sensi che hanno 
    //il peso diverso da zero
    //ciclo per settare i valori del vettore di appoggio degli id = 0
    //  for(q6 = 0; q6 &lt;n_sense;q6 ++){
    //        id_selected[q6] = 0; 
    //}

    //dal vettore dei pesi dei sensi prendo solo quelli che hanno il peso diverso da 0
    //q6 =0;
    //for(i1=0; i1&lt; n_sense;i++){
      //  if(sense_weight_vector(i1)&gt;0){
        //    id_selected[q6] = id_vector_sense[i1];
          //  q6 ++;
        //}
    //}

    //interval vector initialization
    for(q1=0;q1&lt;n_sense;q1++)
    {
    	interval_vector_sense[q1] = sense_weight_vector[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_sense; q ++)//changed
    {
    interval_vector_sense[q] = interval_vector_sense[q-1]+ interval_vector_sense[q];
    }

    l=0;
    // extract the sense from the comparison between the numero random and the interval_vector components
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_sense[l]){
            id_extracted = id_vector_sense[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    } 
    return id_extracted;
}

 double  interval_vector_entity[n_entity];
 double weight_vector_entity[n_entity];//double weight_vector[n_entity];

// modo diverso dal precedente, metto a zero i pesi dell'entità non considerate, evito di usare una funzione esterna
// calcolare il numero di entità derivanti dal senso (perché non ho quell'info al tempo della compilazione)
// for extraction of the entity from the sense--------------------------------------------------
int entity_id_extraction(int sense_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_entity];// int id_selected[n_entity];
    int m1 = 0;
    int selected_id;
    int k; 
    int selected_vector[n_entity];
    //define the interval vector // dichiarazioni spostate per l'errore che danno
    //double  interval_vector[n_entity];
  
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0, comunque per non averlo uguale a non so cosa da zero
    for(q6 = 0; q6 &lt;n_entity;q6 ++){
        id_selected[q6] = 0; 
    }
    
    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_entity;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_entity;k ++){
                    if(id_vector_entity[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
        }
    }
    for(k = 0;k &lt; n_entity; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }

    // creo il vettore dei pesi per l'entità relative al senso estratto

    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_entity; q3 ++){
            if( id_vector_entity[q3] == id_selected[q2]){
                weight_vector_entity[q2] = entity_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_entity[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_entity[q5] = weight_vector_entity[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_entity[q1] = weight_vector_entity[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){//n_selected = n_entity
        interval_vector_entity[q] = interval_vector_entity[q-1]+ interval_vector_entity[q];
    }

    while (id_trovato == true)
    {
        if (numero_random &lt;= interval_vector_entity[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
    return id_extracted;
}


    // definizione esterna per il problema che mi da metterli dentro
    double weight_vector_event[n_event];
    double  interval_vector_event[n_event];
// FUNCTION for extraction of the event id from the entity extracted
int event_id_extraction(int sense_id_extracted, int entity_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number    
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
   // int id_selected[n_event];
    int id_selected[n_event];
    int m1 = 0;
    //double weight_vector[n_event];    
    //double weight_vector[5];
    //define the interval vector
    //double  interval_vector[n_event];
    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id ;
    int selected_vector[n_event];
    int n_dim = n_event;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_dim;q6 ++){
        id_selected[q6] = 0; 
    }

    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }


    // definisco quali sono gli eventi legate a quell'entità
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            if(SEEAO[m][1] == entity_id_extracted){
                selected_id = SEEAO[m][2]; // vettore dell'evento elativo a quell'entità, che dovrò estrarre
                //selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_dim;k ++){
                    if(id_vector_event[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
            }
        }
    }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }


    // creo il vettore dei pesi per l'entità relative al senso estratto
    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_event; q3 ++){
            if( id_vector_event[q3] == id_selected[q2]){
                weight_vector_event[q2] = event_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_event[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_event[q5] = weight_vector_event[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_event[q1] = weight_vector_event[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){
        interval_vector_event[q] = interval_vector_event[q-1]+ interval_vector_event[q];
    }
    l=0;
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_event[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
 
    return id_extracted;
}

    double weight_vector_action[n_action];
    double interval_vector_action[n_action];
// for extraction of the action from the event
int action_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_action];
    int m1 = 0;    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id;
    int n_dim = n_action;
    int selected_vector[n_action];


    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_action;q6 ++){
            id_selected[q6] = 0; 
        }
    
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso

    if(id_rows == false){// caso con la ricerca dell'azione andando per esclusione tra quelle con sense, entity and event extracted
                        // che usa l'id dell'azione nella matrice SEEAO nella posizione 3 (colonnna 4)
        for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        selected_id = SEEAO[m][3]; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        for(k =0; k&lt; n_dim;k ++){
                            if(id_vector_action[k] == selected_id){
                                selected_vector[k] = selected_vector[k] + 1;
                            }
                        }

                    }
                }
            }
        }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }



        for(q2 = 0; q2 &lt; n_selected ;q2 ++){
            for(q3 =0 ; q3 &lt; n_action; q3 ++){
                if( id_vector_action[q3] == id_selected[q2]){
                    weight_vector_action[q2] = action_weight_vector[q3];
                }
            }

        }
        // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_selected; q4 ++){
            weight_sum = weight_sum + weight_vector_action[q4];
        }
        //normalizzo i pesi 
        for(q5 = 0; q5 &lt; n_selected; q5 ++){
            weight_vector_action[q5] = weight_vector_action[q5]/weight_sum;
        }

        //interval vector initialization
        for(q1=0;q1 &lt; n_selected;q1++){
	        interval_vector_action[q1] = weight_vector_action[q1]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q = 1 ; q &lt; n_selected; q ++){
            interval_vector_action[q] = interval_vector_action[q-1]+ interval_vector_action[q];
        }
         while (id_trovato == true){
             if (numero_random &lt;= interval_vector_action[l]){
               id_extracted = id_selected[l];
               id_trovato = false;
             }
             else{
                 l ++;
             }
       }



    }
    else{// caso id_rows = true 
         for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        id_selected[j] = m; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                      //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
                        n_selected ++; 
                    }
                }
            }
        }
    }

   
    return id_extracted;
}



//function for the id of the output action--&gt; non è corretta perché l'azione estratta è definita dalla n_row 
// e non dall'id della azione

int output_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted, int action_id_extracted){
    int id_extracted = 0;
    int m = 0;
 for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){//seleziono la riga con il senso estratto
            if(SEEAO[m][1] == entity_id_extracted){//seleziono la riga con il senso e l'entità estratto
                if(SEEAO[m][2] == event_id_extracted){// seleziono la riga con il senso, entità ed evento estratto
                   if(SEEAO[m][3] == action_id_extracted){ // seleziono la riga con il senso,l'entità,l'evento,l'azione estratta
                      id_extracted = SEEAO[m][4]; // 4 th column defines the output action of the action
                    }
                }
            } 
        }
    }
  
    return id_extracted;
}


double update_stm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

double update_ltm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

int add_1(int a){
    return a + 1;
}

// funzione per la short-term memory 
void stm(){
    stm_action[stm_index] = id_action_extracted;
    stm_index = add_1(stm_index);
}

// funzione per la long-term memory
void ltm(){
    ltm_action[ltm_index] = id_action_extracted;
    ltm_index = add_1(ltm_index);
}

int stm_head ;
int stm_tail=0;
int ltm_head;
int ltm_tail=0;
int stm_deleted;
int ltm_deleted; 

int stm_full = 0;//0 -&gt;false; -1 -&gt;true to see the difference in the simulation
int ltm_full = 0;

void stm_enqueue (){
    if(stm_tail == n_stm){
        stm_full = -1; 
    }
    else{
        stm_action[stm_tail] = id_action_extracted;
        stm_tail ++;
        stm_full = 0;
    }
}

void stm_dequeue(){
    int i;
    if(stm_tail &gt; 0){
        stm_deleted = stm_action[0];
        for(i = 1; i &lt; n_stm ; i++){
            stm_action[i-1] = stm_action[i];
        }
        for(i = stm_tail ; i &lt; n_stm ; i ++){
            stm_action[i] = 0;
        }
        stm_tail --;
        
    }    
}


void ltm_enqueue (){
    if(ltm_tail == n_ltm){
        ltm_full = -1; 
    }
    else{
        ltm_action[ltm_tail] = id_action_extracted;
        ltm_tail ++;
        ltm_full = 0;
    }
}

void ltm_dequeue(){
    int i;
    if(ltm_tail &gt; 0){
        ltm_deleted = ltm_action[0];
        for(i = 1; i &lt; n_ltm ; i++){
            ltm_action[i-1] = ltm_action[i];
        }
        for(i = ltm_tail ; i &lt; n_ltm ; i ++){
            ltm_action[i] = 0;
        }
        ltm_tail --;
    }    
}



void stm_ltm(){
    double weight_lost_action_stm;
    double weight_lost_action_ltm;
    double index_random_double;
    int index_random;
    int i;
    
    int action_removed;
      if(caso_stm_ltm == 0){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm
    } // not case 0
  // possibility to lose an action in the stm or in the ltm 
    if(caso_stm_ltm == 1){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm

        // in stm 
            weight_stm = update_stm_weight();
        if(random(N_random)+1 &lt;= weight_stm ){
          //define the index extracted to remove the action
            index_random_double = random(stm_index+1); // aggiunto l'uno per evitare il problema di random(0)
            index_random = fint(index_random_double);
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(random(stm_index+1)); // from zero to index_stm
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_stm -1; i ++){
                stm_action[i] = stm_action[i+1];
            }
          // reduce the stm_index of 1
            if(stm_index &gt;= 1){ // aggiunto il controllo per evitare il caso stm_index = -1 allo step dopo
                stm_index = stm_index -1;
            }
        }

        // in ltm 
            weight_ltm = update_ltm_weight();
        if(random(N_random)+1 &lt;= weight_ltm ){
          //define the index extracted to remove the action
            index_random_double =random(ltm_index); 
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(index_random_double); // from zero to index_stm-1
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_ltm -1; i ++){
                ltm_action[i] = ltm_action[i+1];
            }
          // reduce the ltm_index of 1
            if (ltm_index &gt;=1){
                ltm_index = ltm_index -1;
            }
        }
    }
    // else no loss of memory

   
  // memoria che si aggiorna in in modo FIFO
    if(caso_stm_ltm == 2){
    // caso per stm
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_enqueue();
        }
        
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_dequeue();
        }
    // caso per ltm
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_enqueue();
        }
        
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_dequeue();
        }
        
    }
    if (caso_stm_ltm == 3){
        if(stm_tail == n_stm){
            stm_dequeue();
            stm_enqueue();
        }
        else{
            stm_enqueue();
        }

        if(ltm_tail == n_ltm){
            ltm_dequeue();
            ltm_enqueue();
        }
        else{
            ltm_enqueue();
        }
    }    
 
}



    double weight_vector_output[n_output];
    double interval_vector_output[n_output];
// funzione per come vado ad assegnare il last_id
void assignment_last_id(){
    int q4;
    int l;
    double weight_sum = 0.0;
    double numero_random = random(N_random)+1;
    bool id_trovato = false;
    int id_extracted;

  //
    // caso 0
    if(caso_last_id ==0){
        last_id_extracted_output = last_id_extracted_output;
        // so che non è necessario ma è solo per avere chiaro i vari casi, posso anche levarlo
    }
  // assegnazione stesso peso per ogni output 
    for(q4=0;q4&lt;n_output;q4++){
        weight_vector_output[q4] = 1;
    }
  // cicli per l'estrazione del last id in modo randomico ad ogni ciclo
    if(caso_last_id == 1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    } 

    //caso 2
    /*
        – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; 
    */

    if (caso_last_id == 2 &amp;&amp; index_cycle &lt;=1){
       last_id_extracted_output = last_id_extracted_output;
        //sembra un po contorta come assegnazione ma rispetto a quella precedente questa avviene solo 
        // al primo avvio del programma, ovvero solo nel caso in cui gli event sono tutti zero all'inizio
        // quando è già avviato la last_id_extracted_outpput = id_output_extracted assumento che venga estratta 
        // se non viene estratta rimarrà sempre uguale a quella iniziale
    }

    if (caso_last_id == 3 &amp;&amp; index_cycle &lt;=1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    }

}

//assignment
 bool event_all_zero = true;
//unica funzione che fa tutto quello che il modello cmpct fa
int out_id_ref(){
    int id_extracted_output;
    int j = 0;
    event_all_zero = true;//to set at all the call of this function the doubt to have all event = zero
   // index_cycle ++;
   // set_to_zero();
// update the position of the dynamic objects
        upd_obj_dyn_pos();
    // per avere che gli id vector siano dipendenti dal numero di entità, sense etc.... presenti
    id_initialization();
  // funzione per definire il valore della last_id a tempo zero
    assignment_last_id();
  // funzione per modificare il vettore degli eventi che potrebbero succedere 
    update_event_may_happen();
  // controllo che almeno un evento sia diverso da zero 
    while(event_all_zero == true and j &lt; n_event){
        if(event_may_happen[j]==1){
            event_all_zero = false;
        }
        j++;
    }
    if(event_all_zero == false){
      
      // funzione per l'update dei weights
        update_weight();
      // funzione per l'estrazione del senso 
        id_sense_extracted = sense_id_extraction();
      // funzione per l'estrazione dell'entità
        id_entity_extracted = entity_id_extraction(id_sense_extracted);
      // funzione per l'estrazione dell'evento
        id_event_extracted = event_id_extraction(id_sense_extracted, id_entity_extracted);
      // funzione per l'estrazione dell'azione
        id_action_extracted = action_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted);
      // funzionne per l'estrazione dell output finale
        id_extracted_output= output_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted, id_action_extracted);
        last_id_extracted_output = id_extracted_output;
      // funzione per li modulo stm and ltm
        stm_ltm();
        }
    else{
         // in questo caso solo per vedere se funziona, nel modello protrebbe essere
          id_extracted_output = last_id_extracted_output; // in questo caso è zero
        // id_extracted_output = 6;   
        }
return id_extracted_output;
}

int next_time = n_delay_index;
int n_extraction = 0;
int extraction_new = 0; 
int last_id_extracted_tmp = 0; // inserito per fare in modo che nel caso_deelay == 1 l'estrazione sia uguale alla precedente
                               // messa fuori perchè dentro viene definita = 0 ad ogni ciclo e quindi si blocca 
                               // il modello  
// funzione che viene usata e poi 
int out_id(){
    int id_extracted_output;
    index_cycle ++;
    if(caso_delay==0){
        id_extracted_output = out_id_ref();
        extraction_new = 1;
    }

    if(caso_delay==1){
        if(index_cycle&lt;=1||index_cycle%n_delay_index ==0){//devo fare l'estrazione almeno una volta
            id_extracted_output = out_id_ref();
            extraction_new = 1;
            last_id_extracted_tmp = id_extracted_output;
        }
       else{
        extraction_new = 0;
        id_extracted_output = last_id_extracted_tmp;
      }
    }
    else if(caso_delay ==2){
                if(index_cycle&lt;=1||fint(x)%n_delay_index ==0){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    } 
            }
    else if(caso_delay ==3){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index*n_extraction){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==4){
                if(index_cycle&lt;=1||fint(x)&gt;=next_time){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    next_time = fint(x) + n_delay_index;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==5){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    x = 0.0;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }

return id_extracted_output;
}

////////////////////////////////////////////////
</declaration>
<location id="id361" x="-492" y="-399">
			<name x="-526" y="-425">idle</name>
			<label kind="invariant" x="-612" y="-518">Fp' == 0 

&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id362" x="119" y="-399">
			<name x="127" y="-442">busy_mov</name>
			<label kind="invariant" x="127" y="-544">Fp' == 0 
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id363" x="-687" y="-398">
			<name x="-730" y="-415">Init</name>
			<committed/>
		</location>
		<location id="id364" x="272" y="-399">
			<name x="289" y="-416">passed_out</name>
			<label kind="invariant" x="289" y="-399">t' == 0 &amp;&amp;
F' == 0</label>
			<label kind="exponentialrate" x="264" y="-382">1</label>
		</location>
		<location id="id365" x="-195" y="-569">
			<name x="-186" y="-561">busy_rec</name>
			<label kind="invariant" x="-187" y="-544">Fp' == 0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id366" x="-493" y="-246">
			<name x="-476" y="-238">p_1</name>
			<committed/>
		</location>
		<location id="id367" x="-578" y="-246">
			<name x="-620" y="-255">p_2</name>
			<committed/>
		</location>
		<location id="id368" x="119" y="-246">
			<name x="102" y="-229">p_5</name>
			<committed/>
		</location>
		<location id="id369" x="119" y="-323">
			<name x="76" y="-331">p_6</name>
			<committed/>
		</location>
		<location id="id370" x="-85" y="-714">
			<name x="-95" y="-748">p_4</name>
			<committed/>
		</location>
		<location id="id371" x="-195" y="-714">
			<name x="-205" y="-748">p_3</name>
			<committed/>
		</location>
		<location id="id372" x="-42" y="-399">
			<name x="-52" y="-433">d_2</name>
			<committed/>
		</location>
		<location id="id373" x="-306" y="-399">
			<name x="-316" y="-433">d_1</name>
			<committed/>
		</location>
		<location id="id374" x="-722" y="-535" color="#a9a9a9">
			<name x="-732" y="-569">not_needed</name>
			<label kind="exponentialrate" x="-748" y="-544">1</label>
		</location>
		<init ref="id363"/>
		<transition color="#ffc0cb">
			<source ref="id373"/>
			<target ref="id368"/>
			<label kind="guard" x="-229" y="-212">id_out == id_walk</label>
			<nail x="-306" y="-187"/>
			<nail x="-306" y="-187"/>
			<nail x="119" y="-187"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id373"/>
			<target ref="id368"/>
			<label kind="guard" x="-17" y="-229">id_out==id_run</label>
			<nail x="-306" y="-229"/>
			<nail x="-306" y="-229"/>
			<nail x="102" y="-229"/>
		</transition>
		<transition color="#0000ff">
			<source ref="id373"/>
			<target ref="id361"/>
			<label kind="guard" x="-348" y="-382">id_out == id_sit</label>
			<label kind="assignment" x="-297" y="-365">t = 0, Fp = F, 
tUpd=0</label>
			<nail x="-365" y="-374"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id373"/>
			<target ref="id361"/>
			<label kind="guard" x="-314" y="-450">id_out== id_stand</label>
			<label kind="assignment" x="-289" y="-433">t = 0, Fp = F, 
tUpd=0</label>
		</transition>
		<transition color="#0000ff">
			<source ref="id372"/>
			<target ref="id366"/>
			<label kind="guard" x="-280" y="-144">id_out==id_sit</label>
			<nail x="-42" y="-119"/>
			<nail x="-493" y="-119"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id372"/>
			<target ref="id366"/>
			<label kind="guard" x="-408" y="-178">id_out== id_stand</label>
			<nail x="-42" y="-153"/>
			<nail x="-493" y="-153"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id372"/>
			<target ref="id362"/>
			<label kind="guard" x="8" y="-501">id_out== id_run</label>
			<label kind="assignment" x="17" y="-484">t = 0, Fp = 1-F,
tUpd=0, 
plan_traj()</label>
			<nail x="-42" y="-459"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id372"/>
			<target ref="id362"/>
			<label kind="guard" x="-34" y="-391">id_out== id_walk</label>
			<label kind="assignment" x="-34" y="-374">t = 0, Fp = 1-F,
tUpd=0, 
plan_traj()</label>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id372"/>
			<label kind="guard" x="-382" y="-272">currH == id</label>
			<nail x="-187" y="-246"/>
			<nail x="-187" y="-399"/>
		</transition>
		<transition>
			<source ref="id368"/>
			<target ref="id373"/>
			<label kind="guard" x="-153" y="-280">currH==id</label>
			<nail x="-229" y="-246"/>
			<nail x="-229" y="-399"/>
		</transition>
		<transition>
			<source ref="id370"/>
			<target ref="id365"/>
			<label kind="synchronisation" x="-136" y="-663">publish_m[2]!</label>
			<label kind="assignment" x="-136" y="-646">tUpd=0</label>
			<nail x="-85" y="-569"/>
		</transition>
		<transition>
			<source ref="id371"/>
			<target ref="id370"/>
			<label kind="guard" x="-178" y="-714">currH==id</label>
			<label kind="synchronisation" x="-161" y="-697">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id365"/>
			<target ref="id371"/>
			<label kind="guard" x="-289" y="-663">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-289" y="-646">updateF(-mi, 0), 
tUpd=0</label>
		</transition>
		<transition>
			<source ref="id369"/>
			<target ref="id362"/>
			<label kind="synchronisation" x="68" y="-357">publish_m[2]!</label>
			<label kind="assignment" x="59" y="-374">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id368"/>
			<target ref="id369"/>
			<label kind="guard" x="17" y="-306">currH==id</label>
			<label kind="synchronisation" x="17" y="-272">publish_m[3]!</label>
		</transition>
		<transition color="#00ff00">
			<source ref="id362"/>
			<target ref="id368"/>
			<label kind="guard" x="204" y="-314">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="204" y="-297">updateF(-lambda, 1),
updateP(), tUpd=0,
id_out=out_id()</label>
			<nail x="195" y="-399"/>
			<nail x="195" y="-246"/>
		</transition>
		<transition>
			<source ref="id367"/>
			<target ref="id361"/>
			<label kind="synchronisation" x="-637" y="-331">publish_m[2]!</label>
			<label kind="assignment" x="-637" y="-314">tUpd=0</label>
			<nail x="-578" y="-399"/>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id367"/>
			<label kind="guard" x="-561" y="-289">currH==id</label>
			<label kind="synchronisation" x="-561" y="-306">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id361"/>
			<label kind="guard" x="-484" y="-297">currH!=id</label>
			<nail x="-493" y="-314"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id361"/>
			<target ref="id366"/>
			<label kind="guard" x="-399" y="-357">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-399" y="-340">updateF(-mi, 0), 
tUpd=0, 
id_out = out_id()</label>
			<nail x="-408" y="-399"/>
			<nail x="-408" y="-246"/>
		</transition>
		<transition>
			<source ref="id365"/>
			<target ref="id361"/>
			<label kind="synchronisation" x="-484" y="-569">stop_h_action?</label>
			<label kind="assignment" x="-484" y="-620">t = 0, Fp = F,

tUpd=0</label>
			<nail x="-493" y="-569"/>
		</transition>
		<transition>
			<source ref="id362"/>
			<target ref="id365"/>
			<label kind="guard" x="-17" y="-552">currH==id</label>
			<label kind="synchronisation" x="-17" y="-569">start_h_action?</label>
			<label kind="assignment" x="-17" y="-620">t = 0, Fp = F, 
tUpd=0</label>
			<nail x="119" y="-569"/>
		</transition>
		<transition>
			<source ref="id361"/>
			<target ref="id365"/>
			<label kind="guard" x="-357" y="-518">currH==id</label>
			<label kind="synchronisation" x="-357" y="-501">start_h_action?</label>
			<label kind="assignment" x="-357" y="-484">F = 0, t = 0,
tUpd=0</label>
			<nail x="-365" y="-399"/>
			<nail x="-365" y="-569"/>
		</transition>
		<transition>
			<source ref="id362"/>
			<target ref="id364"/>
			<label kind="guard" x="137" y="-416">F &gt;= passout_th</label>
			<label kind="synchronisation" x="162" y="-399">h_fail!</label>
			<label kind="assignment" x="213" y="-382">t = 0</label>
		</transition>
		<transition>
			<source ref="id364"/>
			<target ref="id364"/>
			<nail x="247" y="-348"/>
			<nail x="289" y="-348"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id363"/>
			<target ref="id361"/>
			<label kind="assignment" x="-671" y="-416">initHuman()
,id_out= out_id()</label>
		</transition>
		<transition>
			<source ref="id374"/>
			<target ref="id374"/>
			<nail x="-663" y="-535"/>
			<nail x="-663" y="-501"/>
		</transition>
		<transition>
			<source ref="id361"/>
			<target ref="id374"/>
			<label kind="guard" x="-765" y="-510">PATH!=0
            &amp;&amp; PATH!=path</label>
			<nail x="-722" y="-459"/>
		</transition>
</template>
