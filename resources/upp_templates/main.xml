<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
<declaration>
/**
*** CHANNELS
**/

// Human Channels
broadcast chan pass_out, free_start, free_stop, start_h_action, stop_h_action;

// Robot Channels
broadcast chan start_recharging[int], stop_recharging, start_r_action, stop_r_action, r_still;

// Battery Channels
broadcast chan dead_battery;

// Orchestrator Channels
broadcast chan opchk_start, opchk_stop, opchk_scs, opchk_fail;
broadcast chan publish_m[int];

/**
*** CONSTANTS
**/
const double PI = 3.1415926535;
const double INT16_MAX = 32767.0;


// Human Fatigue Profiles [fatiguing rate, recovery rate]
// MET = ln(1-epsilon)/(-lambda)
const double YOUNG_HEALTHY[2] = {0.0005, 0.0005}; // approx. 1380s

// Pre-Simulation

const double YOUNG_SICK[2] = {0.001865, 0.005117}; 
const double YOUNG_SICK_SIGMA[2] = {0.000719, 0.000001};

const double ELDERLY_HEALTHY[2] = {0.000409, 0.000450}; 
const double ELDERLY_HEALTHY_SIGMA[2] = {0.000091, 0.000119}; 

// Post-Simulation
/*
const double YOUNG_SICK[2] = {0.004538, 0.003328}; 
const double YOUNG_SICK_SIGMA[2] = {0.000469, 0.001342};

const double ELDERLY_HEALTHY[2] = {0.000553, 0.000302}; 
const double ELDERLY_HEALTHY_SIGMA[2] = {0.004548, 0.000175}; 
*/

//
const double ELDERLY_SICK[2] = {0.005, 0.004}; // approx. 350s 
const double COVID_PATIENT[2] = {0.025, 0.001}; // approx. 280s

// Human Free Will Profiles
const int GROWN_UP = 99;
const int CHILD_LIKE = 80;
const int WHATEVER = 101;

/**
*** VARIABLES
**/

// Mission Mgmt
int currOp[2] = {1, 1};     //NUM_ROBOTS = 2
double dX[2], dY[2];        //NUM_ROBOTS = 2

bool stop[2] = {false, false};
bool startHuman = false;
bool stopHuman = false;
bool exeRobot = false;
bool fail = false;
bool scs = false;
//
const int MAX_BUFF_SIZE = 10;

// Robot Mgmt
const int NUM_ROBOTS = 2;
bool active_robot[NUM_ROBOTS] = {true, false};    //used due to lack of array of broadcast channels (initial currR = 1)
int currR = 1; //current robot
int coR = -1;  //co-robot
bool synch = false;    //used to check if the syncrhonization between the two robots has happened (task handover pattern)

// Human Mgmt
int currH = 1;
int hExe = 0;

// Sensor Outputs
double batteryCharge[NUM_ROBOTS];
double internal_charge[NUM_ROBOTS] = {-1.0, -1.0};

double robPositionX[NUM_ROBOTS];
double robPositionY[NUM_ROBOTS];
double internalRobX[NUM_ROBOTS], internalRobY[NUM_ROBOTS];

/**
* MISSION DEFINITION
**/

// -&gt; HOW MANY HUMANS TO SERVE IN THE MISSION
const int H = **N_H**

bool served[H] = **N_H_false**
bool objectTaken[H] = **N_H_false**
double humanFatigue[H] = **N_H_0.0**
double humanPositionX[H] = **N_H_0.0**
double humanPositionY[H] = **N_H_0.0**
double humTheta[H] = **N_H_0.0**

double internalFatigue[H] = **N_H_0.0**
double internalHumX[H] = **N_H_0.0**
double internalHumY[H] = **N_H_0.0**

const int ND = -1;
const double NDD = -1.0;
int PATH = 0;

int SAME_H_IDs[H][H] = {{1, ND}, {2, ND}};

//int SAME_H_IDs[H][H] = {{1, 5, ND, ND, ND, ND}, {2, ND, ND, ND, ND, ND}, {3, 4, 6, ND, ND, ND}, 
//                    {4, 3, 6, ND, ND, ND}, {5, 1, ND, ND, ND, ND}, {6, 3, 4, ND, ND, ND}};

// -&gt; DEFINE PATTERN SEQUENCE (make sure it is consistent with humans ids)
// 0: human follower, 1: human leader, 2: human recipient, 3: human assistant, 
// 10: human_rescuer, (11: human_interdependence_mission,) 12: human competitor
int patterns[H] = **PTRNS**
int patterns_alt1[H] = **N_H_0**
int patterns_alt2[H] = **N_H_0**
//

// -&gt; DEFINE DESTINATIONS IN CARTESIAN PLAN
// the definition of destination can vary depending on the pattern,
// and you can decide what it corresponds to for your specific pattern
double destX[H] = **DEST_X**
double destY[H] = **DEST_Y**

const double destX_alt1[H] = **N_H_0.0**
const double destY_alt1[H] = **N_H_0.0**
const double destX_alt2[H] = **N_H_0.0**
const double destY_alt2[H] = **N_H_0.0**

// -&gt; DEFINE BOUND FOR QUERIES 
// (you can refine it by examining simulations)
const int TAU = **TAU**;
//

const int task_size = 150;
int dext = 1;
int task_completion = 0;

/**
*** FLOOR PLAN
**/
const int N_A = **N_A**
const int N_P = **N_P**
const int N_I = **N_I**

typedef double point[2];
typedef point area[4];
typedef area layout[N_A];
typedef point trajectory[N_P];

const layout FLOOR = **LAYOUT**
const point INTERSECTIONS[N_I] = **INTERSECTIONS**

// I apologize for the four doubles, 
// but it seems to be bugging when arrays are passed as arguments.
bool same_area(double sx, double sy, double dx, double dy) {
    int i;
    bool x_s_in, y_s_in, x_d_in, y_d_in;
    for (i = 0; i &lt; N_A; i++)
    {
        x_s_in = sx &gt; FLOOR[i][0][0] &amp;&amp; sx &lt; FLOOR[i][3][0];
        y_s_in = sy &gt; FLOOR[i][0][1] &amp;&amp; sy &lt; FLOOR[i][1][1];
        x_d_in = dx &gt; FLOOR[i][0][0] &amp;&amp; dx &lt; FLOOR[i][3][0];
        y_d_in = dy &gt; FLOOR[i][0][1] &amp;&amp; dy &lt; FLOOR[i][1][1];
        if ((x_s_in &amp;&amp; y_s_in) &amp;&amp; (x_d_in &amp;&amp; y_d_in)) // start and dest in same area
            return true;
    }
    return false;
}

// same.
double pt_dist(double x1, double x2, double y1, double y2) {
    double xdifference = x2-x1;
    double ydifference = y2-y1;
    return sqrt((xdifference*xdifference)+(ydifference*ydifference));
}

double calculateDistance() {
    double xdifference = pow(robPositionX[currR-1]-humanPositionX[currH-1], 2);
    double ydifference = pow(robPositionY[currR-1]-humanPositionY[currH-1], 2);
    double distance = sqrt(xdifference + ydifference)/100;
    if(distance&lt;0) {
        return -distance;
    } else {
        return distance;
    }
}

// Wall Corner Points
const point rechargeStation = {220.0, 320.00};
</declaration>
**HUMAN_ASSISTANT**
**HUMAN_COMPETITOR**
**HUMAN_FOLLOWER**
**HUMAN_LEADER**
**HUMAN_RECIPIENT**
**HUMAN_RESCUER**
**ROBOT**
**BATTERY**
**ORCHESTRATOR**
**OPCHK**
**ROS**
	<system>
// Robot Instances
**ROB_INST**
//

// Controller Instances (one for each robot)
**ORCH_INST**
//

/**
* MISSION DEFINITION
**/

// Human Instances
// -&gt; DEFINE HUMAN PATTERNS
**HUM_INST**
//

system 
**ALL_INST**
;
</system>
<queries>
</queries>
</nta>
