<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
<declaration>
/**
*** CHANNELS
**/

// Human Channels
broadcast chan pass_out, free_start, free_stop, start_h_action, stop_h_action;

// Robot Channels
broadcast chan start_recharging[int], stop_recharging, start_r_action, stop_r_action, r_still;

// Battery Channels
broadcast chan dead_battery;

// Orchestrator Channels
broadcast chan opchk_start, opchk_stop, opchk_scs, opchk_fail;
broadcast chan publish_m[int];

/**
*** CONSTANTS
**/
const double PI = 3.1415926535;
const double INT16_MAX = 32767.0;


// Human Fatigue Profiles [fatiguing rate, recovery rate]
// MET = ln(1-epsilon)/(-lambda)
const double YOUNG_HEALTHY[2] = {0.0005, 0.0005}; // approx. 1380s

// Pre-Simulation

const double YOUNG_SICK[2] = {0.001865, 0.005117}; 
const double YOUNG_SICK_SIGMA[2] = {0.000719, 0.000001};

const double ELDERLY_HEALTHY[2] = {0.000409, 0.000450}; 
const double ELDERLY_HEALTHY_SIGMA[2] = {0.000091, 0.000119}; 

// Post-Simulation
/*
const double YOUNG_SICK[2] = {0.004538, 0.003328}; 
const double YOUNG_SICK_SIGMA[2] = {0.000469, 0.001342};

const double ELDERLY_HEALTHY[2] = {0.000553, 0.000302}; 
const double ELDERLY_HEALTHY_SIGMA[2] = {0.004548, 0.000175}; 
*/

//
const double ELDERLY_SICK[2] = {0.005, 0.004}; // approx. 350s 
const double COVID_PATIENT[2] = {0.025, 0.001}; // approx. 280s

// Human Free Will Profiles
const int NORMAL = 99;
const int HIGH = 80;
const int DISABLED = 101;

/**
*** VARIABLES
**/

// Mission Mgmt
const int R = 2;

int currOp[R] = {1,1}; 
double dX[R], dY[R];  

bool stop[R] = {false,false};
bool startHuman = false;
bool stopHuman = false;
bool exeRobot = false;
bool fail = false;
bool scs = false;
//
const int MAX_BUFF_SIZE = 10;

// Robot Mgmt
bool active_robot[R] = {true,false};
int currR = 1; //current robot
int coR = -1;  //co-robot
bool synch = false;    //used to check if the syncrhonization between the two robots has happened (task handover pattern)
/*
** Added for multi-robot TESTING
*/
bool busy[R] = {false,false};

// Human Mgmt
int currH = 1;
int hExe = 0;

// Sensor Outputs
double batteryCharge[R] = {100.0,100.0};
double internal_charge[R] = {-1.0,-1.0};

double robPositionX[R];
double robPositionY[R];
double internalRobX[R], internalRobY[R];

/**
* MISSION DEFINITION
**/

// -&gt; HOW MANY HUMANS TO SERVE IN THE MISSION
const int H = 6;


bool served[H] = {false,false,false,false,false,false};
bool objectTaken[H] = {false,false,false,false,false,false};
double humanFatigue[H] = {0.0,0.0,0.0,0.0,0.0,0.0};
double humanPositionX[H] = {0.0,0.0,0.0,0.0,0.0,0.0};
double humanPositionY[H] = {0.0,0.0,0.0,0.0,0.0,0.0};
double humTheta[H] = {0.0,0.0,0.0,0.0,0.0,0.0};

double internalFatigue[H] = {0.0,0.0,0.0,0.0,0.0,0.0};
double internalHumX[H] = {0.0,0.0,0.0,0.0,0.0,0.0};
double internalHumY[H] = {0.0,0.0,0.0,0.0,0.0,0.0};

const int ND = -1;
const double NDD = -1.0;
int PATH = 0;

int SAME_H_IDs[H][H] = {{1,7,-1,-1,-1,-1,-1,-1},{2,-1,-1,-1,-1,-1,-1,-1},{3,4,6,-1,-1,-1,-1,-1},{4,3,6,8,-1,-1,-1,-1},{5,-1,-1,-1,-1,-1,-1,-1},{6,3,4,-1,-1,-1,-1,-1},{7,1,-1,-1,-1,-1,-1,-1},{8,4,-1,-1,-1,-1,-1,-1}};
// int SAME_H_IDs[H][H] = {{1, 5, ND, ND, ND, ND}, {2, ND, ND, ND, ND, ND}, {3, 4, 6, ND, ND, ND},
//                    {4, 3, 6, ND, ND, ND}, {5, 1, ND, ND, ND, ND}, {6, 3, 4, ND, ND, ND}};

// -&gt; DEFINE PATTERN SEQUENCE (make sure it is consistent with humans ids)
// 0: human follower, 1: human leader, 2: human recipient, 3: human applicant,
// 10: human_rescuer, (11: human_interdependence_mission,) 12: human competitor
int patterns[H] = {0,12,ND,ND,0,3};
int patterns_alt1[H]; // = {0, 12, 10, 2, 0, 3}; //robot wins competition
int patterns_alt2[H]; // = {0, 12, 1, 1, 0, 3}; //robot loses competition
//

// -&gt; DEFINE STARTING LOCATIONS IN CARTESIAN PLAN
double startX[H] = {220.0,4300.0,0.0,0.0,4300.0,2000.0};
double startY[H] = {300.0,350.0,0.0,0.0,300.0,300.0};

double startX_alt1[H]; // = {220.0,4300.0,700.0,2000.0,400.0,400.0};
double startY_alt1[H]; // = {300.0,300.0,300.0,300.0,150.0,150.0};
double startX_alt2[H]; // = {220.0,4300.0,2000.0,4300.0,400.0,400.0};
double startY_alt2[H]; // = {300.0,300.0,300.0,200.0,150.0,150.0};

// -&gt; DEFINE DESTINATIONS IN CARTESIAN PLAN
// the definition of destination can vary depending on the pattern,
// and you can decide what it corresponds to for your specific pattern
double destX[H] = {4300.0,4300.0,0.0,0.0,2000.0,2000.0};
double destY[H] = {300.0,400.0,0.0,0.0,300.0,300.0};

double destX_alt1[H]; // = {4300.0, 4300.0, 2000.0, 2000.0, 2000.0, 2000.0}; //robot wins competition
double destY_alt1[H]; // = {300.0, 500.0, 300.0, 300.0, 300.0, 300.0};
double destX_alt2[H]; // = {4300.0, 4300.0, 4300.0, 2000.0, 2000.0, 2000.0}; //robot loses competition
double destY_alt2[H]; // = {300.0, 500.0, 200.0, 300.0, 300.0, 300.0};

/**
* PARAMS FOR RESCUER AND APPLICANT (task size and dexterity)
**/

const int task_size = 150;
int dext = 1;
int task_completion = 0;

/**
*** FLOOR PLAN
**/
const int N_A = 10;

const int N_P = 10;

const int N_I = 9;


typedef double point[2];
typedef point area[4];
typedef area layout[N_A];
typedef point trajectory[N_P];

const layout FLOOR = {{{0.0, 110.0},{0.0, 299.5},{1550.0, 299.5},{1550.0, 110.0}},{{0.0, 110.0},{0.0, 850.0},{185.0, 850.0},{185.0, 110.0}},{{0.0, 672.5},{0.0, 850.0},{1550.0, 850.0},{1550.0, 672.5}},{{1352.0, 110.0},{1352.0, 850.0},{1550.0, 850.0},{1550.0, 110.0}},{{2970.0, 110.0},{2970.0, 299.5},{4512.5, 299.5},{4512.5, 110.0}},{{2970.0, 110.0},{2970.0, 850.0},{3155.0, 850.0},{3155.0, 110.0}},{{2970.0, 672.5},{2970.0, 850.0},{4512.5, 850.0},{4512.5, 672.5}},{{4322.0, 110.0},{4322.0, 850.0},{4512.5, 850.0},{4512.5, 110.0}},{{1945.0, 0.0},{1945.0, 695.0},{2670.0, 695.0},{2670.0, 0.0}},{{1352.0, 110.0},{1352.0, 425.0},{3155.0, 425.0},{3155.0, 110.0}}};

const point INTERSECTIONS[N_I] = {{92.5, 163.5},{92.5, 761.2},{1452.0, 761.2},{1452.0, 163.5},{3062.5, 163.5},{4417.0, 163.5},{3062.5, 761.2},{4417.0, 761.2},{2253.5, 267.5}};


// I apologize for the four doubles, 
// but it seems to be bugging when arrays are passed as arguments.
bool same_area(double sx, double sy, double dx, double dy) {
    int i;
    bool x_s_in, y_s_in, x_d_in, y_d_in;
    for (i = 0; i &lt; N_A; i++)
    {
        x_s_in = sx &gt; FLOOR[i][0][0] &amp;&amp; sx &lt; FLOOR[i][3][0];
        y_s_in = sy &gt; FLOOR[i][0][1] &amp;&amp; sy &lt; FLOOR[i][1][1];
        x_d_in = dx &gt; FLOOR[i][0][0] &amp;&amp; dx &lt; FLOOR[i][3][0];
        y_d_in = dy &gt; FLOOR[i][0][1] &amp;&amp; dy &lt; FLOOR[i][1][1];
        if ((x_s_in &amp;&amp; y_s_in) &amp;&amp; (x_d_in &amp;&amp; y_d_in)) // start and dest in same area
            return true;
    }
    return false;
}

// same.
double pt_dist(double x1, double x2, double y1, double y2) {
    double xdifference = x2-x1;
    double ydifference = y2-y1;
    return sqrt((xdifference*xdifference)+(ydifference*ydifference));
}

double calculateDistance() {
    double xdifference = pow(robPositionX[currR-1]-humanPositionX[currH-1], 2);
    double ydifference = pow(robPositionY[currR-1]-humanPositionY[currH-1], 2);
    double distance = sqrt(xdifference + ydifference)/100;
    if(distance&lt;0) {
        return -distance;
    } else {
        return distance;
    }
}

// Wall Corner Points
const point rechargeStation = {220.0, 320.00};
</declaration>
    <template>
        <name>Human_Follower_3</name>
        <parameter>int id, double _v, int p_f, int p_fw, int start_from, int path</parameter>
        <declaration>clock t, F, Fp;
clock tUpd;
double freeWill;

double lambda, mi;
const double passout_th = 1.0;

bool run, harsh, carrying, assisted;
int v;

// Free Will Model
int obey = 100;
int disobey = 0;
int freeWillRange = 100;
int freeWillTh = 101;

// Fatigue Sharing Parameters
const int Tpoll = 1;

bool ONCE_FTG = true;
bool ONCE_POS = true;

bool sat_once = false;

void updateF(double coeff, bool walking) { 
    // if two human instances are the same person,
    // residual conditions must be retrieved
    if (ONCE_FTG &amp;&amp; start_from!=-1 &amp;&amp; currH==id) {
        F = internalFatigue[start_from-1]; 
        Fp = F;
        internalFatigue[id-1] = F;
    }
    // same as ONCE_FTG
    if (ONCE_POS &amp;&amp; start_from!=-1) {
        humanPositionX[id-1] = internalHumX[start_from-1];
        humanPositionY[id-1] = internalHumY[start_from-1];
        internalHumX[id-1] = humanPositionX[id-1];
        internalHumY[id-1] = humanPositionY[id-1];
    } 
 
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll); 
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
    curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void updateP() {
    double eps = 0.0;
    bool x_in, y_in;
    if(ONCE_FTG &amp;&amp; ONCE_POS) {
        ONCE_FTG = false;
        ONCE_POS = false;
    }

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
        return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 50.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
            return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }
    
    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

bool emergency_() {
    return random(100.0)&gt;=95.0;
    /**
    bool x_in, y_in;
    x_in = internalHumX[id-1]&gt;=3000.0 &amp;&amp; internalHumX[id-1]&lt;=4000.0;
    y_in = internalHumY[id-1]&gt;=200.0 &amp;&amp; internalHumY[id-1]&lt;=400.0;
    return x_in &amp;&amp; y_in;
    **/
}

bool should_sit(int ref_id) {
    bool x_in, y_in;
    x_in = internalHumX[ref_id-1]&gt;=4300.0 &amp;&amp; internalHumX[ref_id-1]&lt;=4800.0;
    y_in = internalHumY[ref_id-1]&gt;=200.0 &amp;&amp; internalHumY[ref_id-1]&lt;=500.0;
    return x_in &amp;&amp; y_in;
}

void update_ftg_rates() {
    // unfortunately the switch case is not supported yet
    /*
    if(p_f==1) {
        if(should_sit(id)) mi = random_normal(YOUNG_HEALTHY_2[1], YOUNG_HEALTHY_SIGMA_2[1]);
        else mi = random_normal(YOUNG_HEALTHY[1], YOUNG_HEALTHY_SIGMA[1]);
        if(emergency()) lambda = random_normal(YOUNG_HEALTHY_3[0], YOUNG_HEALTHY_SIGMA_3[0]);
        else lambda = random_normal(YOUNG_HEALTHY[0], YOUNG_HEALTHY_SIGMA[0]);
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]); 
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]); 
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }
    */
    if(should_sit(id)) mi = random_normal(0.0049, 0.0003);
    else if(run) mi = random_normal(0.0017, 0.0003);
    else if(harsh) mi = random_normal(0.0001, 0.0001);
    else if(carrying) mi = random_normal(0.0005, 0.0003);
    else mi = random_normal(0.0024, 0.0002);

    if(mi&lt;=0.0) mi=mi*-1.0;

    if(run) lambda = random_normal(0.006, 0.0004);
    else if(harsh) lambda = random_normal(0.01, 0.0005);
    else if(carrying) lambda = random_normal(0.003, 0.0004);
    else if(assisted) lambda = random_normal(0.0001, 0.0003);
    else lambda = random_normal(0.0006, 0.0004);

    if(lambda&lt;=0.0) lambda=lambda*-1.0;
}

void updateFreeWill(){
    double dice; 

    if(currH==id) { //if human is being served, they are entitled to free will
        obey = 99;
        disobey = 1;
    } else { //if human is not currently active, no one cares about their free will
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20; // freeWill is assigned in range [0, 10] and to trigger it should be &gt;20
    }

    dice = random(100.0);
    if(dice&gt;=90.0) harsh = !harsh;
    dice = random(100.0);
    if(dice&gt;=90.0) assisted = !assisted;
    dice = random(100.0);
    if(dice&gt;=90.0) carrying = !carrying;
    dice = random(100.0);
    if(dice&gt;=90.0) run = !run;
    
    update_ftg_rates();
}

void initHuman() {
    t = 0;
    tUpd = 0;
    F = 0; 
    Fp = 0;
    v = fint(_v);
    
    if(start_from!=-1) sat_once = true;

    humanPositionX[id-1] = startX[id-1];
    humanPositionY[id-1] = startY[id-1];
    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    update_ftg_rates();

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}
</declaration>
        <location id="id0" x="-620" y="229" color="#ff0000">
            <name x="-662" y="212">running</name>
            <label kind="invariant" x="-892" y="178">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id1" x="-391" y="-255" color="#00ffff">
            <name x="-426" y="-246">idle</name>
            <label kind="invariant" x="-484" y="-229">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id2" x="-790" y="68">
            <committed/>
        </location>
        <location id="id3" x="-646" y="76">
            <committed/>
        </location>
        <location id="id4" x="-569" y="-51">
            <committed/>
        </location>
        <location id="id5" x="221" y="-255" color="#ff0000">
            <name x="238" y="-289">busy</name>
            <label kind="invariant" x="238" y="-374">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id6" x="-585" y="-254">
            <name x="-628" y="-271">Init</name>
            <committed/>
        </location>
        <location id="id7" x="374" y="-255">
            <name x="391" y="-272">passed_out</name>
            <label kind="invariant" x="391" y="-255">t' == 0 &amp;&amp;
F' == 0</label>
            <label kind="exponentialrate" x="366" y="-238">1</label>
        </location>
        <location id="id8" x="60" y="-357">
            <name x="50" y="-391">c2</name>
            <committed/>
        </location>
        <location id="id9" x="-390" y="-476">
            <name x="-400" y="-510">p_2</name>
            <committed/>
        </location>
        <location id="id10" x="221" y="-34">
            <name x="211" y="-68">p_4</name>
            <committed/>
        </location>
        <location id="id11" x="-390" y="-366">
            <name x="-400" y="-400">p_1</name>
            <committed/>
        </location>
        <location id="id12" x="221" y="-119">
            <name x="211" y="-153">p_3</name>
            <committed/>
        </location>
        <location id="id13" x="221" y="-824" color="#00ffff">
            <name x="187" y="-850">sit</name>
            <label kind="invariant" x="246" y="-867">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id14" x="221" y="-527">
            <name x="178" y="-544">c_3</name>
            <committed/>
        </location>
        <location id="id15" x="-204" y="-357">
            <committed/>
        </location>
        <location id="id16" x="144" y="-527">
            <committed/>
        </location>
        <location id="id17" x="221" y="-926">
            <name x="211" y="-960">p_5</name>
            <committed/>
        </location>
        <location id="id18" x="221" y="-1037">
            <name x="211" y="-1071">p_6</name>
            <committed/>
        </location>
        <location id="id19" x="221" y="-739">
            <committed/>
        </location>
        <location id="id20" x="-654" y="348">
            <name x="-664" y="314">p_7</name>
            <committed/>
        </location>
        <location id="id21" x="-782" y="459">
            <name x="-799" y="476">p_8</name>
            <committed/>
        </location>
        <location id="id22" x="34" y="-127">
            <committed/>
        </location>
        <location id="id23" x="-926" y="-637" color="#ff0000">
            <name x="-1028" y="-663">assisted_walk</name>
            <label kind="invariant" x="-1045" y="-637">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id24" x="-314" y="-892" color="#ff0000">
            <name x="-324" y="-926">carrying_l</name>
            <label kind="invariant" x="-323" y="-1011">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id25" x="-841" y="-841">
            <committed/>
        </location>
        <location id="id26" x="-416" y="-994">
            <committed/>
        </location>
        <location id="id27" x="-841" y="-994">
            <committed/>
        </location>
        <location id="id28" x="-527" y="-1054">
            <committed/>
        </location>
        <location id="id29" x="136" y="519">
            <committed/>
        </location>
        <location id="id30" x="136" y="289" color="#ff0000">
            <name x="126" y="255">harsh_w</name>
            <label kind="invariant" x="153" y="272">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id31" x="136" y="400">
            <committed/>
        </location>
        <location id="id32" x="-535" y="-501">
            <committed/>
        </location>
        <location id="id33" x="-688" y="-586">
            <committed/>
        </location>
        <location id="id34" x="-756" y="-544">
            <committed/>
        </location>
        <location id="id35" x="-374" y="-756">
            <committed/>
        </location>
        <location id="id36" x="-246" y="-620">
            <committed/>
        </location>
        <location id="id37" x="-221" y="-765">
            <committed/>
        </location>
        <location id="id38" x="51" y="204">
            <committed/>
        </location>
        <location id="id39" x="-93" y="136">
            <committed/>
        </location>
        <location id="id40" x="-153" y="170">
            <committed/>
        </location>
        <location id="id41" x="782" y="213" color="#00ffff">
            <name x="772" y="179">harsh_sit</name>
            <label kind="invariant" x="773" y="111">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id42" x="883" y="-476" color="#00ffff">
            <name x="873" y="-510">harsh_s</name>
            <label kind="invariant" x="875" y="-587">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id43" x="-119" y="799" color="#00ffff">
            <name x="-212" y="816">sit_after_run</name>
            <label kind="invariant" x="-212" y="833">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
        </location>
        <location id="id44" x="1070" y="-476">
            <committed/>
        </location>
        <location id="id45" x="1181" y="-476">
            <committed/>
        </location>
        <location id="id46" x="960" y="221">
            <committed/>
        </location>
        <location id="id47" x="1096" y="221">
            <committed/>
        </location>
        <location id="id48" x="17" y="875">
            <committed/>
        </location>
        <location id="id49" x="119" y="918">
            <committed/>
        </location>
        <location id="id50" x="-178" y="484">
            <committed/>
        </location>
        <location id="id51" x="-238" y="688">
            <committed/>
        </location>
        <location id="id52" x="-323" y="561">
            <committed/>
        </location>
        <location id="id53" x="620" y="144">
            <committed/>
        </location>
        <location id="id54" x="382" y="178">
            <committed/>
        </location>
        <location id="id55" x="586" y="357">
            <committed/>
        </location>
        <location id="id56" x="892" y="-205">
            <committed/>
        </location>
        <location id="id57" x="654" y="-171">
            <committed/>
        </location>
        <location id="id58" x="756" y="8">
            <committed/>
        </location>
        <location id="id59" x="807" y="-697">
            <committed/>
        </location>
        <location id="id60" x="731" y="-884">
            <committed/>
        </location>
        <location id="id61" x="-25" y="-1147">
            <committed/>
        </location>
        <location id="id62" x="170" y="680">
            <committed/>
        </location>
        <location id="id63" x="323" y="527">
            <committed/>
        </location>
        <branchpoint id="id64" x="238" y="629">
        </branchpoint>
        <branchpoint id="id65" x="765" y="-807">
        </branchpoint>
        <branchpoint id="id66" x="170" y="-1181">
        </branchpoint>
        <branchpoint id="id67" x="586" y="263">
        </branchpoint>
        <branchpoint id="id68" x="510" y="153">
        </branchpoint>
        <branchpoint id="id69" x="-144" y="552">
        </branchpoint>
        <branchpoint id="id70" x="-263" y="637">
        </branchpoint>
        <branchpoint id="id71" x="-229" y="-697">
        </branchpoint>
        <branchpoint id="id72" x="-382" y="-663">
        </branchpoint>
        <branchpoint id="id73" x="-612" y="-535">
        </branchpoint>
        <branchpoint id="id74" x="-680" y="-459">
        </branchpoint>
        <branchpoint id="id75" x="-76" y="-127">
        </branchpoint>
        <branchpoint id="id76" x="-671" y="-102">
        </branchpoint>
        <branchpoint id="id77" x="-646" y="8">
        </branchpoint>
        <branchpoint id="id78" x="144" y="-824">
        </branchpoint>
        <branchpoint id="id79" x="221" y="-663">
        </branchpoint>
        <branchpoint id="id80" x="-76" y="-357">
        </branchpoint>
        <branchpoint id="id81" x="-8" y="127">
        </branchpoint>
        <branchpoint id="id82" x="-297" y="110">
        </branchpoint>
        <branchpoint id="id83" x="841" y="-17">
        </branchpoint>
        <branchpoint id="id84" x="782" y="-196">
        </branchpoint>
        <init ref="id6"/>
        <transition color="#c0c0c0">
            <source ref="id1"/>
            <target ref="id13"/>
            <label kind="guard" x="-42" y="-697">currH==id
&amp;&amp; start_from!=-1
&amp;&amp; should_sit(start_from)</label>
            <label kind="assignment" x="-42" y="-646">tUpd=0, t=0,
sat_once = true,
updateFreeWill()</label>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id5"/>
            <label kind="guard" x="-8" y="552">currH==id
&amp;&amp; !run
&amp;&amp; !harsh 
&amp;&amp; !carrying
&amp;&amp; !assisted
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-8" y="663">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="85" y="620"/>
            <nail x="297" y="518"/>
            <nail x="297" y="425"/>
            <nail x="178" y="178"/>
            <nail x="144" y="-17"/>
        </transition>
        <transition>
            <source ref="id63"/>
            <target ref="id5"/>
            <label kind="assignment" x="323" y="467">Fp=1-F,
plan_traj()</label>
            <nail x="323" y="425"/>
            <nail x="187" y="153"/>
        </transition>
        <transition>
            <source ref="id64"/>
            <target ref="id63"/>
            <label kind="assignment" x="255" y="561">t = 0, 
tUpd=0</label>
            <label kind="probability" x="256" y="599">obey</label>
        </transition>
        <transition>
            <source ref="id64"/>
            <target ref="id43"/>
            <label kind="probability" x="102" y="620">disobey</label>
            <nail x="102" y="654"/>
        </transition>
        <transition>
            <source ref="id62"/>
            <target ref="id64"/>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id62"/>
            <label kind="guard" x="-101" y="705">!run</label>
            <label kind="synchronisation" x="-101" y="722">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id24"/>
            <label kind="guard" x="637" y="-1173">currH==id &amp;&amp; carrying
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="663" y="-1130">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="867" y="-688"/>
            <nail x="680" y="-1113"/>
            <nail x="527" y="-1266"/>
            <nail x="-59" y="-1266"/>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id42"/>
            <label kind="guard" x="416" y="-1037">currH==id 
&amp;&amp; harsh
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="450" y="-977">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="127" y="-1113"/>
            <nail x="391" y="-1113"/>
            <nail x="535" y="-952"/>
            <nail x="722" y="-561"/>
        </transition>
        <transition>
            <source ref="id60"/>
            <target ref="id24"/>
            <label kind="assignment" x="629" y="-994">Fp=1-F,
plan_traj()</label>
            <nail x="586" y="-1105"/>
            <nail x="467" y="-1232"/>
            <nail x="0" y="-1232"/>
        </transition>
        <transition>
            <source ref="id65"/>
            <target ref="id60"/>
            <label kind="assignment" x="714" y="-858">t = 0, 
tUpd=0</label>
            <label kind="probability" x="748" y="-828">obey</label>
        </transition>
        <transition>
            <source ref="id65"/>
            <target ref="id42"/>
            <label kind="probability" x="748" y="-680">disobey</label>
            <nail x="756" y="-739"/>
            <nail x="799" y="-612"/>
        </transition>
        <transition>
            <source ref="id59"/>
            <target ref="id65"/>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id59"/>
            <label kind="guard" x="816" y="-637">carrying
&amp;&amp; currH == id</label>
            <label kind="synchronisation" x="825" y="-603">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id66"/>
            <target ref="id42"/>
            <label kind="assignment" x="204" y="-1181">t = 0, Fp=F,  tUpd=0,
updateFreeWill()</label>
            <label kind="probability" x="204" y="-1198">obey</label>
            <nail x="408" y="-1181"/>
            <nail x="578" y="-986"/>
            <nail x="739" y="-620"/>
        </transition>
        <transition>
            <source ref="id66"/>
            <target ref="id24"/>
            <label kind="probability" x="-33" y="-1109">disobey</label>
            <nail x="-51" y="-1071"/>
        </transition>
        <transition>
            <source ref="id61"/>
            <target ref="id66"/>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id61"/>
            <label kind="guard" x="-296" y="-1053">harsh</label>
            <label kind="synchronisation" x="-296" y="-1036">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id30"/>
            <label kind="guard" x="510" y="-382">currH==id &amp;&amp; harsh
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="510" y="-348">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="526" y="-212"/>
            <nail x="297" y="-93"/>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id30"/>
            <label kind="assignment" x="518" y="-145">Fp=1-F,
plan_traj()</label>
            <nail x="365" y="-68"/>
        </transition>
        <transition>
            <source ref="id84"/>
            <target ref="id57"/>
            <label kind="assignment" x="705" y="-178">t = 0, 
tUpd=0</label>
            <label kind="probability" x="705" y="-195">obey</label>
        </transition>
        <transition>
            <source ref="id84"/>
            <target ref="id42"/>
            <label kind="probability" x="800" y="-319">disobey</label>
        </transition>
        <transition>
            <source ref="id56"/>
            <target ref="id84"/>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id56"/>
            <label kind="guard" x="850" y="-306">!run &amp;&amp; 
currH==id</label>
            <label kind="synchronisation" x="841" y="-263">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id30"/>
            <label kind="guard" x="391" y="76">currH==id
&amp;&amp; harsh
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="561" y="59">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="637" y="110"/>
            <nail x="374" y="144"/>
        </transition>
        <transition>
            <source ref="id68"/>
            <target ref="id41"/>
            <label kind="probability" x="586" y="187">disobey</label>
            <nail x="552" y="178"/>
        </transition>
        <transition>
            <source ref="id54"/>
            <target ref="id30"/>
            <label kind="assignment" x="280" y="212">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id68"/>
            <target ref="id54"/>
            <label kind="assignment" x="433" y="170">t = 0, 
tUpd=0</label>
            <label kind="probability" x="442" y="153">obey</label>
        </transition>
        <transition>
            <source ref="id53"/>
            <target ref="id68"/>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id53"/>
            <label kind="guard" x="638" y="144">!run &amp;&amp; 
currH==id</label>
            <label kind="synchronisation" x="637" y="170">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id41"/>
            <label kind="guard" x="484" y="382">currH==id &amp;&amp; should_sit(id)
&amp;&amp; harsh
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="484" y="433">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="467" y="382"/>
            <nail x="782" y="382"/>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id42"/>
            <label kind="guard" x="901" y="-34">currH==id &amp;&amp; harsh
&amp;&amp; !should_sit(id)
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="858" y="25">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="416" y="42"/>
            <nail x="824" y="42"/>
            <nail x="1011" y="-93"/>
        </transition>
        <transition>
            <source ref="id83"/>
            <target ref="id30"/>
            <label kind="probability" x="671" y="-51">disobey</label>
            <nail x="782" y="-34"/>
            <nail x="433" y="-34"/>
        </transition>
        <transition>
            <source ref="id83"/>
            <target ref="id42"/>
            <label kind="assignment" x="833" y="-93">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="859" y="-51">obey</label>
            <nail x="994" y="-119"/>
        </transition>
        <transition>
            <source ref="id58"/>
            <target ref="id83"/>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id58"/>
            <label kind="guard" x="450" y="0">!should_sit(id)</label>
            <label kind="synchronisation" x="459" y="17">stop_h_action?</label>
            <nail x="416" y="8"/>
        </transition>
        <transition>
            <source ref="id67"/>
            <target ref="id30"/>
            <label kind="probability" x="399" y="280">disobey</label>
            <nail x="467" y="297"/>
        </transition>
        <transition>
            <source ref="id67"/>
            <target ref="id41"/>
            <label kind="assignment" x="620" y="255">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="620" y="289">obey</label>
        </transition>
        <transition>
            <source ref="id55"/>
            <target ref="id67"/>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id55"/>
            <label kind="guard" x="459" y="306">should_sit(id)
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="459" y="340">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id0"/>
            <label kind="guard" x="-510" y="561">currH==id
&amp;&amp; run
&amp;&amp; !harsh 
&amp;&amp; !carrying
&amp;&amp; !assisted
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-510" y="663">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="-229" y="782"/>
            <nail x="-391" y="654"/>
        </transition>
        <transition>
            <source ref="id52"/>
            <target ref="id0"/>
            <label kind="assignment" x="-365" y="433">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id70"/>
            <target ref="id52"/>
            <label kind="assignment" x="-276" y="603">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-272" y="586">obey</label>
        </transition>
        <transition>
            <source ref="id70"/>
            <target ref="id43"/>
            <label kind="probability" x="-221" y="646">disobey</label>
            <nail x="-204" y="663"/>
        </transition>
        <transition>
            <source ref="id51"/>
            <target ref="id70"/>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id51"/>
            <label kind="guard" x="-220" y="709">run &amp;&amp;
currH==id</label>
            <label kind="synchronisation" x="-221" y="739">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id69"/>
            <target ref="id0"/>
            <label kind="probability" x="-272" y="450">disobey</label>
            <nail x="-221" y="510"/>
        </transition>
        <transition>
            <source ref="id69"/>
            <target ref="id43"/>
            <label kind="assignment" x="-178" y="595">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-170" y="578">obey</label>
        </transition>
        <transition>
            <source ref="id50"/>
            <target ref="id69"/>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id50"/>
            <label kind="guard" x="-280" y="399">should_sit(id)</label>
            <label kind="synchronisation" x="-272" y="416">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id43"/>
            <label kind="guard" x="85" y="841">currH!=id</label>
            <nail x="77" y="833"/>
        </transition>
        <transition>
            <source ref="id48"/>
            <target ref="id43"/>
            <label kind="synchronisation" x="-68" y="833">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id48"/>
            <label kind="guard" x="35" y="862">currH==id</label>
            <label kind="synchronisation" x="35" y="879">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id49"/>
            <label kind="guard" x="-68" y="918">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="-59" y="935">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="-68" y="909"/>
        </transition>
        <transition>
            <source ref="id47"/>
            <target ref="id41"/>
            <label kind="guard" x="987" y="161">currH!=id</label>
            <nail x="969" y="170"/>
        </transition>
        <transition>
            <source ref="id46"/>
            <target ref="id41"/>
            <label kind="synchronisation" x="867" y="196">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id47"/>
            <target ref="id46"/>
            <label kind="guard" x="978" y="187">currH==id</label>
            <label kind="synchronisation" x="978" y="204">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id47"/>
            <label kind="guard" x="867" y="255">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="909" y="281">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="935" y="281"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id42"/>
            <label kind="guard" x="1088" y="-535">currH!=id</label>
            <nail x="1070" y="-527"/>
        </transition>
        <transition>
            <source ref="id44"/>
            <target ref="id42"/>
            <label kind="synchronisation" x="977" y="-493">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id44"/>
            <label kind="guard" x="1088" y="-510">currH==id</label>
            <label kind="synchronisation" x="1088" y="-493">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id45"/>
            <label kind="guard" x="1011" y="-442">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="1011" y="-417">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="1002" y="-425"/>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id1"/>
            <label kind="guard" x="-620" y="-782">currH==id &amp;&amp; !harsh
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-637" y="-748">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="-451" y="-782"/>
            <nail x="-459" y="-663"/>
            <nail x="-357" y="-544"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id24"/>
            <label kind="guard" x="-195" y="-824">currH==id &amp;&amp; carrying
&amp;&amp; !harsh &amp;&amp; !run &amp;&amp; !assisted
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-187" y="-773">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="-272" y="-450"/>
            <nail x="-170" y="-731"/>
            <nail x="-229" y="-850"/>
        </transition>
        <transition>
            <source ref="id72"/>
            <target ref="id1"/>
            <label kind="assignment" x="-408" y="-654">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-374" y="-620">obey</label>
            <nail x="-323" y="-544"/>
        </transition>
        <transition>
            <source ref="id71"/>
            <target ref="id1"/>
            <label kind="probability" x="-314" y="-578">disobey</label>
            <nail x="-297" y="-612"/>
            <nail x="-297" y="-510"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id36"/>
            <label kind="guard" x="-280" y="-569">carrying &amp;&amp; !harsh
&amp;&amp; !run
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-297" y="-518">start_h_action?</label>
            <nail x="-306" y="-391"/>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id1"/>
            <label kind="guard" x="-518" y="101">currH==id &amp;&amp; !harsh
&amp;&amp; !should_sit(id)
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-518" y="153">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="-297" y="263"/>
            <nail x="-374" y="178"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id30"/>
            <label kind="guard" x="0" y="51">currH==id &amp;&amp; harsh
&amp;&amp; !run &amp;&amp; !assisted &amp;&amp; !carrying
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="8" y="102">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="-195" y="-17"/>
            <nail x="8" y="59"/>
        </transition>
        <transition>
            <source ref="id38"/>
            <target ref="id30"/>
            <label kind="assignment" x="34" y="221">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id81"/>
            <target ref="id1"/>
            <label kind="probability" x="-76" y="59">disobey</label>
            <nail x="-76" y="42"/>
            <nail x="-272" y="-25"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id39"/>
            <label kind="guard" x="-297" y="17">harsh
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-297" y="51">start_h_action?</label>
            <nail x="-297" y="17"/>
        </transition>
        <transition>
            <source ref="id82"/>
            <target ref="id1"/>
            <label kind="assignment" x="-195" y="93">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-161" y="76">obey</label>
        </transition>
        <transition>
            <source ref="id82"/>
            <target ref="id30"/>
            <label kind="probability" x="-272" y="212">disobey</label>
            <nail x="-289" y="195"/>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id40"/>
            <label kind="synchronisation" x="10" y="246">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id37"/>
            <target ref="id24"/>
            <label kind="assignment" x="-296" y="-828">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id71"/>
            <target ref="id37"/>
            <label kind="assignment" x="-280" y="-739">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-246" y="-739">obey</label>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id71"/>
        </transition>
        <transition>
            <source ref="id72"/>
            <target ref="id24"/>
            <label kind="probability" x="-415" y="-790">disobey</label>
            <nail x="-433" y="-722"/>
        </transition>
        <transition>
            <source ref="id35"/>
            <target ref="id72"/>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id35"/>
            <label kind="guard" x="-357" y="-833">!harsh</label>
            <label kind="synchronisation" x="-374" y="-816">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id23"/>
            <label kind="guard" x="-630" y="-646">currH==id &amp;&amp; assisted
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-561" y="-603">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="-468" y="-451"/>
            <nail x="-545" y="-587"/>
            <nail x="-655" y="-646"/>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id1"/>
            <label kind="guard" x="-918" y="-416">currH==id &amp;&amp;
freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-935" y="-374">t = 0, freeWill = 0, Fp = F, 
tUpd=0, updateFreeWill()</label>
            <nail x="-850" y="-476"/>
            <nail x="-705" y="-306"/>
        </transition>
        <transition>
            <source ref="id73"/>
            <target ref="id1"/>
            <label kind="probability" x="-586" y="-459">disobey</label>
            <nail x="-586" y="-459"/>
        </transition>
        <transition>
            <source ref="id33"/>
            <target ref="id23"/>
            <label kind="assignment" x="-782" y="-629">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id73"/>
            <target ref="id33"/>
            <label kind="assignment" x="-620" y="-586">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-654" y="-595">obey</label>
        </transition>
        <transition>
            <source ref="id32"/>
            <target ref="id73"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id32"/>
            <label kind="guard" x="-518" y="-442">assisted
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-518" y="-408">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id74"/>
            <target ref="id23"/>
            <label kind="probability" x="-833" y="-527">disobey</label>
            <nail x="-790" y="-484"/>
            <nail x="-833" y="-552"/>
        </transition>
        <transition>
            <source ref="id74"/>
            <target ref="id1"/>
            <label kind="assignment" x="-688" y="-416">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-654" y="-433">obey</label>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id74"/>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id34"/>
            <label kind="synchronisation" x="-901" y="-603">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id24"/>
            <label kind="guard" x="-442" y="-1071">currH!=id</label>
            <nail x="-399" y="-1045"/>
        </transition>
        <transition>
            <source ref="id26"/>
            <target ref="id24"/>
            <label kind="synchronisation" x="-398" y="-960">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id26"/>
            <label kind="guard" x="-501" y="-1037">currH==id</label>
            <label kind="synchronisation" x="-476" y="-1028">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id28"/>
            <label kind="guard" x="-586" y="-926">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="-518" y="-909">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="-501" y="-926"/>
        </transition>
        <transition>
            <source ref="id27"/>
            <target ref="id23"/>
            <label kind="guard" x="-816" y="-943">currH!=id</label>
            <nail x="-782" y="-824"/>
        </transition>
        <transition>
            <source ref="id25"/>
            <target ref="id23"/>
            <label kind="synchronisation" x="-858" y="-824">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id27"/>
            <target ref="id25"/>
            <label kind="guard" x="-875" y="-909">currH==id</label>
            <label kind="synchronisation" x="-858" y="-892">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id27"/>
            <label kind="guard" x="-1011" y="-833">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="-1105" y="-799">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="-901" y="-833"/>
        </transition>
        <transition>
            <source ref="id75"/>
            <target ref="id1"/>
            <label kind="assignment" x="-238" y="-170">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-238" y="-187">obey</label>
            <nail x="-246" y="-127"/>
        </transition>
        <transition>
            <source ref="id75"/>
            <target ref="id5"/>
            <label kind="probability" x="-59" y="-195">disobey</label>
            <nail x="-76" y="-178"/>
            <nail x="110" y="-178"/>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id75"/>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id22"/>
            <label kind="guard" x="68" y="-238">!should_sit(id)</label>
            <label kind="synchronisation" x="52" y="-208">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id0"/>
            <label kind="guard" x="-527" y="-68">currH==id
&amp;&amp; run
&amp;&amp; !harsh
&amp;&amp; !assisted
&amp;&amp; !carrying
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-578" y="42">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="-484" y="-110"/>
            <nail x="-612" y="77"/>
        </transition>
        <transition>
            <source ref="id76"/>
            <target ref="id0"/>
            <label kind="probability" x="-799" y="-85">disobey</label>
            <nail x="-790" y="-59"/>
            <nail x="-867" y="119"/>
        </transition>
        <transition>
            <source ref="id76"/>
            <target ref="id1"/>
            <label kind="assignment" x="-722" y="-195">t = 0, Fp=F,  tUpd=0, 
updateFreeWill()</label>
            <label kind="probability" x="-680" y="-153">obey</label>
        </transition>
        <transition>
            <source ref="id2"/>
            <target ref="id76"/>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id2"/>
            <label kind="guard" x="-773" y="85">!should_sit(id)
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-748" y="127">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id77"/>
            <target ref="id1"/>
            <label kind="probability" x="-637" y="-102">disobey</label>
            <nail x="-671" y="-42"/>
        </transition>
        <transition>
            <source ref="id3"/>
            <target ref="id0"/>
            <label kind="guard" x="-646" y="119">F==0</label>
            <label kind="assignment" x="-654" y="144">Fp=1,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id3"/>
            <target ref="id0"/>
            <label kind="guard" x="-595" y="102">F&gt;0</label>
            <label kind="assignment" x="-603" y="119">Fp=1-F,
plan_traj()</label>
            <nail x="-612" y="76"/>
        </transition>
        <transition>
            <source ref="id77"/>
            <target ref="id3"/>
            <label kind="assignment" x="-637" y="25">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-637" y="8">obey</label>
        </transition>
        <transition>
            <source ref="id4"/>
            <target ref="id77"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id4"/>
            <label kind="guard" x="-535" y="-170">run
&amp;&amp; !harsh
&amp;&amp; !assisted
&amp;&amp; !carrying
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-569" y="-85">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id79"/>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id19"/>
            <label kind="guard" x="178" y="-799">currH==id</label>
            <label kind="synchronisation" x="170" y="-782">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id10"/>
            <target ref="id5"/>
            <label kind="guard" x="161" y="-153">currH!=id</label>
            <nail x="178" y="-136"/>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id13"/>
            <label kind="guard" x="272" y="-977">currH!=id</label>
            <nail x="280" y="-935"/>
        </transition>
        <transition>
            <source ref="id17"/>
            <target ref="id13"/>
            <label kind="synchronisation" x="221" y="-883">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id17"/>
            <label kind="guard" x="221" y="-1015">currH==id</label>
            <label kind="synchronisation" x="221" y="-998">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id18"/>
            <label kind="guard" x="85" y="-960">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="85" y="-943">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="178" y="-935"/>
        </transition>
        <transition>
            <source ref="id78"/>
            <target ref="id5"/>
            <label kind="probability" x="144" y="-697">disobey</label>
            <nail x="161" y="-807"/>
        </transition>
        <transition>
            <source ref="id78"/>
            <target ref="id13"/>
            <label kind="assignment" x="25" y="-858">t = 0, Fp=F,  tUpd=0, 
sat_once = true,
updateFreeWill()</label>
            <label kind="probability" x="144" y="-841">obey</label>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id78"/>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id16"/>
            <label kind="guard" x="76" y="-501">should_sit(id)</label>
            <label kind="synchronisation" x="76" y="-484">stop_h_action?</label>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id80"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id15"/>
            <label kind="guard" x="-331" y="-340">!run &amp;&amp; !harsh 
&amp;&amp; !carrying &amp;&amp; !assisted
&amp;&amp; currH==id</label>
            <label kind="synchronisation" x="-331" y="-289">start_h_action?</label>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id14"/>
            <label kind="guard" x="280" y="-714">currH==id
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="280" y="-680">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="272" y="-773"/>
            <nail x="272" y="-569"/>
        </transition>
        <transition>
            <source ref="id79"/>
            <target ref="id13"/>
            <label kind="probability" x="246" y="-748">disobey</label>
            <nail x="246" y="-705"/>
            <nail x="246" y="-756"/>
        </transition>
        <transition>
            <source ref="id79"/>
            <target ref="id14"/>
            <label kind="assignment" x="204" y="-612">t = 0, 
tUpd=0</label>
            <label kind="probability" x="204" y="-629">obey</label>
        </transition>
        <transition>
            <source ref="id14"/>
            <target ref="id5"/>
            <label kind="guard" x="272" y="-484">F==0</label>
            <label kind="assignment" x="263" y="-467">Fp=1,
plan_traj()</label>
            <nail x="272" y="-527"/>
        </transition>
        <transition>
            <source ref="id14"/>
            <target ref="id5"/>
            <label kind="guard" x="187" y="-484">F&gt;0</label>
            <label kind="assignment" x="187" y="-467">Fp=1-F,
plan_traj()</label>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id1"/>
            <label kind="guard" x="-374" y="-391">currH!=id</label>
            <nail x="-339" y="-374"/>
        </transition>
        <transition>
            <source ref="id12"/>
            <target ref="id5"/>
            <label kind="synchronisation" x="179" y="-179">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id10"/>
            <target ref="id12"/>
            <label kind="guard" x="170" y="-110">currH==id</label>
            <label kind="synchronisation" x="170" y="-93">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id11"/>
            <target ref="id1"/>
            <label kind="synchronisation" x="-390" y="-327">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id11"/>
            <label kind="guard" x="-391" y="-442">currH==id</label>
            <label kind="synchronisation" x="-390" y="-425">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id10"/>
            <label kind="guard" x="272" y="-162">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="272" y="-145">updateF(-lambda, 1),
updateP(), tUpd=0,
freeWill = random(freeWillRange)</label>
            <nail x="272" y="-145"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id9"/>
            <label kind="guard" x="-518" y="-383">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="-654" y="-366">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="-424" y="-366"/>
        </transition>
        <transition>
            <source ref="id1"/>
            <target ref="id8"/>
            <label kind="guard" x="-263" y="-450">currH==id &amp;&amp; !run
&amp;&amp; !harsh &amp;&amp; !carrying &amp;&amp; !assisted
&amp;&amp; freeWill&gt;=freeWillTh</label>
            <label kind="assignment" x="-25" y="-433">t = 0, tUpd=0,
freeWill = 0</label>
            <nail x="-263" y="-400"/>
            <nail x="9" y="-400"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id5"/>
            <label kind="guard" x="17" y="-289">F==0</label>
            <label kind="assignment" x="17" y="-272">Fp=1,
plan_traj()</label>
            <nail x="60" y="-255"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id5"/>
            <label kind="guard" x="77" y="-357">F&gt;0</label>
            <label kind="assignment" x="76" y="-340">Fp=1-F,
plan_traj()</label>
            <nail x="128" y="-357"/>
        </transition>
        <transition>
            <source ref="id80"/>
            <target ref="id8"/>
            <label kind="assignment" x="-59" y="-357">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-59" y="-374">obey</label>
        </transition>
        <transition>
            <source ref="id80"/>
            <target ref="id1"/>
            <label kind="probability" x="-144" y="-323">disobey</label>
            <nail x="-76" y="-323"/>
            <nail x="-263" y="-323"/>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id7"/>
            <label kind="guard" x="239" y="-272">F &gt;= passout_th</label>
            <label kind="synchronisation" x="264" y="-255">pass_out!</label>
            <label kind="assignment" x="315" y="-238">t = 0</label>
        </transition>
        <transition>
            <source ref="id7"/>
            <target ref="id7"/>
            <nail x="349" y="-204"/>
            <nail x="391" y="-204"/>
        </transition>
        <transition>
            <source ref="id6"/>
            <target ref="id1"/>
            <label kind="assignment" x="-544" y="-255">initHuman()</label>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id0"/>
            <label kind="guard" x="-391" y="323">currH!=id</label>
        </transition>
        <transition>
            <source ref="id20"/>
            <target ref="id0"/>
            <label kind="synchronisation" x="-544" y="314">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id20"/>
            <label kind="guard" x="-714" y="408">currH==id</label>
            <label kind="synchronisation" x="-722" y="425">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id21"/>
            <label kind="guard" x="-892" y="323">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="-892" y="340">updateF(-lambda, 1),
updateP(), tUpd=0,
freeWill = random(freeWillRange)</label>
            <nail x="-612" y="340"/>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id30"/>
            <label kind="guard" x="187" y="383">currH!=id</label>
            <nail x="195" y="417"/>
        </transition>
        <transition>
            <source ref="id31"/>
            <target ref="id30"/>
            <label kind="synchronisation" x="119" y="357">publish_m[3]!</label>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id31"/>
            <label kind="guard" x="110" y="417">currH==id</label>
            <label kind="synchronisation" x="127" y="434">publish_m[4]!</label>
        </transition>
        <transition>
            <source ref="id30"/>
            <target ref="id29"/>
            <label kind="guard" x="8" y="391">tUpd&gt;=Tpoll</label>
            <label kind="assignment" x="0" y="417">updateF(-mi, 0), 
tUpd=0, 
freeWill = random(freeWillRange)</label>
            <nail x="76" y="408"/>
        </transition>
        <transition>
            <source ref="id81"/>
            <target ref="id38"/>
            <label kind="assignment" x="-25" y="161">t = 0, 
tUpd=0</label>
            <label kind="probability" x="-34" y="144">obey</label>
        </transition>
        <transition>
            <source ref="id39"/>
            <target ref="id81"/>
        </transition>
        <transition>
            <source ref="id40"/>
            <target ref="id82"/>
        </transition>
    </template>
<template>
    <name>Human_Applicant</name>
    <parameter>int id, double v, int p_f, int p_fw, int p_dext, int path</parameter>
    <declaration>
/* general comments
- if the person is far from the objective, it will move towards it, otherwise it will wait for the command to
sincronyze and start executing.
- functions for moving the humans are the same of human leader, they can be globally packaged maybe?
*/
clock t, F, Fp;
clock tUpd;
clock freeWill;
clock tWH;

double lambda, mi;
double passout_th = 1.0;

//Free Will Model
double freeWillTh = 100.0;
double freeWillRange = 95.0;
int obey = 90;
int disobey = 10;

int Tpoll = 1;

//this sets the state of the mission: getting to objective or working at mission
bool exeMission = false;
//threshHold for completing the mission
double tWHTh = 60.0;


bool checkDist() {
    return pt_dist(internalHumX[id - 1], destX[id - 1], internalHumY[id - 1], destY[id - 1]) &lt;= 50.0;
}

void initHuman() {
    F = 0;
    Fp = 0;
    t = 0;
    tWH = 0;

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id - 1] = humanPositionX[id - 1];
    internalHumY[id - 1] = humanPositionY[id - 1];

    // unfortunately the switch case is not supported yet
    if (p_f == 1)
    {
        lambda = YOUNG_HEALTHY[0];
        mi = YOUNG_HEALTHY[1];
    }
    else if (p_f == 2)
    {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    }
    else if (p_f == 3)
    {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    }
    else if (p_f == 4)
    {
        lambda = ELDERLY_SICK[0];
        mi = ELDERLY_SICK[1];
    }
    else if (p_f == 5)
    {
        lambda = COVID_PATIENT[0];
        mi = COVID_PATIENT[1];
    }
    else
    {
        lambda = 0.005;
        mi = 0.005; //default values
    }

    if (p_fw == 1)
    {
        freeWillTh = NORMAL;
    }
    else if (p_fw == 2)
    {
        freeWillTh = HIGH;
    }
    else if (p_fw == 3)
    {
        freeWillTh = DISABLED;
    }
    exeMission = checkDist();
}

void updateF(double coeff, bool walking) {
    if (walking)
    {
        internalFatigue[id - 1] = 1 - (1 - internalFatigue[id - 1]) * exp(coeff * Tpoll);
    }
    else
    {
        internalFatigue[id - 1] = internalFatigue[id - 1] * exp(coeff * Tpoll);
    }

    internalFatigue[id - 1] = fmax(0, internalFatigue[id - 1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
    curr[0] = internalHumX[id - 1];
    curr[1] = internalHumY[id - 1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P;i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I;j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id - 1], internalHumY[id - 1], traj[0][0], traj[0][1]);
}

void updateP() {
    double eps = 0.0;
    exeMission = checkDist();
    if (exeMission) return;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0] == 0.0 &amp;&amp; traj[curr_traj][1] == 0.0))
        return;

    if (pt_dist(internalHumX[id - 1], traj[curr_traj][0], internalHumY[id - 1], traj[curr_traj][1]) &lt; v * 1.1)
    {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id - 1], internalHumY[id - 1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id - 1] = internalHumX[id - 1] + v * Tpoll * cos(ort * PI / 180);
    internalHumY[id - 1] = internalHumY[id - 1] + v * Tpoll * sin(ort * PI / 180);
}


void start_moving() {
    F = 0;
    t = 0;
    tUpd = 0;
    freeWill = 0;
    plan_traj();
}
    </declaration>
    <location id="id0" x="-815" y="-51">
        <name x="-825" y="-85">h_init</name>
        <committed/>
    </location>
    <location id="id1" x="-620" y="-51" color="#0000ff">
        <name x="-630" y="-85">h_idle</name>
        <label kind="invariant" x="-671" y="-34">t' == 1
            &amp;&amp; tWH' ==0
            &amp;&amp; Fp' == 0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; freeWill' == 0
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id2" x="-161" y="-178" color="#0000ff">
        <name x="-204" y="-161">h_executing</name>
        <label kind="invariant" x="-221" y="-331">t' == 1
            &amp;&amp; tWH' == p_dext
            &amp;&amp; tWH &lt;= tWHTh
            &amp;&amp; Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id3" x="-161" y="212" color="#0000ff">
        <name x="-171" y="178">h_busy</name>
        <label kind="invariant" x="-272" y="212">t' == 1
            &amp;&amp; tWH' == 0
            &amp;&amp; Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id4" x="-748" y="-331">
        <committed/>
    </location>
    <location id="id5" x="-620" y="-332">
        <committed/>
    </location>
    <location id="id6" x="170" y="-119">
        <committed/>
    </location>
    <location id="id7" x="170" y="-178">
        <committed/>
    </location>
    <location id="id8" x="153" y="212">
        <committed/>
    </location>
    <location id="id9" x="153" y="297">
        <committed/>
    </location>
    <location id="id10" x="-382" y="-178">
        <urgent/>
    </location>
    <location id="id11" x="-365" y="110">
        <urgent/>
    </location>
    <location id="id12" x="17" y="25" color="#ff0000">
        <name x="7" y="-9">a</name>
        <label kind="invariant" x="68" y="0">t' == 0 &amp;&amp;
            F' == 0 &amp;&amp;
            tWH' == 0
        </label>
        <label kind="exponentialrate" x="42" y="17">1</label>
    </location>
    <location id="id13" x="-510" y="-144">
        <name x="-527" y="-170">c1</name>
        <committed/>
    </location>
    <location id="id14" x="-161" y="51">
        <name x="-152" y="26">c2</name>
        <committed/>
    </location>
    <branchpoint id="id15" x="-161" y="-59">
    </branchpoint>
    <branchpoint id="id16" x="-484" y="-178">
    </branchpoint>
    <init ref="id0"/>
    <transition>
        <source ref="id15"/>
        <target ref="id2"/>
        <label kind="assignment" x="-178" y="-102">hExe=1</label>
        <label kind="probability" x="-178" y="-119">obey</label>
    </transition>
    <transition>
        <source ref="id15"/>
        <target ref="id3"/>
        <label kind="probability" x="-255" y="51">disobey</label>
        <nail x="-195" y="59"/>
    </transition>
    <transition>
        <source ref="id14"/>
        <target ref="id15"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id14"/>
        <label kind="guard" x="-153" y="76">!served[id-1]
            &amp;&amp; currH == id
            &amp;&amp; exeMission
        </label>
        <label kind="synchronisation" x="-153" y="127">start_h_action?</label>
    </transition>
    <transition>
        <source ref="id13"/>
        <target ref="id16"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id13"/>
        <label kind="guard" x="-586" y="-127">!served[id-1]
            &amp;&amp; currH == id
            &amp;&amp; exeMission
        </label>
        <label kind="synchronisation" x="-586" y="-76">start_h_action?</label>
    </transition>
    <transition>
        <source ref="id16"/>
        <target ref="id1"/>
        <label kind="probability" x="-561" y="-195">disobey</label>
        <nail x="-493" y="-178"/>
        <nail x="-578" y="-178"/>
    </transition>
    <transition>
        <source ref="id16"/>
        <target ref="id10"/>
        <label kind="assignment" x="-467" y="-178">hExe=1</label>
        <label kind="probability" x="-467" y="-195">obey</label>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="synchronisation" x="-374" y="-110">stop_h_action?</label>
        <label kind="assignment" x="-408" y="-93">t=0, Fp=F, tUpd=0,hExe=0</label>
        <nail x="-246" y="-102"/>
        <nail x="-518" y="-102"/>
    </transition>
    <transition>
        <source ref="id12"/>
        <target ref="id12"/>
        <nail x="59" y="8"/>
        <nail x="59" y="8"/>
        <nail x="59" y="42"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id12"/>
        <label kind="guard" x="25" y="59">F &gt;= passout_th</label>
        <label kind="synchronisation" x="25" y="76">pass_out!</label>
        <label kind="assignment" x="34" y="93">t = 0</label>
        <nail x="17" y="212"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id12"/>
        <label kind="guard" x="-76" y="-85">F &gt;= passout_th</label>
        <label kind="synchronisation" x="-76" y="-68">pass_out!</label>
        <label kind="assignment" x="-76" y="-51">t = 0, hExe=0</label>
        <nail x="-76" y="-34"/>
        <nail x="17" y="-34"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id1"/>
        <label kind="guard" x="-603" y="212">!served[id-1] &amp;&amp;
            freeWill &gt;= freeWillTh &amp;&amp;
            tUpd&gt;=Tpoll
        </label>
        <label kind="assignment" x="-603" y="263">t = 0, Fp=F, tUpd=0</label>
        <nail x="-620" y="212"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="guard" x="-459" y="-297">!served[id-1] &amp;&amp;
            freeWill &gt;= freeWillTh &amp;&amp;
            tUpd &gt;= Tpoll
        </label>
        <label kind="assignment" x="-459" y="-246">t = 0, Fp=F, tUpd=0, hExe=0</label>
        <nail x="-161" y="-220"/>
        <nail x="-595" y="-220"/>
    </transition>
    <transition>
        <source ref="id11"/>
        <target ref="id3"/>
        <label kind="guard" x="-306" y="127">F==0</label>
        <label kind="assignment" x="-306" y="144">Fp=1</label>
        <nail x="-365" y="144"/>
        <nail x="-212" y="144"/>
    </transition>
    <transition>
        <source ref="id11"/>
        <target ref="id3"/>
        <label kind="guard" x="-331" y="93">F&gt;0</label>
        <label kind="assignment" x="-297" y="93">Fp = 1-F</label>
        <nail x="-238" y="110"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id11"/>
        <label kind="guard" x="-510" y="59">!served[id-1]
            &amp;&amp; !exeMission
        </label>
        <label kind="assignment" x="-510" y="93">start_moving()</label>
        <nail x="-527" y="110"/>
    </transition>
    <transition>
        <source ref="id10"/>
        <target ref="id2"/>
        <label kind="guard" x="-365" y="-127">F==0</label>
        <label kind="assignment" x="-306" y="-127">Fp= 1</label>
        <nail x="-382" y="-136"/>
        <nail x="-263" y="-136"/>
        <nail x="-263" y="-178"/>
    </transition>
    <transition>
        <source ref="id10"/>
        <target ref="id2"/>
        <label kind="guard" x="-340" y="-195">F&gt;0</label>
        <label kind="assignment" x="-289" y="-195">Fp = 1-F</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id3"/>
        <label kind="guard" x="25" y="255">currH!=id</label>
        <nail x="153" y="255"/>
        <nail x="-161" y="255"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id8"/>
        <label kind="guard" x="-51" y="187">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-51" y="136">updateF(-lambda, 1),
            updateP(), tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="0" y="212"/>
    </transition>
    <transition>
        <source ref="id9"/>
        <target ref="id3"/>
        <label kind="synchronisation" x="25" y="297">publish_m[4]!</label>
        <nail x="-161" y="297"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="guard" x="-442" y="-68">tWH &gt;= tWHTh</label>
        <label kind="assignment" x="-442" y="-51">served[currH-1]= true,
            t = 0, exeMission = 0, Fp=F,
            tUpd=0, tWH=0,hExe=0
        </label>
        <nail x="-229" y="-51"/>
    </transition>
    <transition>
        <source ref="id7"/>
        <target ref="id6"/>
        <label kind="guard" x="178" y="-161">currH==id</label>
        <label kind="synchronisation" x="178" y="-144">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id7"/>
        <target ref="id2"/>
        <label kind="guard" x="68" y="-161">currH!=id</label>
        <nail x="127" y="-144"/>
        <nail x="-102" y="-144"/>
    </transition>
    <transition>
        <source ref="id6"/>
        <target ref="id2"/>
        <label kind="synchronisation" x="59" y="-119">publish_m[4]!</label>
        <nail x="-59" y="-119"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id7"/>
        <label kind="guard" x="51" y="-221">tUpd&gt;=Tpoll
            &amp;&amp; tWH &lt; tWHTh
        </label>
        <label kind="assignment" x="51" y="-272">updateF(-lambda, 1),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="8" y="-178"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id5"/>
        <label kind="guard" x="-705" y="-297">tUpd&gt;= Tpoll</label>
        <label kind="assignment" x="-705" y="-280">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="-620" y="-187"/>
        <nail x="-620" y="-187"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id1"/>
        <label kind="guard" x="-714" y="-187">currH!=id</label>
        <nail x="-680" y="-331"/>
        <nail x="-680" y="-212"/>
        <nail x="-680" y="-51"/>
    </transition>
    <transition>
        <source ref="id4"/>
        <target ref="id1"/>
        <label kind="synchronisation" x="-850" y="-187">publish_m[4]!</label>
        <nail x="-748" y="-51"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id4"/>
        <label kind="guard" x="-731" y="-374">currH==id</label>
        <label kind="synchronisation" x="-731" y="-357">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id0"/>
        <target ref="id1"/>
        <label kind="assignment" x="-782" y="-51">initHuman()</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id9"/>
        <label kind="guard" x="170" y="238">currH==id</label>
        <label kind="synchronisation" x="170" y="255">publish_m[3]!</label>
    </transition>
</template>
<template>
    <name>Human_Competitor</name>
    <parameter>int id, double v, int p_f, int p_fw, int path</parameter>
    <declaration>
//PATTERN N°12
clock t, F, Fp;
clock tUpd;
clock freeWill;

double lambda, mi;
const double passout_th = 1.0;

//Free Will Model
int obey = 100;
int disobey = 0;
double freeWillTh = 100.0;
double freeWillRange = 100.0;

// Fatigue Sharing Parameters
const int Tpoll = 1;

//TODO coordinates of the eventual position to take the object. At the moment it is the initial position
double secondDestX = 0.0;
double secondDestY = 0.0;

bool atDestRobot = false;
bool atDestHuman = false;


// Position Sharing Parameters

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    plan_traj();
}

// double dist_to_dest;
void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 20.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}


void initHuman() {
    F = 0;
    Fp = 0;
    t = 0;

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    secondDestX = humanPositionX[id-1];
    secondDestY = humanPositionY[id-1];

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}

double rob_dist_to_dest;
double dist_to_dest;
void checkFirst() {
    int i;
    rob_dist_to_dest = pt_dist(robPositionX[currR-1], destX[id-1], robPositionY[currR-1], destY[id-1]);
    dist_to_dest = pt_dist(destX[id-1], internalHumX[id-1], destY[id-1], internalHumY[id-1]);
    if(dist_to_dest &lt;= v*1.2){ //priority to human if parity
        atDestHuman = true;
        PATH = 2;

        for(i=0; i&lt;H; i++) {
            patterns[i] = patterns_alt2[i];
            destX[i] = destX_alt2[i];
            destY[i] = destY_alt2[i];
        }

        //dX[currR-1] = secondDestX;
        //dY[currR-1] = secondDestY;
    }else if(rob_dist_to_dest &lt;= v*1.2){
        PATH = 1;

        for(i=0; i&lt;H; i++) {
            patterns[i] = patterns_alt1[i];
            destX[i] = destX_alt1[i];
            destY[i] = destY_alt1[i];
        }

        atDestRobot = true;
        destX[currH-1] = secondDestX;
        destY[currH-1] = secondDestY;
        dX[currR-1] = secondDestX;
        dY[currR-1] = secondDestY;
    }
}

void checkSuccess(){
    double dist_to_dest = pt_dist(secondDestX, internalHumX[id-1], secondDestY, internalHumY[id-1]);
    double rob_dist_to_dest = pt_dist(robPositionX[currR-1], secondDestX, robPositionY[currR-1], secondDestY);
    // when humans/robot reach their destination, they can be set as "served"
    served[id-1] = (atDestHuman &amp;&amp; (dist_to_dest &lt;= v*2.0)) || (atDestRobot &amp;&amp; (rob_dist_to_dest
                                                                                                   &lt;= v*2.0));
}
    </declaration>
    <location id="id17" x="-807" y="8">
        <label kind="comments" x="-833" y="-280">assunzione per semplificare:
            il primo che arriva è quello
            capace di tornare indietro
            con il componente per primo
            (altrimenti dovrebbero esserci
            dei passaggi tipo "staffetta")
        </label>
        <committed/>
    </location>
    <location id="id18" x="-603" y="8" color="#0000ff">
        <name x="-595" y="-25">idle</name>
        <label kind="invariant" x="-595" y="-93">Fp' == 0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; freeWill' == 0
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id19" x="-332" y="8">
        <name x="-342" y="-26">c1</name>
        <committed/>
    </location>
    <location id="id20" x="-43" y="8" color="#0000ff">
        <name x="-25" y="-8">way_there</name>
        <label kind="invariant" x="-25" y="8">freeWill'==0
            &amp;&amp; Fp'==0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id21" x="-76" y="204">
        <name x="-93" y="221">free_will_dec</name>
        <committed/>
    </location>
    <location id="id22" x="-221" y="8">
        <name x="-231" y="-26">c2</name>
        <committed/>
    </location>
    <location id="id23" x="-42" y="-323" color="#ff0000">
        <name x="-136" y="-314">passed_out</name>
        <label kind="invariant" x="-136" y="-297">t' == 0 &amp;&amp;
            F' == 0 &amp;&amp;
            freeWill' == 0
        </label>
        <label kind="exponentialrate" x="-76" y="-332">1</label>
    </location>
    <location id="id24" x="272" y="178">
        <committed/>
    </location>
    <location id="id25" x="272" y="119">
        <committed/>
    </location>
    <location id="id26" x="272" y="8">
        <name x="255" y="-26">checking</name>
        <committed/>
    </location>
    <location id="id27" x="272" y="-170">
        <committed/>
    </location>
    <location id="id28" x="-603" y="102">
        <name x="-637" y="93">p1</name>
        <committed/>
    </location>
    <location id="id29" x="-603" y="203">
        <committed/>
    </location>
    <location id="id30" x="272" y="-323" color="#0000ff">
        <name x="289" y="-323">way_back</name>
        <label kind="invariant" x="289" y="-306">Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id31" x="272" y="-247">
        <committed/>
    </location>
    <location id="id32" x="501" y="-323">
        <committed/>
    </location>
    <location id="id33" x="552" y="263" color="#0000ff">
        <name x="569" y="263">wait_rob_dest1</name>
        <label kind="invariant" x="561" y="280">Fp' == 0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; freeWill' == 0
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id34" x="280" y="263">
        <committed/>
    </location>
    <branchpoint id="id35" x="-281" y="8">
    </branchpoint>
    <init ref="id17"/>
    <transition>
        <source ref="id34"/>
        <target ref="id33"/>
        <label kind="guard" x="365" y="221">!served[id-1]</label>
        <nail x="408" y="229"/>
    </transition>
    <transition>
        <source ref="id34"/>
        <target ref="id18"/>
        <label kind="guard" x="-585" y="271">served[id-1]</label>
        <label kind="synchronisation" x="-585" y="288">stop_r_action!</label>
        <nail x="-603" y="272"/>
    </transition>
    <transition>
        <source ref="id33"/>
        <target ref="id34"/>
        <label kind="guard" x="365" y="272">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="280" y="289">checkSuccess(), tUpd=0, updateF(-mi, 0)</label>
    </transition>
    <transition>
        <source ref="id27"/>
        <target ref="id30"/>
        <label kind="guard" x="144" y="-255">currH!=id</label>
        <nail x="212" y="-246"/>
    </transition>
    <transition>
        <source ref="id25"/>
        <target ref="id20"/>
        <label kind="guard" x="76" y="93">currH!=id</label>
        <nail x="-42" y="119"/>
    </transition>
    <transition>
        <source ref="id26"/>
        <target ref="id21"/>
        <label kind="guard" x="51" y="212">freeWill&gt;=freeWillTh</label>
        <nail x="272" y="204"/>
    </transition>
    <transition>
        <source ref="id26"/>
        <target ref="id33"/>
        <label kind="guard" x="561" y="59">!atDestHuman &amp;&amp; atDestRobot</label>
        <label kind="synchronisation" x="561" y="93">stop_h_action!</label>
        <label kind="assignment" x="561" y="76">updateF(-lambda, 0)</label>
        <nail x="552" y="8"/>
    </transition>
    <transition>
        <source ref="id21"/>
        <target ref="id18"/>
        <label kind="assignment" x="-357" y="212">Fp=F, tUpd=0, t=0</label>
        <nail x="-603" y="204"/>
    </transition>
    <transition>
        <source ref="id32"/>
        <target ref="id18"/>
        <label kind="guard" x="-467" y="-399">served[id-1] ||
            (freeWill&gt;=freeWillTh)
        </label>
        <label kind="synchronisation" x="-467" y="-365">stop_h_action!</label>
        <label kind="assignment" x="-467" y="-348">hExe = 0, Fp = F</label>
        <nail x="501" y="-399"/>
        <nail x="-603" y="-399"/>
    </transition>
    <transition>
        <source ref="id32"/>
        <target ref="id27"/>
        <label kind="guard" x="510" y="-229">!served[id-1]
            &amp;&amp; freeWill&lt;freeWillTh
        </label>
        <label kind="assignment" x="510" y="-195">updateP(), updateF(-lambda, 1)</label>
        <nail x="501" y="-170"/>
    </transition>
    <transition>
        <source ref="id30"/>
        <target ref="id32"/>
        <label kind="guard" x="306" y="-383">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="306" y="-366">checkSuccess(),
            freeWill = random(freeWillRange)
        </label>
    </transition>
    <transition>
        <source ref="id30"/>
        <target ref="id23"/>
        <label kind="guard" x="51" y="-374">F &gt;= passout_th</label>
        <label kind="synchronisation" x="51" y="-357">pass_out!</label>
        <label kind="assignment" x="51" y="-340">t = 0, hExe = 0</label>
    </transition>
    <transition>
        <source ref="id31"/>
        <target ref="id30"/>
        <label kind="synchronisation" x="170" y="-297">publish_m[3]!</label>
        <label kind="assignment" x="212" y="-280">tUpd=0</label>
    </transition>
    <transition>
        <source ref="id27"/>
        <target ref="id31"/>
        <label kind="guard" x="187" y="-229">currH==id</label>
        <label kind="synchronisation" x="170" y="-212">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id26"/>
        <target ref="id27"/>
        <label kind="guard" x="280" y="-144">atDestHuman
            &amp;&amp; freeWill&lt;freeWillTh
            &amp;&amp; !atDestRobot
        </label>
        <label kind="synchronisation" x="280" y="-93">stop_r_action!</label>
        <label kind="assignment" x="280" y="-76">updateP(), updateF(-lambda, 1), plan_traj()</label>
    </transition>
    <transition>
        <source ref="id29"/>
        <target ref="id18"/>
        <label kind="guard" x="-739" y="102">currH!=id</label>
        <nail x="-663" y="110"/>
    </transition>
    <transition>
        <source ref="id28"/>
        <target ref="id18"/>
        <label kind="synchronisation" x="-629" y="50">publish_m[3]!</label>
        <label kind="assignment" x="-629" y="68">tUpd=0</label>
    </transition>
    <transition>
        <source ref="id29"/>
        <target ref="id28"/>
        <label kind="guard" x="-629" y="135">currH==id</label>
        <label kind="synchronisation" x="-637" y="152">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id18"/>
        <target ref="id29"/>
        <label kind="guard" x="-527" y="102">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-527" y="119">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="-535" y="110"/>
    </transition>
    <transition>
        <source ref="id26"/>
        <target ref="id25"/>
        <label kind="guard" x="280" y="25">!atDestHuman
            &amp;&amp; !atDestRobot
            &amp;&amp; freeWill&lt;freeWillTh
        </label>
        <label kind="assignment" x="280" y="76">updateP(),
            updateF(-lambda, 1)
        </label>
    </transition>
    <transition>
        <source ref="id20"/>
        <target ref="id26"/>
        <label kind="guard" x="42" y="-85">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="42" y="-68">checkFirst(),
            freeWill = random(freeWillRange),
            tUpd=0, updateP(),
            updateF(-lambda, 1)
        </label>
    </transition>
    <transition>
        <source ref="id21"/>
        <target ref="id20"/>
        <label kind="synchronisation" x="-178" y="93">stop_r_action!</label>
        <label kind="assignment" x="-136" y="110">hExe=0</label>
        <nail x="-76" y="76"/>
    </transition>
    <transition>
        <source ref="id23"/>
        <target ref="id23"/>
        <nail x="-93" y="-374"/>
        <nail x="-42" y="-374"/>
    </transition>
    <transition>
        <source ref="id20"/>
        <target ref="id23"/>
        <label kind="guard" x="-34" y="-229">F &gt;= passout_th</label>
        <label kind="synchronisation" x="-34" y="-212">pass_out!</label>
        <label kind="assignment" x="-34" y="-195">t = 0</label>
    </transition>
    <transition>
        <source ref="id25"/>
        <target ref="id24"/>
        <label kind="guard" x="280" y="127">currH==id</label>
        <label kind="synchronisation" x="280" y="144">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id24"/>
        <target ref="id20"/>
        <label kind="synchronisation" x="59" y="153">publish_m[3]!</label>
        <nail x="-42" y="178"/>
    </transition>
    <transition>
        <source ref="id22"/>
        <target ref="id20"/>
        <label kind="guard" x="-170" y="8">F==0</label>
        <label kind="assignment" x="-170" y="25">Fp=1,
            plan_traj()
        </label>
    </transition>
    <transition>
        <source ref="id22"/>
        <target ref="id20"/>
        <label kind="guard" x="-170" y="-76">F&gt;0</label>
        <label kind="assignment" x="-170" y="-59">Fp=1-F,
            plan_traj()
        </label>
        <nail x="-136" y="-25"/>
    </transition>
    <transition>
        <source ref="id35"/>
        <target ref="id22"/>
        <label kind="probability" x="-272" y="8">obey</label>
    </transition>
    <transition>
        <source ref="id35"/>
        <target ref="id18"/>
        <label kind="probability" x="-476" y="68">disobey</label>
        <nail x="-450" y="68"/>
    </transition>
    <transition>
        <source ref="id19"/>
        <target ref="id35"/>
    </transition>
    <transition>
        <source ref="id18"/>
        <target ref="id19"/>
        <label kind="guard" x="-493" y="-25">currH==id</label>
        <label kind="synchronisation" x="-501" y="-9">start_h_action?</label>
    </transition>
    <transition>
        <source ref="id17"/>
        <target ref="id18"/>
        <label kind="assignment" x="-722" y="-9">initHuman()</label>
    </transition>
</template>
<template>
    <name>Human_Follower</name>
    <parameter>int id, double _v, int p_f, int p_fw, int start_from, int path</parameter>
    <declaration>clock t, F, Fp;
clock tUpd;
clock freeWill;

double lambda, mi;
const double passout_th = 1.0;

// Free Will Model
int obey = 100;
int disobey = 0;
int freeWillRange = 100;
int freeWillTh = 101;

// Fatigue Sharing Parameters
const int Tpoll = 1;

bool ONCE_FTG = true;
bool ONCE_POS = true;

int v;

void updateF(double coeff, bool walking) {
    // if two human instances are the same person,
    // residual conditions must be retrieved
    if (ONCE_FTG &amp;&amp; start_from!=-1 &amp;&amp; currH==id) {
        F = internalFatigue[start_from-1];
        Fp = F;
        internalFatigue[id-1] = F;
        ONCE_FTG = false;
    }

    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
    curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void updateP() {
    double eps = 0.0;
    // same as ONCE_FTG
    if (ONCE_POS &amp;&amp; start_from!=-1) {
        humanPositionX[id-1] = internalHumX[start_from-1];
        humanPositionY[id-1] = internalHumY[start_from-1];
        internalHumX[id-1] = humanPositionX[id-1];
        internalHumY[id-1] = humanPositionY[id-1];
        ONCE_POS = false;
    }

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void updateFreeWill(){
    if(currH==id) { //if human is being served, they are entitled to free will
        obey = 99;
        disobey = 1;
    } else { //if human is not currently active, no one cares about their free will
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20; // freeWill is assigned in range [0, 10] and to trigger it should be &gt;20
    }
}

void initHuman() {
    t = 0;
    tUpd = 0;
    F = 0;
    Fp = 0;
    v = fint(_v);

    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }
    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}
    </declaration>
    <location id="id36" x="-390" y="-255">
        <name x="-425" y="-246">idle</name>
        <label kind="invariant" x="-450" y="-229">freeWill'==0
            &amp;&amp; Fp'==0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id37" x="221" y="-255">
        <name x="213" y="-289">busy</name>
        <label kind="invariant" x="212" y="-374">freeWill'==0
            &amp;&amp; Fp'==0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id38" x="-585" y="-254">
        <name x="-628" y="-271">Init</name>
        <committed/>
    </location>
    <location id="id39" x="374" y="-255">
        <name x="391" y="-272">passed_out</name>
        <label kind="invariant" x="391" y="-255">t' == 0 &amp;&amp;
            F' == 0 &amp;&amp;
            freeWill' == 0
        </label>
        <label kind="exponentialrate" x="366" y="-238">1</label>
    </location>
    <location id="id40" x="-127" y="-357">
        <name x="-137" y="-391">c1</name>
        <committed/>
    </location>
    <location id="id41" x="43" y="-111">
        <name x="51" y="-145">c3</name>
        <committed/>
    </location>
    <location id="id42" x="60" y="-357">
        <name x="50" y="-391">c2</name>
        <committed/>
    </location>
    <location id="id43" x="-390" y="-476">
        <committed/>
    </location>
    <location id="id44" x="221" y="-34">
        <committed/>
    </location>
    <location id="id45" x="-390" y="-366">
        <committed/>
    </location>
    <location id="id46" x="221" y="-153">
        <committed/>
    </location>
    <branchpoint id="id47" x="-16" y="-111">
    </branchpoint>
    <branchpoint id="id48" x="-76" y="-357">
    </branchpoint>
    <init ref="id38"/>
    <transition>
        <source ref="id44"/>
        <target ref="id37"/>
        <label kind="guard" x="136" y="-127">currH!=id</label>
        <nail x="170" y="-119"/>
    </transition>
    <transition>
        <source ref="id43"/>
        <target ref="id36"/>
        <label kind="guard" x="-339" y="-391">currH!=id</label>
        <nail x="-339" y="-374"/>
    </transition>
    <transition>
        <source ref="id46"/>
        <target ref="id37"/>
        <label kind="synchronisation" x="179" y="-179">publish_m[4]!</label>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id46"/>
        <label kind="guard" x="187" y="-102">currH==id</label>
        <label kind="synchronisation" x="170" y="-85">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id45"/>
        <target ref="id36"/>
        <label kind="synchronisation" x="-390" y="-327">publish_m[4]!</label>
    </transition>
    <transition>
        <source ref="id43"/>
        <target ref="id45"/>
        <label kind="guard" x="-390" y="-455">currH==id</label>
        <label kind="synchronisation" x="-390" y="-425">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id37"/>
        <target ref="id44"/>
        <label kind="guard" x="272" y="-162">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="272" y="-145">updateF(-lambda, 1),
            updateP(), tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="272" y="-145"/>
    </transition>
    <transition>
        <source ref="id36"/>
        <target ref="id43"/>
        <label kind="guard" x="-518" y="-383">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-654" y="-366">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="-424" y="-366"/>
    </transition>
    <transition>
        <source ref="id36"/>
        <target ref="id42"/>
        <label kind="guard" x="-271" y="-451">!served[id-1]
            &amp;&amp; freeWill&gt;=freeWillTh
        </label>
        <label kind="synchronisation" x="-263" y="-417">free_start!</label>
        <label kind="assignment" x="-93" y="-442">t = 0, tUpd=0,
            freeWill = 0
        </label>
        <nail x="-263" y="-400"/>
        <nail x="9" y="-400"/>
    </transition>
    <transition>
        <source ref="id42"/>
        <target ref="id37"/>
        <label kind="guard" x="17" y="-306">F&lt;=0</label>
        <label kind="assignment" x="17" y="-289">F=0,
            Fp=1,
            plan_traj()
        </label>
        <nail x="60" y="-255"/>
    </transition>
    <transition>
        <source ref="id42"/>
        <target ref="id37"/>
        <label kind="guard" x="77" y="-357">F&gt;0</label>
        <label kind="assignment" x="68" y="-340">Fp=1-F,
            plan_traj()
        </label>
        <nail x="128" y="-357"/>
    </transition>
    <transition>
        <source ref="id48"/>
        <target ref="id42"/>
        <label kind="assignment" x="-59" y="-357">t = 0,
            tUpd=0
        </label>
        <label kind="probability" x="-59" y="-374">obey</label>
    </transition>
    <transition>
        <source ref="id37"/>
        <target ref="id36"/>
        <label kind="guard" x="-323" y="-76">served[id-1] || (!served[id-1] &amp;&amp;
            freeWill&gt;=freeWillTh)
        </label>
        <label kind="synchronisation" x="-297" y="-43">free_stop!</label>
        <label kind="assignment" x="-93" y="-77">t = 0, freeWill = 0, Fp = F,
            tUpd=0,
            updateFreeWill()
        </label>
        <nail x="119" y="-85"/>
        <nail x="-305" y="-85"/>
    </transition>
    <transition>
        <source ref="id47"/>
        <target ref="id37"/>
        <label kind="probability" x="-16" y="-187">disobey</label>
        <nail x="-16" y="-170"/>
        <nail x="170" y="-170"/>
    </transition>
    <transition>
        <source ref="id47"/>
        <target ref="id36"/>
        <label kind="assignment" x="-186" y="-230">t = 0, Fp=F,
            tUpd=0,
            updateFreeWill()
        </label>
        <label kind="probability" x="-229" y="-196">obey</label>
        <nail x="-59" y="-170"/>
        <nail x="-322" y="-170"/>
    </transition>
    <transition>
        <source ref="id41"/>
        <target ref="id47"/>
    </transition>
    <transition>
        <source ref="id37"/>
        <target ref="id41"/>
        <label kind="synchronisation" x="51" y="-187">stop_h_action?</label>
        <nail x="170" y="-170"/>
        <nail x="43" y="-170"/>
    </transition>
    <transition>
        <source ref="id36"/>
        <target ref="id40"/>
        <label kind="guard" x="-246" y="-391">currH==id</label>
        <label kind="synchronisation" x="-271" y="-374">start_h_action?</label>
        <nail x="-263" y="-357"/>
    </transition>
    <transition>
        <source ref="id48"/>
        <target ref="id36"/>
        <label kind="probability" x="-144" y="-323">disobey</label>
        <nail x="-76" y="-323"/>
        <nail x="-263" y="-323"/>
    </transition>
    <transition>
        <source ref="id40"/>
        <target ref="id48"/>
    </transition>
    <transition>
        <source ref="id37"/>
        <target ref="id39"/>
        <label kind="guard" x="239" y="-272">F &gt;= passout_th</label>
        <label kind="synchronisation" x="264" y="-255">pass_out!</label>
        <label kind="assignment" x="315" y="-238">t = 0</label>
    </transition>
    <transition>
        <source ref="id39"/>
        <target ref="id39"/>
        <nail x="349" y="-204"/>
        <nail x="391" y="-204"/>
    </transition>
    <transition>
        <source ref="id38"/>
        <target ref="id36"/>
        <label kind="assignment" x="-544" y="-246">initHuman()</label>
    </transition>
</template>
<template>
    <name>Human_Leader</name>
    <parameter>int id, double _v, int p_f, int p_fw, int start_from, int path</parameter>
    <declaration>clock t, F, Fp;
clock tUpd;
clock freeWill;

double lambda, mi;
const double passout_th = 1.0;

//Free Will Model
double freeWillTh = 100.0;
double freeWillRange = 95.0;

// Fatigue Sharing Parameters
const int Tpoll = 1;

bool ONCE_FTG = true;
bool ONCE_POS = true;

int v;

// Position Sharing Parameters

void updateF(double coeff, bool walking) {
    // if two human instances are the same person,
    // residual conditions must be retrieved
    if (ONCE_FTG &amp;&amp; start_from!=-1 &amp;&amp; currH==id) {
        F = internalFatigue[start_from-1];
        Fp = F;
        internalFatigue[id-1] = F;
        ONCE_FTG = false;
    }

    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    // same as ONCE_FTG
    if (ONCE_POS &amp;&amp; start_from!=-1) {
        humanPositionX[id-1] = internalHumX[start_from-1];
        humanPositionY[id-1] = internalHumY[start_from-1];
        internalHumX[id-1] = humanPositionX[id-1];
        internalHumY[id-1] = humanPositionY[id-1];
        ONCE_POS = false;
    }

    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    freeWill=0;
    plan_traj();
}

double dist_to_dest;
double humanRobotDist;
void checkSuccess() {
    dist_to_dest = pt_dist(destX[id-1], internalHumX[id-1], destY[id-1], internalHumY[id-1]);
    humanRobotDist = calculateDistance();
    // when humans reach their destination, they can set themselves as "served"
    if(dist_to_dest &lt;= v*1.5 &amp;&amp; humanRobotDist&lt;=4.0) {
        served[id-1] = true;
    }
}

void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void initHuman() {
    F = 0;
    Fp = 0;
    t = 0;
    v = fint(_v);

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}
    </declaration>
    <location id="id49" x="-357" y="-221" color="#0000ff">
        <name x="-399" y="-246">idle</name>
        <label kind="invariant" x="-340" y="-229">Fp' == 0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; freeWill' == 0
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id50" x="254" y="-221" color="#0000ff">
        <name x="263" y="-255">busy</name>
        <label kind="invariant" x="263" y="-357">Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; freeWill&lt;= freeWillTh
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id51" x="-552" y="-220">
        <name x="-595" y="-237">Init</name>
        <committed/>
    </location>
    <location id="id52" x="425" y="-221" color="#ff0000">
        <name x="442" y="-238">passed_out</name>
        <label kind="invariant" x="442" y="-221">t' == 0 &amp;&amp;
            F' == 0
        </label>
        <label kind="exponentialrate" x="417" y="-204">1</label>
    </location>
    <location id="id53" x="255" y="-42">
        <name x="272" y="-42">checking</name>
        <committed/>
    </location>
    <location id="id54" x="-42" y="-272">
        <name x="-52" y="-306">starting</name>
        <urgent/>
    </location>
    <location id="id55" x="-484" y="-408">
        <name x="-544" y="-417">pub_2</name>
        <committed/>
    </location>
    <location id="id56" x="-357" y="-408">
        <name x="-367" y="-442">pub_1</name>
        <committed/>
    </location>
    <location id="id57" x="195" y="-221">
        <name x="170" y="-255">pub_4</name>
        <committed/>
    </location>
    <location id="id58" x="195" y="42">
        <name x="170" y="59">pub_3</name>
        <committed/>
    </location>
    <location id="id59" x="-246" y="-110">
        <name x="-314" y="-136">stopping</name>
    </location>
    <location id="id60" x="-467" y="-59" color="#a9a9a9">
        <name x="-569" y="-76">not_needed</name>
        <label kind="exponentialrate" x="-450" y="-68">1</label>
    </location>
    <init ref="id51"/>
    <transition>
        <source ref="id60"/>
        <target ref="id60"/>
        <nail x="-467" y="-8"/>
        <nail x="-442" y="-8"/>
    </transition>
    <transition>
        <source ref="id49"/>
        <target ref="id60"/>
        <label kind="guard" x="-535" y="-144">PATH!=0
            &amp;&amp; PATH!=path
        </label>
        <nail x="-467" y="-144"/>
    </transition>
    <transition>
        <source ref="id53"/>
        <target ref="id59"/>
        <label kind="guard" x="-34" y="-76">served[id-1] ||
            freeWill&gt;=freeWillTh
        </label>
        <label kind="synchronisation" x="-34" y="-42">stop_h_action!</label>
        <label kind="assignment" x="-34" y="-25">hExe = 0, Fp = F</label>
        <nail x="-246" y="-42"/>
    </transition>
    <transition>
        <source ref="id59"/>
        <target ref="id49"/>
        <label kind="synchronisation" x="-357" y="-110">r_still?</label>
        <label kind="assignment" x="-357" y="-93">t = 0, tUpd=0</label>
        <nail x="-357" y="-110"/>
    </transition>
    <transition>
        <source ref="id50"/>
        <target ref="id59"/>
        <label kind="guard" x="-161" y="-161">!served[id-1] &amp;&amp;
            freeWill &gt;= freeWillTh &amp;&amp;
            tUpd&gt;=Tpoll
        </label>
        <label kind="synchronisation" x="-161" y="-110">stop_h_action!</label>
        <label kind="assignment" x="-161" y="-93">hExe = 0, Fp=F</label>
        <nail x="255" y="-110"/>
    </transition>
    <transition>
        <source ref="id56"/>
        <target ref="id49"/>
        <label kind="guard" x="-459" y="-323">currH!=id</label>
        <nail x="-416" y="-408"/>
        <nail x="-416" y="-221"/>
    </transition>
    <transition>
        <source ref="id57"/>
        <target ref="id50"/>
        <label kind="synchronisation" x="93" y="-153">publish_m[4]!</label>
        <label kind="assignment" x="127" y="-136">tUpd=0</label>
    </transition>
    <transition>
        <source ref="id58"/>
        <target ref="id57"/>
        <label kind="synchronisation" x="93" y="-8">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id53"/>
        <target ref="id58"/>
        <label kind="guard" x="263" y="-8">!served[id-1] &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="assignment" x="263" y="25">updateP(),
            updateF(-lambda, 1)
        </label>
        <nail x="255" y="42"/>
    </transition>
    <transition>
        <source ref="id55"/>
        <target ref="id49"/>
        <label kind="synchronisation" x="-527" y="-289">publish_m[4]!</label>
        <label kind="assignment" x="-484" y="-272">tUpd=0</label>
        <nail x="-484" y="-221"/>
    </transition>
    <transition>
        <source ref="id56"/>
        <target ref="id55"/>
        <label kind="guard" x="-467" y="-450">currH==id</label>
        <label kind="synchronisation" x="-467" y="-433">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id49"/>
        <target ref="id56"/>
        <label kind="guard" x="-348" y="-391">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-348" y="-374">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
    </transition>
    <transition>
        <source ref="id54"/>
        <target ref="id50"/>
        <label kind="guard" x="34" y="-238">F==0</label>
        <label kind="assignment" x="85" y="-238">Fp=1</label>
        <nail x="-42" y="-221"/>
    </transition>
    <transition>
        <source ref="id54"/>
        <target ref="id50"/>
        <label kind="guard" x="-17" y="-289">F&gt;0</label>
        <label kind="assignment" x="17" y="-289">Fp=1-F</label>
        <nail x="255" y="-272"/>
    </transition>
    <transition>
        <source ref="id49"/>
        <target ref="id54"/>
        <label kind="guard" x="-246" y="-306">!served[id-1]
            &amp;&amp; currH == id
        </label>
        <label kind="synchronisation" x="-246" y="-272">start_h_action!</label>
        <label kind="assignment" x="-246" y="-255">start_moving()</label>
        <nail x="-357" y="-272"/>
    </transition>
    <transition>
        <source ref="id50"/>
        <target ref="id53"/>
        <label kind="guard" x="263" y="-153">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="263" y="-136">checkSuccess(),
            freeWill = random(freeWillRange)
        </label>
    </transition>
    <transition>
        <source ref="id50"/>
        <target ref="id52"/>
        <label kind="guard" x="272" y="-238">F &gt;= passout_th</label>
        <label kind="synchronisation" x="289" y="-221">pass_out!</label>
        <label kind="assignment" x="289" y="-204">t = 0, hExe = 0</label>
    </transition>
    <transition>
        <source ref="id52"/>
        <target ref="id52"/>
        <nail x="400" y="-170"/>
        <nail x="442" y="-170"/>
    </transition>
    <transition>
        <source ref="id51"/>
        <target ref="id49"/>
        <label kind="assignment" x="-510" y="-221">initHuman()</label>
    </transition>
</template>
<template>
    <name>Human_Recipient</name>
    <parameter>int id, double _v, int p_f, int p_fw, int path</parameter>
    <declaration>clock t, F, Fp;
clock tUpd;
clock freeWill;

double lambda, mi;
const double passout_th = 1.0;

//Free Will Model
double freeWillTh = 100.0;
double freeWillRange = 95.0;

// Fatigue Sharing Parameters
const int Tpoll = 1;

int v;

// Position Sharing Parameters

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    plan_traj();
}

double dist_to_dest;
void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 20.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void updateFreeWill(){
    if(currH==id) {
        freeWillTh = 100.0;
        freeWillRange = 95.0;
    } else {
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20;
    }
}

void initHuman() {
    F = 0;
    Fp = 0;
    t = 0;
    v = fint(_v);

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}
    </declaration>
    <location id="id61" x="-492" y="-399" color="#0000ff">
        <name x="-526" y="-425">idle</name>
        <label kind="invariant" x="-612" y="-518">Fp' == 0
            &amp;&amp; freeWill' == 0
            &amp;&amp; freeWill&lt;=freeWillTh
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id62" x="119" y="-399" color="#0000ff">
        <name x="127" y="-442">busy_mov</name>
        <label kind="invariant" x="127" y="-544">Fp' == 0
            &amp;&amp; freeWill' == 0
            &amp;&amp; freeWill&lt;=freeWillTh
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id63" x="-687" y="-398">
        <name x="-730" y="-415">Init</name>
        <committed/>
    </location>
    <location id="id64" x="272" y="-399" color="#ff0000">
        <name x="289" y="-416">passed_out</name>
        <label kind="invariant" x="289" y="-399">t' == 0 &amp;&amp;
            F' == 0 &amp;&amp;
            freeWill' == 0
        </label>
        <label kind="exponentialrate" x="264" y="-382">1</label>
    </location>
    <location id="id65" x="-195" y="-569" color="#0000ff">
        <name x="-186" y="-561">busy_rec</name>
        <label kind="invariant" x="-187" y="-544">Fp' == 0
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id66" x="-493" y="-246">
        <name x="-476" y="-238">pub_1</name>
        <committed/>
    </location>
    <location id="id67" x="-578" y="-246">
        <name x="-638" y="-254">pub_2</name>
        <committed/>
    </location>
    <location id="id68" x="119" y="-246">
        <name x="102" y="-229">pub_5</name>
        <committed/>
    </location>
    <location id="id69" x="119" y="-323">
        <name x="59" y="-331">pub_6</name>
        <committed/>
    </location>
    <location id="id70" x="-85" y="-714">
        <name x="-95" y="-748">pub_4</name>
        <committed/>
    </location>
    <location id="id71" x="-195" y="-714">
        <name x="-205" y="-748">pub_3</name>
        <committed/>
    </location>
    <location id="id72" x="-688" y="-501" color="#a9a9a9">
        <name x="-698" y="-535">not_needed</name>
        <label kind="exponentialrate" x="-714" y="-510">1</label>
    </location>
    <init ref="id63"/>
    <transition>
        <source ref="id72"/>
        <target ref="id72"/>
        <nail x="-629" y="-501"/>
        <nail x="-629" y="-467"/>
    </transition>
    <transition>
        <source ref="id61"/>
        <target ref="id72"/>
        <label kind="guard" x="-731" y="-476">PATH!=0
            &amp;&amp; PATH!=path
        </label>
        <nail x="-688" y="-425"/>
    </transition>
    <transition>
        <source ref="id68"/>
        <target ref="id62"/>
        <label kind="guard" x="-93" y="-348">currH!=id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <nail x="0" y="-246"/>
        <nail x="0" y="-399"/>
    </transition>
    <transition>
        <source ref="id71"/>
        <target ref="id65"/>
        <label kind="guard" x="-289" y="-739">currH!=id</label>
        <nail x="-289" y="-714"/>
        <nail x="-289" y="-569"/>
    </transition>
    <transition>
        <source ref="id66"/>
        <target ref="id62"/>
        <label kind="guard" x="-178" y="-433">freeWill&gt;=freeWillTh</label>
        <label kind="synchronisation" x="-178" y="-416">free_start!</label>
        <label kind="assignment" x="-178" y="-399">t = 0, Fp = 1-F,
            tUpd=0, freeWill = 0,
            plan_traj()
        </label>
        <nail x="-187" y="-246"/>
        <nail x="-187" y="-399"/>
    </transition>
    <transition>
        <source ref="id68"/>
        <target ref="id61"/>
        <label kind="guard" x="-178" y="-280">freeWill&gt;=freeWillTh</label>
        <label kind="synchronisation" x="-178" y="-263">free_stop!</label>
        <label kind="assignment" x="-178" y="-246">t = 0, Fp = F, freeWill = 0,
            tUpd=0, updateFreeWill()
        </label>
        <nail x="-229" y="-246"/>
        <nail x="-229" y="-399"/>
    </transition>
    <transition>
        <source ref="id70"/>
        <target ref="id65"/>
        <label kind="synchronisation" x="-136" y="-663">publish_m[4]!</label>
        <label kind="assignment" x="-136" y="-646">tUpd=0</label>
        <nail x="-85" y="-569"/>
    </transition>
    <transition>
        <source ref="id71"/>
        <target ref="id70"/>
        <label kind="guard" x="-178" y="-714">currH==id</label>
        <label kind="synchronisation" x="-187" y="-697">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id65"/>
        <target ref="id71"/>
        <label kind="guard" x="-289" y="-663">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-289" y="-646">updateF(-mi, 0),
            tUpd=0
        </label>
    </transition>
    <transition>
        <source ref="id69"/>
        <target ref="id62"/>
        <label kind="synchronisation" x="17" y="-357">publish_m[4]!</label>
        <label kind="assignment" x="59" y="-374">tUpd=0</label>
    </transition>
    <transition>
        <source ref="id68"/>
        <target ref="id69"/>
        <label kind="guard" x="17" y="-306">currH==id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="synchronisation" x="17" y="-272">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id62"/>
        <target ref="id68"/>
        <label kind="guard" x="204" y="-314">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="204" y="-297">updateF(-lambda, 1),
            updateP(), tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="195" y="-399"/>
        <nail x="195" y="-246"/>
    </transition>
    <transition>
        <source ref="id67"/>
        <target ref="id61"/>
        <label kind="synchronisation" x="-671" y="-331">publish_m[4]!</label>
        <label kind="assignment" x="-671" y="-314">tUpd=0</label>
        <nail x="-578" y="-399"/>
    </transition>
    <transition>
        <source ref="id66"/>
        <target ref="id67"/>
        <label kind="guard" x="-561" y="-289">currH==id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="synchronisation" x="-561" y="-306">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id66"/>
        <target ref="id61"/>
        <label kind="guard" x="-544" y="-365">currH!=id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
    </transition>
    <transition>
        <source ref="id61"/>
        <target ref="id66"/>
        <label kind="guard" x="-399" y="-357">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-399" y="-340">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="-408" y="-399"/>
        <nail x="-408" y="-246"/>
    </transition>
    <transition>
        <source ref="id65"/>
        <target ref="id61"/>
        <label kind="synchronisation" x="-484" y="-569">stop_h_action?</label>
        <label kind="assignment" x="-484" y="-620">t = 0, Fp = F,
            freeWill = 0,
            tUpd=0
        </label>
        <nail x="-493" y="-569"/>
    </transition>
    <transition>
        <source ref="id62"/>
        <target ref="id65"/>
        <label kind="guard" x="-17" y="-637">currH==id</label>
        <label kind="synchronisation" x="-17" y="-569">start_h_action?</label>
        <label kind="assignment" x="-17" y="-620">t = 0, Fp = F,
            freeWill = 0,
            tUpd=0
        </label>
        <nail x="119" y="-569"/>
    </transition>
    <transition>
        <source ref="id61"/>
        <target ref="id65"/>
        <label kind="guard" x="-474" y="-433">currH==id</label>
        <label kind="synchronisation" x="-357" y="-501">start_h_action?</label>
        <label kind="assignment" x="-357" y="-484">F = 0, t = 0,
            tUpd=0
        </label>
        <nail x="-365" y="-399"/>
        <nail x="-365" y="-569"/>
    </transition>
    <transition>
        <source ref="id62"/>
        <target ref="id64"/>
        <label kind="guard" x="137" y="-416">F &gt;= passout_th</label>
        <label kind="synchronisation" x="162" y="-399">pass_out!</label>
        <label kind="assignment" x="213" y="-382">t = 0</label>
    </transition>
    <transition>
        <source ref="id64"/>
        <target ref="id64"/>
        <nail x="247" y="-348"/>
        <nail x="289" y="-348"/>
    </transition>
    <transition>
        <source ref="id63"/>
        <target ref="id61"/>
        <label kind="assignment" x="-671" y="-416">initHuman()</label>
    </transition>
</template>
<template>
    <name>Human_Rescuer</name>
    <parameter>int id, double v, int p_f, int p_fw, int p_dext, int path</parameter>
    <declaration>//PATTERN N°10
clock t, F, Fp;
clock tUpd;
clock freeWill;

double lambda, mi;
const double passout_th = 1.0;

//Free Will Model
int obey = 100;
int disobey = 0;
double freeWillTh = 100.0;
double freeWillRange = 100.0;

// Fatigue Sharing Parameters
const int Tpoll = 1;


// Position Sharing Parameters

bool nearRobot = false;

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}


double dist_to_dest;

void updateP(){
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void updateFreeWill(){
    if(currH==id) {
        freeWillTh = 100.0;
        freeWillRange = 95.0;
        //freeWillTh = 50.0; //riottoso
    } else {
        freeWill = 0;
        freeWillRange = 10;
        freeWillTh = 20;
    }
}

void initHuman() {
    F = 0;
    Fp = 0;
    t = 0;

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    dext = p_dext;
    task_completion = 0;

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if(p_f==5) {
        lambda = COVID_PATIENT[0]; mi = COVID_PATIENT[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    if(p_fw==1) {
        freeWillTh = NORMAL;
    } else if(p_fw == 2) {
        freeWillTh = HIGH;
    } else if(p_fw == 3) {
        freeWillTh = DISABLED;
    }
}

void updateT(){
    task_completion += dext * (random(1)&gt;=0.5);
}

void checkRobot(){
    nearRobot = calculateDistance() &lt;= v/100*1.2;
}
    </declaration>
    <location id="id73" x="-595" y="17">
        <name x="-605" y="-17">Init</name>
        <committed/>
    </location>
    <location id="id74" x="-391" y="204">
        <name x="-391" y="213">c1</name>
        <committed/>
    </location>
    <location id="id75" x="204" y="17" color="#0000ff">
        <name x="212" y="-8">exec</name>
        <label kind="invariant" x="212" y="25">Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id76" x="-391" y="17" color="#0000ff">
        <name x="-425" y="25">idle</name>
        <label kind="invariant" x="-510" y="42">freeWill'==0
            &amp;&amp; Fp'==0
            &amp;&amp; F' == -Fp*mi*exp(-mi*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id77" x="-391" y="-68">
        <committed/>
    </location>
    <location id="id78" x="-391" y="-221">
        <committed/>
    </location>
    <location id="id79" x="204" y="-153">
        <name x="194" y="-187">checking</name>
        <committed/>
    </location>
    <location id="id80" x="450" y="-153">
        <committed/>
    </location>
    <location id="id81" x="450" y="17">
        <committed/>
    </location>
    <location id="id82" x="-34" y="204">
        <name x="-44" y="170">c2</name>
        <committed/>
    </location>
    <location id="id83" x="17" y="-34">
        <committed/>
    </location>
    <location id="id84" x="204" y="204" color="#0000ff">
        <name x="194" y="170">moving</name>
        <label kind="invariant" x="161" y="221">Fp' == 0
            &amp;&amp; F &lt;= passout_th
            &amp;&amp; freeWill' == 0
            &amp;&amp; F' == Fp*lambda*exp(-lambda*t)
            &amp;&amp; tUpd&lt;=Tpoll
        </label>
    </location>
    <location id="id85" x="433" y="255">
        <name x="423" y="221">c3</name>
        <committed/>
    </location>
    <location id="id86" x="663" y="204">
        <name x="671" y="221">checking_2</name>
        <committed/>
    </location>
    <location id="id87" x="799" y="17" color="#ff0000">
        <name x="807" y="25">passed_out</name>
        <label kind="invariant" x="807" y="42">t' == 0 &amp;&amp;
            F' == 0 &amp;&amp;
            freeWill' == 0
        </label>
        <label kind="exponentialrate" x="782" y="-17">1</label>
    </location>
    <location id="id88" x="204" y="476">
        <committed/>
    </location>
    <location id="id89" x="-595" y="-153" color="#a9a9a9">
        <name x="-605" y="-187">not_needed</name>
        <label kind="exponentialrate" x="-586" y="-136">1</label>
    </location>
    <branchpoint id="id90" x="-391" y="476">
    </branchpoint>
    <branchpoint id="id91" x="17" y="17">
    </branchpoint>
    <branchpoint id="id92" x="-102" y="204">
    </branchpoint>
    <init ref="id73"/>
    <transition>
        <source ref="id89"/>
        <target ref="id89"/>
        <nail x="-544" y="-153"/>
        <nail x="-544" y="-119"/>
    </transition>
    <transition>
        <source ref="id76"/>
        <target ref="id89"/>
        <label kind="guard" x="-663" y="-93">PATH!=0
            &amp;&amp; PATH!=path
        </label>
        <nail x="-595" y="-25"/>
    </transition>
    <transition>
        <source ref="id79"/>
        <target ref="id75"/>
        <label kind="guard" x="323" y="-136">currH!=id &amp;&amp;
            !served[id-1] &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="assignment" x="323" y="-85">tUpd=0</label>
        <nail x="323" y="-153"/>
        <nail x="323" y="-42"/>
    </transition>
    <transition>
        <source ref="id86"/>
        <target ref="id84"/>
        <label kind="guard" x="382" y="161">currH!=id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <nail x="433" y="187"/>
    </transition>
    <transition>
        <source ref="id79"/>
        <target ref="id76"/>
        <label kind="guard" x="-8" y="-212">served[id-1]</label>
        <label kind="assignment" x="-8" y="-195">hExe = 0, Fp = F, tUpd=0,
            t = 0,updateFreeWill()
        </label>
        <nail x="-34" y="-153"/>
    </transition>
    <transition>
        <source ref="id78"/>
        <target ref="id82"/>
        <label kind="guard" x="-272" y="-280">currH==id
            &amp;&amp; freeWill&gt;=freeWillTh
            &amp;&amp; task_completion &lt; task_size
        </label>
        <label kind="synchronisation" x="-373" y="-238">free_start!</label>
        <label kind="assignment" x="-373" y="-221">freeWill=0</label>
        <nail x="-34" y="-221"/>
    </transition>
    <transition>
        <source ref="id86"/>
        <target ref="id76"/>
        <label kind="guard" x="357" y="331">freeWill&gt;=freeWillTh</label>
        <label kind="synchronisation" x="357" y="348">free_stop!</label>
        <label kind="assignment" x="357" y="374">hExe=0, t = 0, Fp=F,
            tUpd=0,
            updateFreeWill()
        </label>
        <nail x="663" y="365"/>
        <nail x="-391" y="365"/>
    </transition>
    <transition>
        <source ref="id84"/>
        <target ref="id75"/>
        <label kind="guard" x="127" y="76">nearRobot</label>
        <label kind="assignment" x="85" y="93">t = 0, tUpd=0,
            Fp=F, freeWill=0
        </label>
        <label kind="comments" x="484" y="-161">//errore se metto &amp;&amp; freeWill&lt;=freeWillTh.
            general hybrid guard without urgent channel
        </label>
    </transition>
    <transition>
        <source ref="id75"/>
        <target ref="id87"/>
        <label kind="guard" x="535" y="17">F&gt;=passout_th</label>
        <label kind="synchronisation" x="535" y="34">pass_out!</label>
        <label kind="assignment" x="535" y="51">t=0</label>
    </transition>
    <transition>
        <source ref="id90"/>
        <target ref="id76"/>
        <label kind="assignment" x="-518" y="416">t = 0, Fp=F,
            tUpd=0,
            updateFreeWill(),
            hExe=0
        </label>
        <label kind="probability" x="-518" y="399">obey</label>
    </transition>
    <transition>
        <source ref="id90"/>
        <target ref="id84"/>
        <label kind="probability" x="-59" y="382">disobey</label>
    </transition>
    <transition>
        <source ref="id88"/>
        <target ref="id90"/>
    </transition>
    <transition>
        <source ref="id84"/>
        <target ref="id88"/>
        <label kind="synchronisation" x="170" y="399">stop_h_action?</label>
    </transition>
    <transition>
        <source ref="id87"/>
        <target ref="id87"/>
        <nail x="841" y="-8"/>
        <nail x="841" y="17"/>
    </transition>
    <transition>
        <source ref="id84"/>
        <target ref="id87"/>
        <label kind="guard" x="807" y="127">F&gt;=passout_th</label>
        <label kind="synchronisation" x="807" y="144">pass_out!</label>
        <label kind="assignment" x="807" y="161">t = 0</label>
        <nail x="799" y="204"/>
    </transition>
    <transition>
        <source ref="id85"/>
        <target ref="id84"/>
        <label kind="synchronisation" x="289" y="221">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id86"/>
        <target ref="id85"/>
        <label kind="guard" x="484" y="221">currH==id &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="synchronisation" x="484" y="255">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id84"/>
        <target ref="id86"/>
        <label kind="guard" x="391" y="127">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="484" y="93">updateF(-lambda, 1),
            checkRobot(),
            updateP(), tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="433" y="144"/>
    </transition>
    <transition>
        <source ref="id82"/>
        <target ref="id84"/>
        <label kind="guard" x="59" y="136">F==0</label>
        <label kind="assignment" x="-8" y="153">Fp=1, plan_traj(), hExe = 1</label>
        <nail x="76" y="153"/>
    </transition>
    <transition>
        <source ref="id82"/>
        <target ref="id84"/>
        <label kind="guard" x="59" y="204">F&gt;0</label>
        <label kind="assignment" x="-17" y="221">Fp=1-F, plan_traj(), hExe = 1</label>
    </transition>
    <transition>
        <source ref="id91"/>
        <target ref="id76"/>
        <label kind="assignment" x="-127" y="17">t = 0, Fp=F,
            tUpd=0,
            updateFreeWill(), hExe=0
        </label>
        <label kind="probability" x="-136" y="0">obey</label>
    </transition>
    <transition>
        <source ref="id91"/>
        <target ref="id75"/>
        <label kind="probability" x="76" y="0">disobey</label>
    </transition>
    <transition>
        <source ref="id83"/>
        <target ref="id91"/>
    </transition>
    <transition>
        <source ref="id75"/>
        <target ref="id83"/>
        <label kind="synchronisation" x="76" y="-34">stop_h_action?</label>
        <nail x="204" y="-34"/>
    </transition>
    <transition>
        <source ref="id92"/>
        <target ref="id82"/>
        <label kind="probability" x="-93" y="136">obey</label>
    </transition>
    <transition>
        <source ref="id79"/>
        <target ref="id76"/>
        <label kind="guard" x="-144" y="-102">freeWill&gt;=freeWillTh
            &amp;&amp; !served[id-1]
        </label>
        <label kind="synchronisation" x="-144" y="-68">free_stop!</label>
        <label kind="assignment" x="-221" y="-51">hExe = 0, Fp = F, tUpd=0, t = 0,
            freeWill=0, updateFreeWill()
        </label>
        <label kind="comments" x="68" y="-263">human autonomously decides to leave --&gt; insuccess</label>
    </transition>
    <transition>
        <source ref="id81"/>
        <target ref="id75"/>
        <label kind="synchronisation" x="263" y="-17">publish_m[3]!</label>
        <label kind="assignment" x="263" y="0">tUpd=0</label>
    </transition>
    <transition>
        <source ref="id80"/>
        <target ref="id81"/>
        <label kind="synchronisation" x="425" y="-42">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id79"/>
        <target ref="id80"/>
        <label kind="guard" x="272" y="-238">currH==id &amp;&amp;
            !served[id-1] &amp;&amp;
            freeWill&lt;freeWillTh
        </label>
        <label kind="assignment" x="272" y="-187">updateT(),
            updateF(-lambda, 1)
        </label>
    </transition>
    <transition>
        <source ref="id75"/>
        <target ref="id79"/>
        <label kind="guard" x="204" y="-119">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="76" y="-85">freeWill = random(freeWillRange)</label>
    </transition>
    <transition>
        <source ref="id92"/>
        <target ref="id76"/>
        <label kind="probability" x="-357" y="51">disobey</label>
    </transition>
    <transition>
        <source ref="id74"/>
        <target ref="id92"/>
    </transition>
    <transition>
        <source ref="id78"/>
        <target ref="id77"/>
        <label kind="guard" x="-391" y="-161">currH==id
            &amp;&amp; freeWill&lt;=freeWillTh
        </label>
        <label kind="synchronisation" x="-391" y="-119">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id77"/>
        <target ref="id76"/>
        <label kind="synchronisation" x="-425" y="-51">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id78"/>
        <target ref="id76"/>
        <label kind="guard" x="-382" y="-187">currH!=id || served[id-1]</label>
        <nail x="-306" y="-102"/>
    </transition>
    <transition>
        <source ref="id76"/>
        <target ref="id78"/>
        <label kind="guard" x="-527" y="-153">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-527" y="-136">updateF(-mi, 0),
            tUpd=0,
            freeWill = random(freeWillRange)
        </label>
        <nail x="-459" y="-85"/>
    </transition>
    <transition>
        <source ref="id76"/>
        <target ref="id74"/>
        <label kind="guard" x="-476" y="144">currH==id</label>
        <label kind="synchronisation" x="-501" y="161">start_h_action?</label>
        <label kind="comments" x="-612" y="127">The human "notices" the robot</label>
    </transition>
    <transition>
        <source ref="id73"/>
        <target ref="id76"/>
        <label kind="assignment" x="-578" y="0">initHuman()</label>
    </transition>
</template>
<template>
	<name>Robot</name>
	<parameter>int id, double _v_max, double _a_max, double posX, double posY</parameter>
	<declaration>clock V, Th, tUpd;

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};

double ort = 0.0;
int curr_traj = 0;

// Position Sharing parameters
int t = 0;
const int T_poll = 1;
int v_max;
int a_max;

bool needsTurning = false;
void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;
void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
	int	k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
	bool close;
    curr[0] = internalRobX[id-1]; curr[1] = internalRobY[id-1];
    dest[0] = dX[id-1]; dest[1] = dY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;
    
    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    close = same_area(curr[0], curr[1], dest[0], dest[1]);
    while (!close)
    {
        for (j = 0; j &lt; N_I &amp;&amp; k&lt;3; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        if(neigh[0]==-1) close = true;
        else {
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
        close = same_area(curr[0], curr[1], dest[0], dest[1]);
        }
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalRobX[id-1], internalRobY[id-1], traj[0][0], traj[0][1]);
}

void update_pos(double coeff) {
    internalRobX[id-1] = internalRobX[id-1] + coeff*T_poll*cos(ort*PI/180);    
    internalRobY[id-1] = internalRobY[id-1] + coeff*T_poll*sin(ort*PI/180); 
}

void initRobot() {
    t = 0;
    V = 0;
    robPositionX[id-1] = posX;
    robPositionY[id-1] = posY;
    internalRobX[id-1] = posX;
    internalRobY[id-1] = posY;
    tUpd=0; 
    v_max = fint(_v_max);
    a_max = fint(_a_max);
}

void varsUpdate(double coeff) {
    tUpd = 0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
        return;

    if (pt_dist(internalRobX[id-1], traj[curr_traj][0], internalRobY[id-1], traj[curr_traj][1]) &lt; v_max*1.1) {
        curr_traj++;
        if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
            plan_traj();
        change_orientation(internalRobX[id-1], internalRobY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }
    
    update_pos(coeff);
}</declaration>
		<location id="id92" x="-629" y="-348">
			<name x="-672" y="-365">idle</name>
			<label kind="invariant" x="-722" y="-348">V' == 0 &amp;&amp; 
tUpd'==0</label>
		</location>
		<location id="id93" x="-424" y="-144">
			<name x="-501" y="-144">stopping</name>
			<label kind="invariant" x="-603" y="-144">V' == -a_max 
&amp;&amp; tUpd&lt;=T_poll</label>
			<label kind="comments" x="-603" y="-110">&amp;&amp; V &gt;=0</label>
		</location>
		<location id="id94" x="-425" y="-348">
			<name x="-408" y="-366">starting</name>
			<label kind="invariant" x="-348" y="-382">V' == a_max 
&amp;&amp; V &lt;= v_max
&amp;&amp; tUpd&lt;=T_poll</label>
		</location>
		<location id="id95" x="-161" y="-246">
			<name x="-229" y="-263">moving</name>
			<label kind="invariant" x="-263" y="-246">V' == 0 &amp;&amp; 
tUpd&lt;=T_poll</label>
		</location>
		<location id="id96" x="-629" y="-527">
			<name x="-639" y="-561">Init</name>
			<committed/>
		</location>
		<location id="id97" x="-850" y="-459">
			<name x="-943" y="-467">recharging</name>
			<label kind="invariant" x="-926" y="-450">V'==0 &amp;&amp; 
tUpd'==0</label>
		</location>
		<location id="id98" x="195" y="-246">
			<name x="212" y="-272">turning</name>
			<label kind="invariant" x="212" y="-255">V'==0 &amp;&amp;
Th&lt;=fabs(ort*PI/180)</label>
		</location>
		<location id="id99" x="51" y="-246">
			<committed/>
		</location>
		<location id="id100" x="-425" y="-527">
			<committed/>
		</location>
		<location id="id101" x="-425" y="76">
			<committed/>
		</location>
		<location id="id102" x="-59" y="-204">
			<committed/>
		</location>
		<location id="id103" x="-629" y="-144">
			<committed/>
		</location>
		<init ref="id96"/>
		<transition>
			<source ref="id93"/>
			<target ref="id103"/>
			<label kind="guard" x="-612" y="-187">V &lt;= 0</label>
			<label kind="assignment" x="-612" y="-170">active_robot[id-1] = true</label>
		</transition>
		<transition>
			<source ref="id102"/>
			<target ref="id95"/>
			<label kind="synchronisation" x="-153" y="-229">publish_m[id]!</label>
		</transition>
		<transition>
			<source ref="id99"/>
			<target ref="id102"/>
			<label kind="guard" x="-25" y="-229">!needsTurning</label>
			<label kind="assignment" x="-25" y="-212">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id101"/>
			<target ref="id93"/>
			<label kind="synchronisation" x="-561" y="-42">publish_m[id]!</label>
			<nail x="-459" y="17"/>
			<nail x="-459" y="-85"/>
		</transition>
		<transition>
			<source ref="id100"/>
			<target ref="id94"/>
			<label kind="synchronisation" x="-382" y="-467">publish_m[1]!</label>
			<nail x="-391" y="-484"/>
			<nail x="-391" y="-399"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id101"/>
			<label kind="guard" x="-416" y="-25">tUpd&gt;=T_poll
&amp;&amp;V&gt;0</label>
			<label kind="assignment" x="-416" y="8">t+=T_poll, tUpd=0,
varsUpdate(v_max-a_max*t)</label>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id100"/>
			<label kind="guard" x="-527" y="-476">tUpd&gt;=T_poll
&amp;&amp;V&lt;v_max</label>
			<label kind="assignment" x="-569" y="-442">t+=T_poll, tUpd=0,
varsUpdate(a_max*t)</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id93"/>
			<label kind="guard" x="-119" y="-178">active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-331" y="-161">stop_r_action?</label>
			<label kind="assignment" x="-119" y="-144">tUpd=0, t=0,
active_robot[id-1] = false</label>
			<nail x="195" y="-144"/>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id95"/>
			<label kind="guard" x="-85" y="-365">Th&gt;=fabs(ort*PI/180)</label>
			<label kind="assignment" x="-85" y="-348">tUpd = 0, Th = 0,
needsTurning = false</label>
			<nail x="195" y="-348"/>
			<nail x="-161" y="-348"/>
		</transition>
		<transition>
			<source ref="id99"/>
			<target ref="id98"/>
			<label kind="guard" x="67" y="-263">needsTurning</label>
			<label kind="assignment" x="67" y="-246">Th=0</label>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id99"/>
			<label kind="guard" x="-110" y="-280">tUpd&gt;=T_poll</label>
			<label kind="assignment" x="-119" y="-263">varsUpdate(v_max)</label>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id94"/>
			<label kind="guard" x="-416" y="-323">V&gt;0 &amp;&amp;
active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-416" y="-289">start_r_action?</label>
			<label kind="assignment" x="-416" y="-272">t=0, tUpd=0,
plan_traj(),
active_robot[id-1] = false</label>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id93"/>
			<label kind="guard" x="-603" y="-289">V&lt;v_max &amp;&amp;
active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-603" y="-255">stop_r_action?</label>
			<label kind="assignment" x="-603" y="-238">t=0, tUpd=0,
active_robot[id-1] = false</label>
			<nail x="-459" y="-323"/>
			<nail x="-459" y="-161"/>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id92"/>
			<label kind="guard" x="-816" y="-510">active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-816" y="-493">stop_recharging?</label>
			<label kind="assignment" x="-816" y="-476">tUpd=0,
active_robot[id-1] = false</label>
			<nail x="-629" y="-459"/>
		</transition>
		<transition>
			<source ref="id92"/>
			<target ref="id97"/>
			<label kind="synchronisation" x="-842" y="-416">start_recharging[id]?</label>
			<nail x="-850" y="-348"/>
		</transition>
		<transition>
			<source ref="id103"/>
			<target ref="id92"/>
			<label kind="synchronisation" x="-680" y="-221">r_still!</label>
			<label kind="assignment" x="-680" y="-204">t=0,
tUpd = 0,
V=0</label>
			<nail x="-629" y="-161"/>
			<nail x="-629" y="-161"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id93"/>
			<label kind="guard" x="-331" y="-178">active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-119" y="-161">stop_r_action?</label>
			<label kind="assignment" x="-331" y="-144">tUpd=0, t=0,
active_robot[id-1] = false</label>
			<nail x="-160" y="-144"/>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id95"/>
			<label kind="guard" x="-246" y="-331">V &gt;= v_max</label>
			<label kind="assignment" x="-238" y="-314">t+=T_poll,
tUpd=0,
V=v_max</label>
			<nail x="-161" y="-348"/>
		</transition>
		<transition>
			<source ref="id92"/>
			<target ref="id94"/>
			<label kind="guard" x="-620" y="-391">active_robot[id-1] == true</label>
			<label kind="synchronisation" x="-578" y="-374">start_r_action?</label>
			<label kind="assignment" x="-603" y="-348">t=0, tUpd=0,
plan_traj(), 
active_robot[id-1] = false</label>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id92"/>
			<label kind="assignment" x="-621" y="-484">initRobot()</label>
		</transition>
</template>
<template>
    <name>Battery</name>
    <parameter>int id, double Cstart</parameter>
    <declaration>clock C = 12.6, t, tUpd;

        // Discharge tresholds
        const int C_100 = 100;

        // Charge/Discharge Rate R:
        // R = 1/Tcycle * ln(100/0.01)
        const double R = 0.00102;
        const double cheatFactor = 10.0;

        // BatteryStatus Sharing parameters
        //int chargeCounter = 0;
        const int Tpoll = 1;
        double Cp;
        int dt = 0;

        const double a_0 = 1.23612015*10;
        const double a_1 = -3.05366882*pow(10, -4);
        const double a_2 = 2.46157427*pow(10, -8);
        const double a_3 = -8.33622587*pow(10, -13);

        void updateCharge(bool charging) {
        double increment;

        increment = 100 - internal_charge[id-1];

        if(charging) {
        internal_charge[id-1] = 100 - increment*exp(-R*(Tpoll));
        } else {
        internal_charge[id-1] = internal_charge[id-1]+Tpoll*(a_1+a_2*Tpoll+2*a_2*dt+a_3*pow(Tpoll,2)+3*a_3*pow(dt,
        2)+3*a_3*dt*Tpoll);
        //internal_charge[id-1] = 100 - increment*exp(R*(Tpoll));
        }

        dt+=Tpoll;
        }

        void initBattery() {
        t=0;

        if(Cstart==C_100) {
        Cp = 99.99;
        } else {
        Cp = Cstart;
        }
        C = Cp;
        batteryCharge[id-1] = Cp;
        internal_charge[id-1] = Cp;
        tUpd=0;
        }
    </declaration>
    <location id="id111" x="408" y="204">
        <name x="383" y="170">Init</name>
        <committed/>
    </location>
    <location id="id112" x="1063" y="204">
        <name x="1080" y="179">empty</name>
        <label kind="invariant" x="1080" y="196">C'==0</label>
        <label kind="exponentialrate" x="1080" y="162">1</label>
    </location>
    <location id="id113" x="689" y="204">
        <name x="697" y="179">discharging</name>
        <label kind="invariant" x="697" y="128">tUpd &lt;= Tpoll
            &amp;&amp; t'==1
            &amp;&amp; C' == a_1 + 2*a_2*t + 3*a_3*t*t
        </label>
    </location>
    <location id="id114" x="689" y="425">
        <name x="697" y="434">recharging</name>
        <label kind="invariant" x="697" y="451">C' == (100-Cp)*R*exp(-R*t)
            &amp;&amp; C &lt; C_100 &amp;&amp; t'==1
            &amp;&amp; tUpd &lt;= Tpoll
        </label>
    </location>
    <location id="id115" x="595" y="119">
        <committed/>
    </location>
    <location id="id116" x="595" y="519">
        <committed/>
    </location>
    <location id="id117" x="876" y="204">
        <committed/>
    </location>
    <init ref="id111"/>
    <transition>
        <source ref="id113"/>
        <target ref="id117"/>
        <label kind="guard" x="748" y="204">C&lt;=0</label>
        <label kind="assignment" x="706" y="221">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id116"/>
        <target ref="id114"/>
        <label kind="synchronisation" x="544" y="459">publish_m[0]!</label>
    </transition>
    <transition>
        <source ref="id114"/>
        <target ref="id116"/>
        <label kind="guard" x="621" y="519">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="621" y="536">tUpd=0,
            updateCharge(1)
        </label>
        <nail x="689" y="519"/>
    </transition>
    <transition>
        <source ref="id115"/>
        <target ref="id113"/>
        <label kind="synchronisation" x="536" y="153">publish_m[0]!</label>
    </transition>
    <transition>
        <source ref="id113"/>
        <target ref="id115"/>
        <label kind="guard" x="621" y="51">tUpd&gt;=Tpoll
            &amp;&amp; C&gt;0
        </label>
        <label kind="assignment" x="621" y="85">tUpd=0,
            updateCharge(0)
        </label>
        <nail x="689" y="119"/>
    </transition>
    <transition>
        <source ref="id111"/>
        <target ref="id113"/>
        <label kind="assignment" x="510" y="213">initBattery()</label>
    </transition>
    <transition>
        <source ref="id114"/>
        <target ref="id113"/>
        <label kind="guard" x="519" y="247">C&lt;C_100 &amp;&amp;
            tUpd&lt;Tpoll &amp;&amp;
            active_robot[id-1] == true
        </label>
        <label kind="synchronisation" x="519" y="298">stop_recharging?</label>
        <label kind="assignment" x="519" y="315">Cp=C, t=0, tUpd = 0,
            active_robot[id-1] = false
        </label>
    </transition>
    <transition>
        <source ref="id113"/>
        <target ref="id114"/>
        <label kind="guard" x="723" y="289">C&lt;C_100</label>
        <label kind="synchronisation" x="723" y="306">start_recharging[id]?</label>
        <label kind="assignment" x="723" y="323">Cp=C, t=0, tUpd = 0</label>
        <nail x="714" y="264"/>
        <nail x="714" y="374"/>
    </transition>
    <transition>
        <source ref="id112"/>
        <target ref="id112"/>
        <nail x="1080" y="247"/>
        <nail x="1105" y="230"/>
    </transition>
    <transition>
        <source ref="id117"/>
        <target ref="id112"/>
        <label kind="synchronisation" x="910" y="204">dead_battery!</label>
    </transition>
</template>
<template>
    <name>Orchestrator</name>
    <parameter>int id</parameter>
    <declaration>clock ROS;

double latency = 1.5;
double eps = 0.0;

void update_eps() {
    eps = random_normal(0.5, 0.05);
}

void complete_leader() {
    if(served[currH-1] &amp;&amp; currH&lt;H &amp;&amp; patterns[currH]==1)
    currH++;
}

void complete_recipient() {
    served[currH-1] = true;
    if(currH&lt;H)
        currH++;
}

//This function change the current robot to fulfill the current task. The new coR should reach the recharge station and recharge itself.
void exchange_robots(){
    int tmp;
    tmp = coR;
    coR = currR;
    currR = tmp;

    currOp[currR-1] = 1;
    currOp[coR-1] = 4;
}
    </declaration>
    <location id="id110" x="-1028" y="-1989">
        <committed/>
    </location>
    <location id="id111" x="-2711" y="-2218">
        <name x="-2779" y="-2235">o_init</name>
        <committed/>
    </location>
    <location id="id112" x="-1700" y="-2218">
        <name x="-1751" y="-2252">x_move</name>
        <label kind="invariant" x="-1776" y="-2218">ROS'==0</label>
    </location>
    <location id="id113" x="-2142" y="-2388">
        <name x="-2134" y="-2380">r_rech</name>
    </location>
    <location id="id114" x="-2312" y="-2218">
        <name x="-2337" y="-2252">r_start</name>
        <label kind="invariant" x="-2322" y="-2201">ROS &lt;= latency + eps</label>
    </location>
    <location id="id115" x="-1181" y="-2159">
        <name x="-1173" y="-2150">o_scs</name>
        <label kind="invariant" x="-1173" y="-2133">ROS'==0</label>
        <label kind="exponentialrate" x="-1139" y="-2176">1</label>
    </location>
    <location id="id116" x="-1181" y="-2278">
        <name x="-1173" y="-2269">o_fail_2</name>
        <label kind="invariant" x="-1173" y="-2252">ROS'==0</label>
        <label kind="exponentialrate" x="-1139" y="-2295">1</label>
    </location>
    <location id="id117" x="-1258" y="-2388">
        <name x="-1351" y="-2379">to_2nd_task</name>
        <committed/>
    </location>
    <location id="id118" x="-1666" y="-2387">
        <name x="-1657" y="-2379">starting_2</name>
        <committed/>
    </location>
    <location id="id119" x="-2303" y="-2388">
        <name x="-2295" y="-2380">stopping_2</name>
        <committed/>
    </location>
    <location id="id120" x="-2108" y="-2218">
        <name x="-2167" y="-2210">h_start</name>
        <committed/>
    </location>
    <location id="id121" x="-1572" y="-2218">
        <name x="-1582" y="-2252">x_stop</name>
        <label kind="invariant" x="-1581" y="-2269">ROS &lt;= latency + eps</label>
    </location>
    <location id="id122" x="-1258" y="-2219">
        <name x="-1241" y="-2235">stopping</name>
        <label kind="invariant" x="-1241" y="-2218">ROS'==0</label>
        <label kind="exponentialrate" x="-1275" y="-2210">1</label>
    </location>
    <location id="id123" x="-1853" y="-2218">
        <name x="-1844" y="-2210">starting</name>
        <committed/>
    </location>
    <location id="id124" x="-1377" y="-2142">
        <name x="-1394" y="-2176">h_stop</name>
        <committed/>
    </location>
    <location id="id125" x="-1666" y="-2456">
        <name x="-1657" y="-2448">delivering</name>
        <committed/>
    </location>
    <location id="id126" x="-2431" y="-2218">
        <name x="-2473" y="-2227">idle</name>
        <label kind="invariant" x="-2507" y="-2244">ROS'==0</label>
        <label kind="exponentialrate" x="-2441" y="-2184">1</label>
    </location>
    <location id="id127" x="-2431" y="-2116">
        <name x="-2507" y="-2082">o_fail_1</name>
        <label kind="invariant" x="-2507" y="-2099">ROS'==0</label>
        <label kind="exponentialrate" x="-2456" y="-2133">1</label>
    </location>
    <location id="id128" x="-2218" y="-2218">
        <committed/>
    </location>
    <location id="id129" x="-1802" y="-2218">
        <committed/>
    </location>
    <location id="id130" x="-1419" y="-2218">
        <committed/>
    </location>
    <location id="id131" x="-2431" y="-2388">
        <committed/>
    </location>
    <location id="id132" x="-1870" y="-2388">
        <committed/>
    </location>
    <location id="id133" x="-2609" y="-2218">
        <committed/>
    </location>
    <location id="id134" x="-2669" y="-2167">
        <committed/>
    </location>
    <location id="id135" x="-2550" y="-2167">
        <committed/>
    </location>
    <location id="id136" x="-2354" y="-1989">
        <name x="-2337" y="-2014">r_synch</name>
        <label kind="invariant" x="-2516" y="-1997">ROS &lt;= latency + eps</label>
    </location>
    <location id="id137" x="-2133" y="-1989">
        <committed/>
    </location>
    <location id="id138" x="-1946" y="-1989">
        <name x="-1956" y="-2023">r1</name>
        <label kind="invariant" x="-2023" y="-2014">ROS'==0</label>
    </location>
    <location id="id139" x="-1768" y="-1989">
        <name x="-1778" y="-2023">r2</name>
        <label kind="invariant" x="-1751" y="-2014">ROS &lt;= latency + eps</label>
    </location>
    <location id="id140" x="-1428" y="-1989">
        <name x="-1436" y="-2023">stopping_coR</name>
        <label kind="invariant" x="-1521" y="-2014">ROS'==0</label>
        <label kind="exponentialrate" x="-1428" y="-1997">1</label>
    </location>
    <location id="id141" x="-1564" y="-1989">
        <committed/>
    </location>
    <location id="id142" x="-1428" y="-1912">
        <name x="-1504" y="-1938">o_fail_3</name>
        <label kind="invariant" x="-1521" y="-1921">ROS'==0</label>
        <label kind="exponentialrate" x="-1428" y="-1921">1</label>
    </location>
    <location id="id143" x="-1207" y="-1989">
        <committed/>
    </location>
    <location id="id144" x="-1504" y="-2142">
        <committed/>
    </location>
    <init ref="id111"/>
    <transition>
        <source ref="id144"/>
        <target ref="id124"/>
        <label kind="synchronisation" x="-1487" y="-2142">stop_r_action!</label>
    </transition>
    <transition>
        <source ref="id113"/>
        <target ref="id119"/>
        <label kind="guard" x="-2269" y="-2422">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2244" y="-2456">opchk_scs?</label>
        <label kind="assignment" x="-2269" y="-2405">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id110"/>
        <target ref="id126"/>
        <label kind="synchronisation" x="-1708" y="-2091">opchk_start!</label>
        <label kind="assignment" x="-1691" y="-2065">ROS=0</label>
        <nail x="-1028" y="-2065"/>
        <nail x="-2303" y="-2074"/>
    </transition>
    <transition>
        <source ref="id143"/>
        <target ref="id110"/>
        <label kind="assignment" x="-1189" y="-1989">exchange_robots(),
            active_robot[id-1] = true
        </label>
    </transition>
    <transition>
        <source ref="id140"/>
        <target ref="id143"/>
        <label kind="guard" x="-1377" y="-1972">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1334" y="-1989">r_still?</label>
        <label kind="assignment" x="-1377" y="-1955">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id142"/>
        <target ref="id142"/>
        <nail x="-1436" y="-1904"/>
        <nail x="-1436" y="-1887"/>
        <nail x="-1419" y="-1878"/>
        <nail x="-1402" y="-1895"/>
    </transition>
    <transition>
        <source ref="id140"/>
        <target ref="id142"/>
        <label kind="guard" x="-1419" y="-1963">fail</label>
        <label kind="synchronisation" x="-1419" y="-1946">r_still?</label>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id136"/>
        <label kind="guard" x="-2363" y="-2040">synch &amp;&amp; coR == id</label>
        <label kind="synchronisation" x="-2363" y="-2057">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id133"/>
        <target ref="id135"/>
        <label kind="assignment" x="-2652" y="-2150">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id111"/>
        <target ref="id134"/>
        <label kind="assignment" x="-2864" y="-2193">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id135"/>
        <target ref="id126"/>
        <label kind="assignment" x="-2532" y="-2192">ROS=0</label>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id133"/>
        <label kind="synchronisation" x="-2677" y="-2261">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id118"/>
        <target ref="id132"/>
        <label kind="assignment" x="-1853" y="-2431">currOp[id-1]=3,
            active_robot[id-1] = true
        </label>
    </transition>
    <transition>
        <source ref="id119"/>
        <target ref="id131"/>
        <label kind="assignment" x="-2448" y="-2439">currOp[id-1]=1,
            active_robot[id-1] = true
        </label>
    </transition>
    <transition>
        <source ref="id121"/>
        <target ref="id130"/>
        <label kind="guard" x="-1530" y="-2261">!stopHuman &amp;&amp;
            ROS &gt;= latency + eps
        </label>
        <label kind="assignment" x="-1547" y="-2218">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id123"/>
        <target ref="id129"/>
        <label kind="assignment" x="-1921" y="-2269">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id114"/>
        <target ref="id128"/>
        <label kind="guard" x="-2269" y="-2295">ROS &gt;= latency + eps
            &amp;&amp; !exeRobot
        </label>
        <label kind="assignment" x="-2269" y="-2244">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id111"/>
        <label kind="guard" x="-2167" y="-2609">currOp[id-1]==6 || currOp[id-1] == 7</label>
        <label kind="assignment" x="-2091" y="-2592">currOp[id-1]=1</label>
        <nail x="-1258" y="-2235"/>
        <nail x="-1258" y="-2575"/>
        <nail x="-2711" y="-2575"/>
    </transition>
    <transition>
        <source ref="id114"/>
        <target ref="id120"/>
        <label kind="guard" x="-2244" y="-2176">ROS &gt;= latency + eps
            &amp;&amp; exeRobot
        </label>
        <nail x="-2218" y="-2159"/>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id115"/>
        <label kind="synchronisation" x="-2133" y="-2125">opchk_scs?</label>
        <nail x="-2371" y="-2108"/>
        <nail x="-1181" y="-2108"/>
    </transition>
    <transition>
        <source ref="id127"/>
        <target ref="id127"/>
        <nail x="-2431" y="-2056"/>
        <nail x="-2405" y="-2056"/>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id127"/>
        <label kind="synchronisation" x="-2516" y="-2176">opchk_fail?</label>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id114"/>
        <label kind="guard" x="-2456" y="-2261">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2414" y="-2244">opchk_stop?</label>
        <label kind="assignment" x="-2397" y="-2210">ROS = 0,
            update_eps(),
            active_robot[id-1] = false
        </label>
    </transition>
    <transition>
        <source ref="id125"/>
        <target ref="id111"/>
        <label kind="synchronisation" x="-2040" y="-2507">stop_h_action!</label>
        <label kind="assignment" x="-2040" y="-2490">currOp[id-1]=1,
            complete_recipient()
        </label>
        <nail x="-2711" y="-2456"/>
    </transition>
    <transition>
        <source ref="id117"/>
        <target ref="id125"/>
        <label kind="guard" x="-1632" y="-2490">currOp[id-1]==4 &amp;&amp; patterns[currH-1]==2</label>
        <label kind="synchronisation" x="-1632" y="-2473">start_h_action!</label>
        <nail x="-1258" y="-2456"/>
    </transition>
    <transition>
        <source ref="id120"/>
        <target ref="id123"/>
        <label kind="guard" x="-2048" y="-2193">!startHuman</label>
        <nail x="-1989" y="-2192"/>
    </transition>
    <transition>
        <source ref="id124"/>
        <target ref="id122"/>
        <label kind="synchronisation" x="-1360" y="-2159">stop_h_action!</label>
        <nail x="-1258" y="-2142"/>
    </transition>
    <transition>
        <source ref="id121"/>
        <target ref="id144"/>
        <label kind="guard" x="-1564" y="-2201">stopHuman &amp;&amp;
            ROS &gt;= latency + eps
        </label>
        <label kind="assignment" x="-1564" y="-2167">active_robot[id-1] = true</label>
        <nail x="-1572" y="-2142"/>
    </transition>
    <transition>
        <source ref="id129"/>
        <target ref="id112"/>
        <label kind="synchronisation" x="-1793" y="-2235">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id120"/>
        <target ref="id123"/>
        <label kind="guard" x="-2048" y="-2252">startHuman</label>
        <label kind="synchronisation" x="-2048" y="-2235">start_h_action!</label>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id117"/>
        <label kind="guard" x="-1224" y="-2414">stop [id-1]&amp;&amp; (currOp[id-1]==2 ||
            (currOp[id-1]==4 &amp;&amp;
            patterns[currH-1]==2)) &amp;&amp;
            active_robot[id-1] == true
        </label>
        <label kind="synchronisation" x="-1224" y="-2431">r_still?</label>
        <label kind="assignment" x="-1224" y="-2346">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id115"/>
        <label kind="guard" x="-1232" y="-2159">scs</label>
        <nail x="-1232" y="-2159"/>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id116"/>
        <label kind="guard" x="-1232" y="-2295">fail</label>
        <nail x="-1232" y="-2278"/>
    </transition>
    <transition>
        <source ref="id112"/>
        <target ref="id121"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1674" y="-2286">opchk_scs?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
            update_eps(),
            active_robot[id-1] = false
        </label>
        <nail x="-1640" y="-2227"/>
    </transition>
    <transition>
        <source ref="id112"/>
        <target ref="id121"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1674" y="-2269">opchk_fail?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
            update_eps(),
            active_robot[id-1] = false
        </label>
        <nail x="-1640" y="-2235"/>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id111"/>
        <label kind="guard" x="-2065" y="-2354">stop[id-1] &amp;&amp; !(currOp[id-1]==2 ||
            (currOp[id-1]==4 &amp;&amp;
            patterns[currH-1]==2)) &amp;&amp;
            active_robot[id-1] == true
        </label>
        <label kind="synchronisation" x="-2244" y="-2363">r_still?</label>
        <label kind="assignment" x="-2252" y="-2346">currOp[id-1]=1,
            complete_leader(),
            active_robot[id-1] = -1
        </label>
        <nail x="-1258" y="-2303"/>
        <nail x="-2711" y="-2303"/>
    </transition>
    <transition>
        <source ref="id130"/>
        <target ref="id122"/>
        <label kind="synchronisation" x="-1394" y="-2235">stop_r_action!</label>
    </transition>
    <transition>
        <source ref="id112"/>
        <target ref="id121"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1683" y="-2252">opchk_stop?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
            update_eps(),
            active_robot[id-1] = false
        </label>
        <nail x="-1640" y="-2218"/>
    </transition>
    <transition>
        <source ref="id128"/>
        <target ref="id120"/>
        <label kind="synchronisation" x="-2269" y="-2261">start_r_action!</label>
    </transition>
    <transition>
        <source ref="id131"/>
        <target ref="id111"/>
        <label kind="synchronisation" x="-2609" y="-2414">stop_recharging!</label>
        <nail x="-2711" y="-2388"/>
    </transition>
    <transition>
        <source ref="id113"/>
        <target ref="id119"/>
        <label kind="guard" x="-2269" y="-2422">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2244" y="-2439">opchk_stop?</label>
        <label kind="assignment" x="-2269" y="-2405">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id132"/>
        <target ref="id113"/>
        <label kind="synchronisation" x="-2006" y="-2414">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id117"/>
        <target ref="id118"/>
        <label kind="guard" x="-1632" y="-2422">currOp[id-1]==2</label>
        <label kind="synchronisation" x="-1632" y="-2405">start_recharging[id]!</label>
    </transition>
    <transition>
        <source ref="id115"/>
        <target ref="id115"/>
        <nail x="-1122" y="-2159"/>
        <nail x="-1122" y="-2184"/>
    </transition>
    <transition>
        <source ref="id116"/>
        <target ref="id116"/>
        <nail x="-1122" y="-2303"/>
        <nail x="-1122" y="-2278"/>
    </transition>
    <transition>
        <source ref="id137"/>
        <target ref="id138"/>
        <label kind="synchronisation" x="-2116" y="-1989">start_r_action!</label>
    </transition>
    <transition>
        <source ref="id136"/>
        <target ref="id137"/>
        <label kind="guard" x="-2329" y="-1980">ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-2329" y="-1963">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id139"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1912" y="-1963">opchk_scs?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
            update_eps()
        </label>
        <nail x="-1870" y="-1997"/>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id139"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1912" y="-1946">opchk_fail?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
            update_eps()
        </label>
        <nail x="-1870" y="-2006"/>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id139"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1921" y="-1929">opchk_stop?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
            update_eps()
        </label>
        <nail x="-1870" y="-1989"/>
    </transition>
    <transition>
        <source ref="id139"/>
        <target ref="id141"/>
        <label kind="guard" x="-1734" y="-1989">ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-1734" y="-1972">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id141"/>
        <target ref="id140"/>
        <label kind="synchronisation" x="-1547" y="-1989">stop_r_action!</label>
    </transition>
</template>
<template>
    <name>OpChk</name>
    <parameter>int id, int T_int, int T_proc</parameter>
    <declaration>clock t_act;


//Human-Robot Distance Parameters
const double stopDistance = 4.0;
const double restartDistance = 3.0;
int recipientStages = 0;

//Recharging Policy Parameters
const double rechargingTh = 11.1;
const double stopRechargingTh = 11.4;
const double failBattery = 11.0;

//Fatigue-Monitoring Parameters
const double failFatigue = 0.97;
const double stopFatigue = 0.6;
const double resumeFatigue = 0.3;


/**
* Init
**/

void initialize() {
    if (currR == id) stop[currR-1] = false;
    else if (coR == id) stop[coR-1] = false;
    exeRobot=false;
    stopHuman= false;
    startHuman=false;
}

/**
* Pattern-Specific Logics
**/

bool getStart(int pattern) {
    double humanRobotDist = calculateDistance();
    double dist_to_dest = pt_dist(robPositionX[currR-1], dX[currR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 100.0*1.2;

    if(pattern==0) //start cond. for follower
        //if (humanRobotDist&gt;=stopDistance) { //if human and robot are too distant
        return batteryCharge[id-1]&gt;=rechargingTh; //starts if battery is sufficient
    /*
    } else
    return batteryCharge[id-1]&gt;=rechargingTh &amp;&amp; //starts if battery is sufficient,
    ((!stopHuman &amp;&amp; humanRobotDist&lt;=restartDistance) || //if human and robot are close again,
    (stopHuman &amp;&amp; humanFatigue[currH-1]&lt;=resumeFatigue)); //or if human has rested enough
    */
    else if(pattern==1) // start cond. for leader
        return hExe; //starts if human has started
    else if(pattern==2) // start cond. for recipient
        return batteryCharge[id-1]&gt;=rechargingTh; // starts if battery is sufficient
    else if(pattern==3)
        return batteryCharge[id-1]&gt;rechargingTh &amp;&amp;
    (pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]) &lt;= dist &amp;&amp;
    pt_dist(humanPositionX[currH-1], destX[currH-1], humanPositionY[currH-1], destY[currH-1]) &lt;= dist ||
                                                                                                    pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]) &gt; dist) ;
    else if(pattern == 10)// start cond. for interdependence by contract
        return batteryCharge[id-1]&gt;=rechargingTh;//start if battery is sufficient
    else if(pattern == 12) // start cond. for competition
        return batteryCharge[id-1]&gt;=rechargingTh;
    else
    return false;
}

double humanRobotDist;
void setOpParams(int pattern) {
    humanRobotDist = calculateDistance();
    exeRobot= false;
    // operational parameters (destination for robot, and op. state)
    if (pattern==0) { //follower
        currOp[currR-1] = 4;
        if (humanRobotDist&lt;=stopDistance) { //if human and robot are close,
            dX[currR-1] = destX[currH-1]; // move towards destination
            dY[currR-1] = destY[currH-1];
        } else { // !! ONLINE RECONFIGURATION FEATURE !!
            dX[currR-1] = humanPositionX[currH-1]; //if human and robot are distant,
            dY[currR-1] = humanPositionY[currH-1]; //move towards human
        }
    } else if (pattern==1) { //leader
        currOp[currR-1] = 5;
        dX[currR-1] = humanPositionX[currH-1]; // follow human
        dY[currR-1] = humanPositionY[currH-1];
    } else if (pattern==2) { //recipient
        currOp[currR-1] = 4;
        recipientStages = 1;
        dX[currR-1] = destX[currH-1]; // move towards object location
        dY[currR-1] = destY[currH-1];
    } else if (pattern==3){
        double dist_to_dest = pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]);
        if (dist_to_dest &gt; 50.0) {
            currOp[id-1]=4;
            dX[currR-1] = destX[currH-1];
            dY[currR-1] = destY[currH-1];
        }
        else {
            currOp[currR-1]=6;
            exeRobot=true;
        }
    } else if(pattern==10) { // interdependence by contract
        currOp[currR-1] = 4;
        //The robot shouldn't move ==&gt; set dest to initial position of robot
        dX[currR-1] = destX[currH-1];
        dY[currR-1] = destY[currH-1];
    } else if(pattern==12) { // competition
        currOp[currR-1] = 4;
        dX[currR-1] = destX[currH-1]; // move towards object location
        dY[currR-1] = destY[currH-1];
    }
}

bool getStop(int pattern) {
    double humanRobotDist = pt_dist(robPositionX[currR-1], humanPositionX[currH-1], robPositionY[currR-1],
                                    humanPositionY[currH-1])/100;
    double dist_to_dest = pt_dist(robPositionX[currR-1], dX[currR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 100.0*1.1;

    if(pattern==0) { // stop cond. for follower
        if(dX[currR-1]==destX[currH-1] &amp;&amp; dY[currR-1]==destY[currH-1]) { //if currently moving towards destination
            stopHuman = humanFatigue[currH-1]&gt;=stopFatigue; //stop human if too fatigued
            // stop robot if close to destination, human is too tired or too distant
            return dist_to_dest&lt;=dist || stopHuman || humanRobotDist&gt;=stopDistance;
        } else
        return humanRobotDist&lt;=restartDistance || (dX[currR-1] == rechargeStation[0] &amp;&amp; dY[currR-1] ==
                                                                                                   rechargeStation[1] &amp;&amp; dist_to_dest&lt;=dist); // else stop if close to human or recharge station
    } else if (pattern==1) // stop cond. for leader
        return dist_to_dest&lt;=dist || (!hExe &amp;&amp; dist_to_dest&lt;=dist); // stop if human has stopped
    else if (pattern==2 || pattern==3){ // stop cond. for recipient
        return dist_to_dest&lt;=dist; // stop if close to destination
    } else if (pattern==10)// interdependence by contract
        return !hExe;
    else if (pattern==12) // competition
        return dist_to_dest&lt;=dist;
    else
    return false;
}

/**
* Operating Mode Checks
**/

void check_r_rech(){
    if(batteryCharge[currR-1]&gt;=stopRechargingTh) //if recharging, stop when recharged
    stop[currR-1] = true;
}

void check_fail(){
    // mission fails if battery gets to 0, or human passes out
    if(batteryCharge[id-1]&lt;=failBattery ||
                               humanFatigue[currH-1]&gt;=failFatigue) {
        fail = true;
        currOp[currR-1] = 0;
    }
}

void check_scs(){
    // mission is accomplished if all humans are served
    if(served[H-1]) {
        scs = true;
        currOp[currR-1] = 0;
    }
}

void check_h_move(){
    stop[currR-1] = getStop(patterns[currH-1]);

    if(!stop[currR-1]) {
        dX[currR-1] = humanPositionX[currH-1];
        dY[currR-1] = humanPositionY[currH-1];
    }
}

void check_r_move(){
    // stop moving if battery is low and start task handover
    if(currOp[currR-1]==4 &amp;&amp; batteryCharge[currR-1]&lt;=rechargingTh) {
        stop[currR-1] = true;
        if (patterns[currH-1]==3 || patterns[currH-1]==0) stopHuman=true;
        return;
    }

    stop[currR-1] = getStop(patterns[currH-1]);

    // if human is a recipient, and robot has arrived to
    // its current destination
    if(patterns[currH-1]==2 &amp;&amp; stop[currR-1]) {
        // if it is the first stage, move on to the second one
        // and reach the human
        if(recipientStages==1) {
            stop[currR-1] = false;
            stopHuman = false;
            dX[currR-1] = humanPositionX[currH-1];
            dY[currR-1] = humanPositionY[currH-1];
            recipientStages++;
        }
    }
}

int select_coR() {
    int i, closest= -1;
    double dist, min_dist = 100000.0;
    if(R&gt;=2) {
        for(i=0; i &lt; R; i++) {
            dist = pt_dist(robPositionX[currR-1], robPositionX[i], robPositionY[currR-1], robPositionY[i]);
            if(dist &lt; min_dist &amp;&amp; i != (currR-1) &amp;&amp; !busy[i]) {
                min_dist = dist;
                closest = i;
            }
        }
        return closest+1;
    } else return closest;
}

bool start;
void check_start(){
    int tmp, coR_choice;
    bool isCoRobotAvailable;

    // if battery charge is low, move to rech. mode
    if(batteryCharge[currR-1]&lt;=rechargingTh) {
        dX[currR-1] = rechargeStation[0];
        dY[currR-1] = rechargeStation[1];
        coR_choice = select_coR();
        isCoRobotAvailable = coR_choice &gt; 0;
        if (isCoRobotAvailable){
            currOp[currR-1] = 7;
            coR = coR_choice;
            //if (currR == 1) coR = 2;
            //else coR = 1;
            currOp[coR-1] = 7;
            dX[coR-1] = robPositionX[currR-1];
            dY[coR-1] = robPositionY[currR-1];
            active_robot[coR-1] = true;
            synch = true;
        }
        else{
            currOp[currR-1] = 2;
            stop[currR-1] = true;
        }
        return;
    }

    start = getStart(patterns[currH-1]);
    if(start) {
        setOpParams(patterns[currH-1]);
        // human can start if it is a follower, rob is not recharging
        // and everybody is moving towards the destination (i.e., robot is not going back towards the human)
        // note: the leader does not need this boolean, because it does not "wait" for start_h_action to fire
        startHuman = (currOp[currR-1]==4 &amp;&amp; patterns[currH-1]!=2 &amp;&amp; patterns[currH-1]!=3 &amp;&amp;
        dX[currR-1]==destX[currH-1] &amp;&amp; dY[currR-1]==destY[currH-1]) || currOp[currR-1]==6;
        stop[currR-1] = true;
    }
}

void check_hr_mission(){
    if (served[currH-1]){
        stop[currR-1] = true;
        stopHuman=false;
        return;
    }
    if (batteryCharge[id-1]&lt;=rechargingTh){
        stop[currR-1]=true;
        stopHuman=true;
        return;
    }
    if (!hExe) {
        stop[currR-1]=true;
    }

}

void check_service_provided() {
    double eps = 100.0, dist_to_dest, humanRobotDist;

    dist_to_dest = pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]);
    humanRobotDist = calculateDistance();

    if(patterns[currH-1]==0
       &amp;&amp; dist_to_dest &lt;= eps
                                     &amp;&amp; humanRobotDist &lt;= eps/100*2) { // if follower is close to robot and both are close to destination
        served[currH-1] = true;
        stopHuman = true;
        if(currH&lt;H &amp;&amp; patterns[currH]!=1)
        currH++;
    }
    else if((patterns[currH-1]==1 || patterns[currH-1]==3 || patterns[currH-1]==12) &amp;&amp; served[currH-1]) // if leader has set themselves as served
        currH++;
    else if(patterns[currH-1]==10 &amp;&amp; task_size &lt;= task_completion){
        served[currH-1] = true;
        stopHuman = true;
        if(currH&lt;H &amp;&amp; patterns[currH]!=1)
        currH++;
    }
}

/***********coR functions**************/

void check_r_move_coR(){
    //check if the coR has reached the recharging station
    double dist_to_dest = pt_dist(robPositionX[coR-1], dX[coR-1], robPositionY[coR-1], dY[coR-1]);
    double dist = 150.0;
    stop[coR-1] = dist_to_dest &lt;= dist;

}

void check_r_rech_coR(){
    if(batteryCharge[coR-1]&gt;=stopRechargingTh) //if recharging, stop when recharged
    stop[coR-1] = true;
}

void needs_recharging_coR(){
    stop[coR-1] = true;
    currOp[coR-1] = 2;
    dX[coR-1] = rechargeStation[0];
    dY[coR-1] = rechargeStation[1];
}


void check_r_sync(){
    double dist_to_dest = pt_dist(robPositionX[coR-1], dX[coR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 150.0;
    if (dist_to_dest &lt;= dist) {
        synch = false;
        stop[coR-1] = true;
    }
}


void check_actions() {

    if (currR == id) {
        check_scs();
        if( scs )
            return;

        check_fail();
        if( fail )
            return;

        if( currOp[currR-1]==1 ) // system idle, waiting for an action to start
            check_start();
        else if( currOp[currR-1]==2 || currOp[currR-1]==4 ) // robot moving to rech. station (currOp=2), or leading (currOp=4)
            check_r_move();
        else if( currOp[currR-1]==3 ) // robot recharging
            check_r_rech();
        else if( currOp[currR-1]==5 ) // robot following
            check_h_move();
        else if ( currOp[currR-1]==6 )
            check_hr_mission();
        else if ( currOp[currR-1]==7 )
            /*waiting co-robot synchronization*/;

        check_service_provided();
    }
    else if (coR == id){
        if( currOp[currR-1]==1 ) // system idle, waiting for an eventual synchronization with the current robot
            /*nothing*/;
        else if ( currOp[coR-1]==2 ) // co-robot moving to rech. station
            check_r_move_coR();
        else if ( currOp[coR-1]==3 ) // co-robot recharging
            check_r_rech_coR();
        else if ( currOp[coR-1]==4 )
            needs_recharging_coR();
        else if ( currOp[coR-1]==7 ) //// co-robot reaching current robot
            check_r_sync();
    }
}
    </declaration>
    <location id="id145" x="-663" y="-366">
        <name x="-705" y="-399">op</name>
        <label kind="invariant" x="-773" y="-374">t_act&lt;=T_int</label>
    </location>
    <location id="id146" x="-238" y="-366">
        <name x="-221" y="-391">chk</name>
        <label kind="invariant" x="-221" y="-365">t_act&lt;=T_proc</label>
    </location>
    <location id="id147" x="-442" y="-527">
        <name x="-452" y="-561">off</name>
    </location>
    <location id="id148" x="-451" y="-222">
        <committed/>
    </location>
    <location id="id149" x="-238" y="-459">
        <committed/>
    </location>
    <location id="id150" x="-136" y="-459">
        <committed/>
    </location>
    <init ref="id147"/>
    <transition>
        <source ref="id150"/>
        <target ref="id147"/>
        <label kind="synchronisation" x="-195" y="-518">opchk_scs!</label>
        <nail x="-144" y="-467"/>
        <nail x="-238" y="-527"/>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id150"/>
        <label kind="guard" x="-127" y="-450">!stop[id-1] &amp;&amp; scs
            &amp;&amp; t_act&gt;=T_proc
        </label>
        <label kind="assignment" x="-127" y="-416">active_robot[id-1] = true</label>
        <nail x="-136" y="-365"/>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id149"/>
        <label kind="guard" x="-382" y="-459">stop[id-1] &amp;&amp; !scs
            &amp;&amp; t_act&gt;=T_proc
        </label>
        <label kind="assignment" x="-382" y="-425">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id148"/>
        <target ref="id147"/>
        <label kind="synchronisation" x="-26" y="-552">opchk_fail!</label>
        <label kind="comments" x="-433" y="-200">active_robot[id-1] is not set true because the synch messagge
            opchk_fail is not received by anyone
        </label>
        <nail x="59" y="-229"/>
        <nail x="59" y="-527"/>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id148"/>
        <label kind="guard" x="-229" y="-323">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-229" y="-306">pass_out?</label>
        <label kind="assignment" x="-238" y="-246">active_robot[id-1] = false</label>
        <nail x="-238" y="-263"/>
    </transition>
    <transition>
        <source ref="id145"/>
        <target ref="id148"/>
        <label kind="guard" x="-841" y="-340">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-841" y="-323">pass_out?</label>
        <label kind="assignment" x="-841" y="-246">active_robot[id-1] = false</label>
        <nail x="-663" y="-263"/>
    </transition>
    <transition>
        <source ref="id149"/>
        <target ref="id147"/>
        <label kind="synchronisation" x="-331" y="-501">opchk_stop!</label>
        <nail x="-238" y="-527"/>
    </transition>
    <transition>
        <source ref="id147"/>
        <target ref="id145"/>
        <label kind="guard" x="-748" y="-578">active_robot[id-1] == true &amp;&amp;
            (currR == id || coR == id)
        </label>
        <label kind="synchronisation" x="-697" y="-544">opchk_start?</label>
        <label kind="assignment" x="-748" y="-527">initialize(), t_act=0,
            active_robot[id-1] = false
        </label>
        <nail x="-663" y="-527"/>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id148"/>
        <label kind="guard" x="-238" y="-280">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-238" y="-263">dead_battery?</label>
        <label kind="assignment" x="-238" y="-246">active_robot[id-1] = false</label>
        <nail x="-306" y="-263"/>
    </transition>
    <transition>
        <source ref="id145"/>
        <target ref="id148"/>
        <label kind="guard" x="-841" y="-297">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-841" y="-280">dead_battery?</label>
        <label kind="assignment" x="-841" y="-246">active_robot[id-1] = false</label>
        <nail x="-620" y="-272"/>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id145"/>
        <label kind="guard" x="-518" y="-323">!stop[id-1] &amp;&amp; !scs
            &amp;&amp; t_act&gt;=T_proc
        </label>
        <label kind="assignment" x="-476" y="-289">t_act=0</label>
        <nail x="-450" y="-323"/>
    </transition>
    <transition>
        <source ref="id145"/>
        <target ref="id146"/>
        <label kind="guard" x="-501" y="-408">t_act&gt;=T_int</label>
        <label kind="assignment" x="-501" y="-391">check_actions(), t_act=0</label>
    </transition>
</template>
<template>
	<name>ROS_SensPub</name>
	<parameter>int id, double l_avg, double l_dev</parameter>
	<declaration>
clock L;
double latency = 0.0;
int buff_pos = 0;
double buffer[MAX_BUFF_SIZE]; 
double buffer2[MAX_BUFF_SIZE]; 
int buffer3[MAX_BUFF_SIZE];
int cached_id;

void update_lat() {
    latency = random_normal(l_avg, l_dev);
}

void add_to_buffer() {
    cached_id = currH;
    if(id==0){
        buffer[buff_pos] = internal_charge[0];
        buffer3[buff_pos] = 0;
        if(R&gt;=2) {
            buff_pos++;
            buffer[buff_pos] = internal_charge[1];
            buffer3[buff_pos] = 1;
        }
    }
    else if(id==3) {
        buffer[buff_pos] = internalHumX[currH-1];
        buffer2[buff_pos] = internalHumY[currH-1];
        buffer3[buff_pos] = -1;
    }
    else if(id==4){
        buffer[buff_pos] = internalFatigue[currH-1];
        buffer3[buff_pos] = -1;
    }
    else {
        //update robot position (currR or coR)
        buffer[buff_pos] = internalRobX[id-1];
        buffer2[buff_pos] = internalRobY[id-1];
    }

    buff_pos += 1;
}

void shift_buffer(){
    int i;

    // Shift buffer
    for(i=0; i&lt;MAX_BUFF_SIZE-1 &amp;&amp; buffer[i+1] &gt; 0.0; i++) {
        buffer[i] = buffer[i+1];
        buffer2[i] = buffer2[i+1];
        buffer3[i] = buffer3[i+1];
    }

    buffer[i+1] = -1.0;
    buffer2[i+1] = -1.0;
    buffer3[i+1] = -1;
    
    buff_pos = buff_pos-1;
    if(buff_pos &lt; 0)
        buff_pos = 0;
}

void publish() {
    int i;

    // Publish
    if(id==0){
        batteryCharge[buffer3[0]] = buffer[0];
        shift_buffer();
        batteryCharge[buffer3[0]] = buffer[0];
    }
    else if(id==3) {
        if(cached_id==currH) {
            for(i=0; i&lt;H &amp;&amp; SAME_H_IDs[currH-1][i]!=-1; i++) {
                humanPositionX[SAME_H_IDs[currH-1][i]-1] = buffer[0];
                humanPositionY[SAME_H_IDs[currH-1][i]-1] = buffer2[0];
            }
        }
    }
    else if(id==4 &amp;&amp; cached_id==currH) {
        humanFatigue[currH-1] = buffer[0];
    }
    else if(id==1 || id ==2) {
        //update robot position (currR or coR)
        robPositionX[id-1] = buffer[0];
        robPositionY[id-1] = buffer2[0];
        /*shift_buffer();
        robPositionX[buffer3[0]] = buffer[0];
        robPositionY[buffer3[0]] = buffer2[0];*/
    }
    
    shift_buffer();
}

</declaration>
		<location id="id152" x="-34" y="-8">
			<name x="-42" y="8">idle</name>
			<label kind="invariant" x="-42" y="25">L'==0</label>
		</location>
		<location id="id153" x="-34" y="-195">
			<name x="-17" y="-204">sending</name>
			<label kind="invariant" x="-17" y="-187">L &lt;= latency</label>
		</location>
		<init ref="id152"/>
		<transition>
			<source ref="id153"/>
			<target ref="id153"/>
			<label kind="synchronisation" x="-8" y="-289">publish_m[id]?</label>
			<label kind="assignment" x="17" y="-272">add_to_buffer()</label>
			<nail x="-34" y="-280"/>
			<nail x="34" y="-246"/>
		</transition>
		<transition>
			<source ref="id153"/>
			<target ref="id153"/>
			<label kind="guard" x="-153" y="-314">L&gt;=latency 
&amp;&amp; buff_pos&gt;1</label>
			<label kind="assignment" x="-178" y="-280">publish(), 
update_lat(),
L=0</label>
			<nail x="-34" y="-280"/>
			<nail x="-102" y="-238"/>
		</transition>
		<transition>
			<source ref="id153"/>
			<target ref="id152"/>
			<label kind="guard" x="-204" y="-144">L&gt;=latency 
&amp;&amp; buff_pos&lt;=1</label>
			<label kind="assignment" x="-153" y="-93">publish()</label>
			<nail x="-93" y="-102"/>
		</transition>
		<transition>
			<source ref="id152"/>
			<target ref="id153"/>
			<label kind="synchronisation" x="34" y="-127">publish_m[id]?</label>
			<label kind="assignment" x="34" y="-110">add_to_buffer(),
L=0, update_lat()</label>
			<nail x="34" y="-102"/>
		</transition>
</template>
	<system>
// Robot Instances
r_1 = Robot(1, 100, 100, 300.00, 300.00);
b_r_1 = Battery(1, 11.15);
r_pub_1 = ROS_SensPub(1, 0.5, 0.01);
r_2 = Robot(2, 100, 100, 300.00, 300.00);
b_r_2 = Battery(2, 11.15);
r_pub_2 = ROS_SensPub(2, 0.5, 0.01);
c_pub = ROS_SensPub(0, 0.5, 0.01);

//

// Controller Instances (one for each robot)
o_1 = Orchestrator(1);
opchk_1 = OpChk(1, 1, 0);
o_2 = Orchestrator(2);
opchk_2 = OpChk(2, 1, 0);

//

/**
* MISSION DEFINITION
**/

// Human Instances
// -&gt; DEFINE HUMAN PATTERNS
h1_a = Human_Follower(1, 80, 2, -1, -1, -1);
h2 = Human_Competitor(2, 100, 3, -1, -1);
h3_a_alt1 = Human_Rescuer(3, 100, 3, -1, 10, 1);
h3a_b_alt1 = Human_Recipient(4, 100, 3, -1, 1);
h3_a_alt2 = Human_Leader(5, 100, 3, -1, -1, 2);
h3_b_alt2 = Human_Leader(6, 100, 3, -1, 3, 2);
h1_b = Human_Follower(7, 80, 2, -1, 1, -1);
h3_c = Human_Applicant(8, 100, 3, -1, 1, -1);
h_pub_pos = ROS_SensPub(3, 0.5, 0.01);
h_pub_ftg = ROS_SensPub(4, 0.5, 0.01);

//

system 
h1_a,
h2,
h3_a_alt1,
h3a_b_alt1,
h3_a_alt2,
h3_b_alt2,
h1_b,
h3_c,
r_1,
r_2,
b_r_1,
b_r_2,
r_pub_1,
r_pub_2,
o_1,
o_2,
opchk_1,
opchk_2,
c_pub,
h_pub_pos,
h_pub_ftg
;
</system>
<queries>
</queries>
</nta>
