<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Place global declarations here.
// Human Channels
broadcast chan start_h_action, stop_h_action, h_fail;

// Robot Channels
broadcast chan start_r_action, stop_r_action, r_still;

// Battery Channels
broadcast chan start_recharging[int], stop_recharging, dead_battery;

// Orchestrator Channels
broadcast chan opchk_start, opchk_stop, opchk_scs, opchk_fail;
broadcast chan publish_m[int];

/**
*** CONSTANTS
**/
const double PI = 3.1415926535;
const double INT16_MAX = 32767.0;


// Human Fatigue Profiles [fatiguing rate, recovery rate]
// MET = ln(1-epsilon)/(-lambda)
const double YOUNG_HEALTHY[2] = {0.0005, 0.0005}; // approx. 1380s

// Pre-Simulation

const double YOUNG_SICK[2] = {0.001865, 0.005117};
const double YOUNG_SICK_SIGMA[2] = {0.000719, 0.000001};

const double ELDERLY_HEALTHY[2] = {0.000409, 0.000450};
const double ELDERLY_HEALTHY_SIGMA[2] = {0.000091, 0.000119};

// Post-Simulation
/*
const double YOUNG_SICK[2] = {0.004538, 0.003328};
const double YOUNG_SICK_SIGMA[2] = {0.000469, 0.001342};

const double ELDERLY_HEALTHY[2] = {0.000553, 0.000302};
const double ELDERLY_HEALTHY_SIGMA[2] = {0.004548, 0.000175};
*/

//
const double ELDERLY_SICK[2] = {0.005, 0.004}; // approx. 350s
const double YOUNG_UNSTEADY[2] = {0.025, 0.001}; // approx. 280s
const double ELDERLY_UNSTEADY[2] = {0.035, 0.001};

const int F_max = 1;

/**
** ERRORS PARAMS
**/
const int Tpoll = 1;

const int H1_ERR = 0;
const int H2_ERR = 0;
const int H3_ERR = 7;
const int H4_ERR = 0;

// obey/disobey
const int DISABLED_WEIGHTS[2] = {100, 0};
const int HIGH_WEIGHTS[2] = {90, 10};
const int NORMAL_WEIGHTS[2] = {95, 5};
const int LOW_WEIGHTS[2] = {99, 1};

// free will
const int FW_max = 100;
const int DISABLED_FW = 101;
const int NORMAL_FW = 99;
const int HIGH_FW = 95;
const int LOW_FW = 100;

// timer expired
const int DISABLED_DELTA = 9999;
const int HIGH_DELTA = 200;
const int NORMAL_DELTA = 400;
const int LOW_DELTA = 800;

// safety distance
bool is_crit = false;
bool ignore_crit = false;
int collisions = 0;

const int DISABLED_LAMBDA = 9999;
const int HIGH_LAMBDA = 1;
const int NORMAL_LAMBDA = 10;
const int LOW_LAMBDA = 10000;

// critical status
const int FS = 1000;
const int DISABLED_CRIT = 0;
const int HIGH_CRIT = 2;
const int NORMAL_CRIT = 1;
const int LOW_CRIT = 0;

typedef struct {
    int obey, disobey;
    int FW_th;
    int delta_x100;
    int lambda_inv;
    int crit;
} ERR_PROF;

ERR_PROF get_error_params(int p) {
    ERR_PROF res = {LOW_WEIGHTS[0], LOW_WEIGHTS[1], LOW_FW, LOW_DELTA, LOW_LAMBDA, LOW_CRIT};

    if(p==1) { // busy professional
        res.FW_th = HIGH_FW;
        res.delta_x100 = HIGH_DELTA;
    }
    else if(p==2) { // free professional
        res.FW_th = LOW_FW;
        res.delta_x100 = LOW_DELTA;
    }
    else if(p==3) { // unexperienced professional
        res.lambda_inv = HIGH_LAMBDA;
    }
    else if(p==4) { // experienced professional
        res.lambda_inv = LOW_LAMBDA;
    }
    else if(p==5) { // critical patient
        res.crit = HIGH_CRIT;
    }
    else if(p==6) { // stable patient
        res.crit = NORMAL_CRIT;
    }
    else if(p==7) { // distracted patient
        res.obey = HIGH_WEIGHTS[0];
        res.disobey = HIGH_WEIGHTS[1];
        res.FW_th = HIGH_FW;
    }
    else if(p==8) { // focused patient
        res.FW_th = LOW_FW;
        res.obey = LOW_WEIGHTS[0];
        res.disobey = LOW_WEIGHTS[1];
    }
    else {
        res.FW_th = DISABLED_FW;
        res.obey = DISABLED_WEIGHTS[0];
        res.disobey = DISABLED_WEIGHTS[1];
        res.delta_x100 = DISABLED_DELTA;
        res.lambda_inv = DISABLED_LAMBDA;
        res.crit = DISABLED_CRIT;
    }

    return res;
}

/**
*** VARIABLES
**/

// Mission Mgmt
const int R = 1;

int currOp[R] = {1};
double dX[R], dY[R];

bool stop[R] = {false};
bool startHuman = false;
bool stopHuman = false;
bool exeRobot = false;
bool fail = false;
bool scs = false;
//
const int MAX_BUFF_SIZE = 10;

// Robot Mgmt
bool active_robot[R] = {true};
int currR = 1; //current robot
int coR = -1;  //co-robot
bool synch = false;    //used to check if the syncrhonization between the two robots has happened (task handover pattern)
/*
** Added for multi-robot TESTING
*/
bool busy[R] = {false};

// Human Mgmt
int currH = 1;
int hExe = 0;

// Sensor Outputs
double batteryCharge[R] = {100.0};
double internal_charge[R] = {-1.0};

double robPositionX[R];
double robPositionY[R];
double internalRobX[R], internalRobY[R];

/**
* MISSION DEFINITION
**/

// -&gt; HOW MANY HUMANS TO SERVE IN THE MISSION
const int H = 5;


bool served[H] = {false,false,false,false,false};
bool objectTaken[H] = {false,false,false,false,false};
double humanFatigue[H] = {0.0,0.0,0.0,0.0,0.0};
double humanPositionX[H] = {0.0,0.0,0.0,0.0,0.0};
double humanPositionY[H] = {0.0,0.0,0.0,0.0,0.0};
double humTheta[H] = {0.0,0.0,0.0,0.0,0.0};

double internalFatigue[H] = {0.0,0.0,0.0,0.0,0.0};
double internalHumX[H] = {0.0,0.0,0.0,0.0,0.0};
double internalHumY[H] = {0.0,0.0,0.0,0.0,0.0};

const int ND = -1;
const double NDD = -1.0;
int PATH = 0;

int SAME_H_IDs[H][H] = {{1,4,5,-1,-1},{2,3,-1,-1,-1},{3,2,-1,-1,-1},{4,1,5,-1,-1},{5,1,4,-1,-1}};

// -&gt; DEFINE PATTERN SEQUENCE (make sure it is consistent with humans ids)
// 0: human follower, 1: human leader, 2: human recipient, 3: human applicant,
// 10: human_rescuer, (11: human_interdependence_mission,) 12: human competitor
int patterns[H] = {0,1,1,1,0};
int patterns_alt1[H] = {0,1,1,1,0};
int patterns_alt2[H] = {0,1,1,1,0};
//

// -&gt; DEFINE STARTING LOCATIONS IN CARTESIAN PLAN
double startX[H] = {2500.0,3000.0,1400.0,400.0,500.0};
double startY[H] = {500.0,500.0,200.0,200.0,200.0};

double startX_alt1[H] = {2500.0,3000.0,1400.0,400.0,500.0};
double startY_alt1[H] = {500.0,500.0,200.0,200.0,200.0};
double startX_alt2[H] = {2500.0,3000.0,1400.0,400.0,500.0};
double startY_alt2[H] = {500.0,500.0,200.0,200.0,200.0};

// -&gt; DEFINE DESTINATIONS IN CARTESIAN PLAN
// the definition of destination can vary depending on the pattern,
// and you can decide what it corresponds to for your specific pattern
double destX[H] = {400.0,1400.0,3000.0,500.0,3500.0};
double destY[H] = {200.0,200.0,500.0,200.0,200.0};

double destX_alt1[H] = {400.0,1400.0,3000.0,500.0,3500.0};
double destY_alt1[H] = {200.0,200.0,500.0,200.0,200.0};
double destX_alt2[H] = {400.0,1400.0,3000.0,500.0,3500.0};
double destY_alt2[H] = {200.0,200.0,500.0,200.0,200.0};

/**
* PARAMS FOR RESCUER AND APPLICANT (task size and dexterity)
**/

const int task_size = 150;
int dext = 1;
int task_completion = 0;

/**
*** FLOOR PLAN
**/
const int N_A = 10;

const int N_P = 10;

const int N_I = 9;


typedef double point[2];
typedef point area[4];
typedef area layout[N_A];
typedef point trajectory[N_P];

const layout FLOOR = {{{0.0, 110.0},{0.0, 299.5},{1550.0, 299.5},{1550.0, 110.0}},{{0.0, 110.0},{0.0, 850.0},{185.0, 850.0},{185.0, 110.0}},{{0.0, 672.5},{0.0, 850.0},{1550.0, 850.0},{1550.0, 672.5}},{{1352.0, 110.0},{1352.0, 850.0},{1550.0, 850.0},{1550.0, 110.0}},{{2970.0, 110.0},{2970.0, 299.5},{4512.5, 299.5},{4512.5, 110.0}},{{2970.0, 110.0},{2970.0, 850.0},{3155.0, 850.0},{3155.0, 110.0}},{{2970.0, 672.5},{2970.0, 850.0},{4512.5, 850.0},{4512.5, 672.5}},{{4322.0, 110.0},{4322.0, 850.0},{4512.5, 850.0},{4512.5, 110.0}},{{1945.0, 0.0},{1945.0, 695.0},{2670.0, 695.0},{2670.0, 0.0}},{{1352.0, 110.0},{1352.0, 425.0},{3155.0, 425.0},{3155.0, 110.0}}};

const point INTERSECTIONS[N_I] = {{92.5, 163.5},{92.5, 761.2},{1452.0, 761.2},{1452.0, 163.5},{3062.5, 163.5},{4417.0, 163.5},{3062.5, 761.2},{4417.0, 761.2},{2253.5, 267.5}};


// I apologize for the four doubles,
// but it seems to be bugging when arrays are passed as arguments.
bool same_area(double sx, double sy, double dx, double dy) {
    int i;
    bool x_s_in, y_s_in, x_d_in, y_d_in;
    for (i = 0; i &lt; N_A; i++)
    {
        x_s_in = sx &gt; FLOOR[i][0][0] &amp;&amp; sx &lt; FLOOR[i][3][0];
        y_s_in = sy &gt; FLOOR[i][0][1] &amp;&amp; sy &lt; FLOOR[i][1][1];
        x_d_in = dx &gt; FLOOR[i][0][0] &amp;&amp; dx &lt; FLOOR[i][3][0];
        y_d_in = dy &gt; FLOOR[i][0][1] &amp;&amp; dy &lt; FLOOR[i][1][1];
        if ((x_s_in &amp;&amp; y_s_in) &amp;&amp; (x_d_in &amp;&amp; y_d_in)) // start and dest in same area
            return true;
    }
    return false;
}

// same.
double pt_dist(double x1, double x2, double y1, double y2) {
    double xdifference = x2-x1;
    double ydifference = y2-y1;
    return sqrt((xdifference*xdifference)+(ydifference*ydifference));
}

double calculateDistance() {
    double xdifference = pow(robPositionX[currR-1]-humanPositionX[currH-1], 2);
    double ydifference = pow(robPositionY[currR-1]-humanPositionY[currH-1], 2);
    double distance = sqrt(xdifference + ydifference)/100;

    if(distance&lt;0) return -distance;
    else return distance;
}

// Wall Corner Points
const point rechargeStation = {220.0, 320.00};

/////// static globalDec ///////
const int nc_seeao=5;
const int n_arg_all=22;
const int n_sense_tot=5;
const int nc_obj=3;
const int nr_argAd=7;

/////// max globalDec ///////
const int nr_seeao_max = 57;
const int nr_impEntity_max = 11;
const int nr_impSense_max = 5;
const int nr_obj_max = 7;
</declaration>
<template>
    <name>Human_Applicant</name>
    <parameter>int id, double _v, int p_f, int p_fw, int p_dext, int path</parameter>
    <declaration>
/* general comments
- if the person is far from the objective, it will move towards it, otherwise it will wait for the command to
sincronyze and start executing.
- functions for moving the humans are the same of human leader, they can be globally packaged maybe?
*/
clock t, F;
clock tUpd;
clock tWH;
clock tExp;

double Fp;
double lambda, mi;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

//this sets the state of the mission: getting to objective or working at mission
bool exeMission = false;
//threshHold for completing the mission
const double tWHTh = 60.0;


bool checkDist() {
    return pt_dist(internalHumX[id - 1], destX[id - 1], internalHumY[id - 1], destY[id - 1]) &lt;= 50.0;
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;

    F = 0;
    Fp = 0;
    t = 0;
    tWH = 0;
    tUpd = 0;

    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id - 1] = humanPositionX[id - 1];
    internalHumY[id - 1] = humanPositionY[id - 1];

    // unfortunately the switch case is not supported yet
    if (p_f == 1)
    {
        lambda = YOUNG_HEALTHY[0];
        mi = YOUNG_HEALTHY[1];
    }
    else if (p_f == 2)
    {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    }
    else if (p_f == 3)
    {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    }
    else if (p_f == 4)
    {
        lambda = ELDERLY_SICK[0];
        mi = ELDERLY_SICK[1];
    }
    else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    }
    else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    }
    else
    {
        lambda = 0.005;
        mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    if(dist_to_dest&lt;1.0) TE = 999;
    else TE = fint(dist_to_dest / _v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;

    exeMission = checkDist();
}

void updateF(double coeff, bool walking) {
    if (walking)
    {
        internalFatigue[id - 1] = 1 - (1 - internalFatigue[id - 1]) * exp(coeff * Tpoll);
    }
    else
    {
        internalFatigue[id - 1] = internalFatigue[id - 1] * exp(coeff * Tpoll);
    }

    internalFatigue[id - 1] = fmax(0, internalFatigue[id - 1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void updateP() {
    double eps = 0.0;
    exeMission = checkDist();
    if (exeMission) return;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0] == 0.0 &amp;&amp; traj[curr_traj][1] == 0.0))
        return;

    if (pt_dist(internalHumX[id - 1], traj[curr_traj][0], internalHumY[id - 1], traj[curr_traj][1]) &lt; _v * 1.1)
    {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id - 1], internalHumY[id - 1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id - 1] = internalHumX[id - 1] + _v * Tpoll * cos(ort * PI / 180);
    internalHumY[id - 1] = internalHumY[id - 1] + _v * Tpoll * sin(ort * PI / 180);
}


void start_moving() {
    F = 0;
    t = 0;
    tUpd = 0;
    fw = 0;
    plan_traj();
}
</declaration>
    <location id="id0" x="-815" y="-51">
        <name x="-825" y="-85">h_init</name>
        <committed/>
    </location>
    <location id="id1" x="-620" y="-51" color="#0000ff">
        <name x="-630" y="-85">h_idle</name>
        <label kind="invariant" x="-671" y="-34">t' == 1
&amp;&amp; tWH' ==0
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
    </location>
    <location id="id2" x="-161" y="-178" color="#0000ff">
        <name x="-204" y="-161">h_executing</name>
        <label kind="invariant" x="-153" y="-289">t' == 1 &amp;&amp; tExp'==0
&amp;&amp; tWH' == p_dext
&amp;&amp; tWH &lt;= tWHTh
&amp;&amp; F &lt;= F_max
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
    </location>
    <location id="id3" x="-161" y="212" color="#0000ff">
        <name x="-171" y="178">h_busy</name>
        <label kind="invariant" x="-221" y="221">t' == 1
&amp;&amp; tWH' == 0
&amp;&amp; F &lt;= F_max
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
    </location>
    <location id="id4" x="-748" y="-331">
        <committed/>
    </location>
    <location id="id5" x="-620" y="-332">
        <committed/>
    </location>
    <location id="id6" x="170" y="-119">
        <committed/>
    </location>
    <location id="id7" x="170" y="-178">
        <committed/>
    </location>
    <location id="id8" x="153" y="212">
        <committed/>
    </location>
    <location id="id9" x="153" y="297">
        <committed/>
    </location>
    <location id="id10" x="-382" y="-178">
        <urgent/>
    </location>
    <location id="id11" x="-365" y="110">
        <urgent/>
    </location>
    <location id="id12" x="17" y="25" color="#ff0000">
        <name x="68" y="-17">failed</name>
        <label kind="invariant" x="68" y="0">t' == 0 &amp;&amp;
F' == 0 &amp;&amp;
tWH' == 0</label>
        <label kind="exponentialrate" x="42" y="17">1</label>
    </location>
    <location id="id13" x="-510" y="-144">
        <name x="-527" y="-170">c1</name>
        <committed/>
    </location>
    <location id="id14" x="-161" y="51">
        <name x="-152" y="26">c2</name>
        <committed/>
    </location>
    <branchpoint id="id15" x="-161" y="-59">
    </branchpoint>
    <branchpoint id="id16" x="-484" y="-178">
    </branchpoint>
    <init ref="id0"/>
    <transition color="#ff0000">
        <source ref="id3"/>
        <target ref="id12"/>
        <label kind="guard" x="204" y="136">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
        <nail x="195" y="212"/>
        <nail x="195" y="93"/>
    </transition>
    <transition color="#ff0000">
        <source ref="id1"/>
        <target ref="id12"/>
        <label kind="guard" x="-561" y="-382">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
        <nail x="-578" y="-357"/>
        <nail x="195" y="-357"/>
        <nail x="280" y="-229"/>
        <nail x="161" y="-34"/>
    </transition>
    <transition>
        <source ref="id15"/>
        <target ref="id2"/>
        <label kind="assignment" x="-178" y="-102">hExe=1</label>
        <label kind="probability" x="-178" y="-119">obey</label>
    </transition>
    <transition color="#ff0000">
        <source ref="id15"/>
        <target ref="id3"/>
        <label kind="probability" x="-255" y="51">disobey</label>
        <nail x="-195" y="59"/>
    </transition>
    <transition>
        <source ref="id14"/>
        <target ref="id15"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id14"/>
        <label kind="guard" x="-153" y="76">!served[id-1]
        &amp;&amp; currH == id
        &amp;&amp; exeMission</label>
        <label kind="synchronisation" x="-153" y="127">start_h_action?</label>
    </transition>
    <transition>
        <source ref="id13"/>
        <target ref="id16"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id13"/>
        <label kind="guard" x="-586" y="-127">!served[id-1] &amp;&amp; currH == id
&amp;&amp; exeMission</label>
        <label kind="synchronisation" x="-586" y="-76">start_h_action?</label>
    </transition>
    <transition color="#ff0000">
        <source ref="id16"/>
        <target ref="id1"/>
        <label kind="probability" x="-561" y="-195">disobey</label>
        <nail x="-493" y="-178"/>
        <nail x="-578" y="-178"/>
    </transition>
    <transition>
        <source ref="id16"/>
        <target ref="id10"/>
        <label kind="assignment" x="-467" y="-178">hExe=1</label>
        <label kind="probability" x="-467" y="-195">obey</label>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="synchronisation" x="-374" y="-110">stop_h_action?</label>
        <label kind="assignment" x="-408" y="-93">t=0, Fp=F, tUpd=0,hExe=0</label>
        <nail x="-246" y="-102"/>
        <nail x="-518" y="-102"/>
    </transition>
    <transition>
        <source ref="id12"/>
        <target ref="id12"/>
        <nail x="59" y="8"/>
        <nail x="59" y="8"/>
        <nail x="59" y="42"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id12"/>
        <label kind="guard" x="25" y="59">F &gt;= F_max</label>
        <label kind="synchronisation" x="25" y="76">h_fail!</label>
        <label kind="assignment" x="25" y="93">t = 0</label>
        <nail x="17" y="212"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id12"/>
        <label kind="guard" x="-76" y="-85">F &gt;= F_max</label>
        <label kind="synchronisation" x="-76" y="-68">h_fail!</label>
        <label kind="assignment" x="-76" y="-51">t = 0, hExe=0</label>
        <nail x="-76" y="-34"/>
        <nail x="17" y="-34"/>
    </transition>
    <transition color="#ff0000">
        <source ref="id3"/>
        <target ref="id1"/>
        <label kind="guard" x="-620" y="212">!served[id-1] &amp;&amp;
fw &gt;= freeWillTh &amp;&amp;
tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="-620" y="263">t = 0, Fp=F, tUpd=0</label>
        <nail x="-620" y="212"/>
    </transition>
    <transition color="#ff0000">
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="guard" x="-459" y="-297">!served[id-1] &amp;&amp;
fw &gt;= freeWillTh &amp;&amp;
tUpd &gt;= Tpoll</label>
        <label kind="assignment" x="-459" y="-246">t = 0, Fp=F, tUpd=0, hExe=0</label>
        <nail x="-161" y="-220"/>
        <nail x="-595" y="-220"/>
    </transition>
    <transition>
        <source ref="id11"/>
        <target ref="id3"/>
        <label kind="guard" x="-306" y="127">F==0</label>
        <label kind="assignment" x="-306" y="144">Fp=1</label>
        <nail x="-365" y="144"/>
        <nail x="-212" y="144"/>
    </transition>
    <transition>
        <source ref="id11"/>
        <target ref="id3"/>
        <label kind="guard" x="-331" y="93">F&gt;0</label>
        <label kind="assignment" x="-297" y="93">Fp = 1-F</label>
        <nail x="-238" y="110"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id11"/>
        <label kind="guard" x="-510" y="59">!served[id-1]
        &amp;&amp; !exeMission</label>
        <label kind="assignment" x="-510" y="93">start_moving()</label>
        <nail x="-527" y="110"/>
    </transition>
    <transition>
        <source ref="id10"/>
        <target ref="id2"/>
        <label kind="guard" x="-365" y="-127">F==0</label>
        <label kind="assignment" x="-306" y="-127">Fp= 1</label>
        <nail x="-382" y="-136"/>
        <nail x="-263" y="-136"/>
        <nail x="-263" y="-178"/>
    </transition>
    <transition>
        <source ref="id10"/>
        <target ref="id2"/>
        <label kind="guard" x="-340" y="-195">F&gt;0</label>
        <label kind="assignment" x="-289" y="-195">Fp = 1-F</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id3"/>
        <label kind="guard" x="25" y="255">currH!=id</label>
        <label kind="assignment" x="34" y="238">tExp=0</label>
        <nail x="153" y="255"/>
        <nail x="-161" y="255"/>
    </transition>
    <transition>
        <source ref="id3"/>
        <target ref="id8"/>
        <label kind="guard" x="-51" y="187">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="25" y="127">updateF(-lambda, 1),
updateP(), tUpd=0,
fw = random(FW_max)</label>
        <nail x="0" y="212"/>
    </transition>
    <transition>
        <source ref="id9"/>
        <target ref="id3"/>
        <label kind="synchronisation" x="25" y="297">publish_m[2]!</label>
        <nail x="-161" y="297"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
        <label kind="guard" x="-442" y="-68">tWH &gt;= tWHTh</label>
        <label kind="assignment" x="-442" y="-51">served[currH-1]= true,
        t = 0, exeMission = 0, Fp=F,
        tUpd=0, tWH=0,hExe=0</label>
        <nail x="-229" y="-51"/>
    </transition>
    <transition>
        <source ref="id7"/>
        <target ref="id6"/>
        <label kind="guard" x="178" y="-161">currH==id</label>
        <label kind="synchronisation" x="178" y="-144">publish_m[2]!</label>
    </transition>
    <transition>
        <source ref="id7"/>
        <target ref="id2"/>
        <label kind="guard" x="68" y="-161">currH!=id</label>
        <nail x="127" y="-144"/>
        <nail x="-102" y="-144"/>
    </transition>
    <transition>
        <source ref="id6"/>
        <target ref="id2"/>
        <label kind="synchronisation" x="59" y="-119">publish_m[3]!</label>
        <nail x="-59" y="-119"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id7"/>
        <label kind="guard" x="51" y="-221">tUpd&gt;=Tpoll
        &amp;&amp; tWH &lt; tWHTh</label>
        <label kind="assignment" x="51" y="-272">updateF(-lambda, 1),
tUpd=0,
fw = random(FW_max)</label>
        <nail x="8" y="-178"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id5"/>
        <label kind="guard" x="-705" y="-297">tUpd&gt;= Tpoll</label>
        <label kind="assignment" x="-705" y="-280">updateF(-mi, 0),
tUpd=0,
fw = random(FW_max)</label>
        <nail x="-620" y="-187"/>
        <nail x="-620" y="-187"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id1"/>
        <label kind="guard" x="-714" y="-187">currH!=id</label>
        <label kind="assignment" x="-705" y="-170">tExp=0</label>
        <nail x="-680" y="-331"/>
        <nail x="-680" y="-51"/>
    </transition>
    <transition>
        <source ref="id4"/>
        <target ref="id1"/>
        <label kind="synchronisation" x="-850" y="-187">publish_m[2]!</label>
        <nail x="-748" y="-51"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id4"/>
        <label kind="guard" x="-731" y="-374">currH==id</label>
        <label kind="synchronisation" x="-731" y="-357">publish_m[3]!</label>
    </transition>
    <transition>
        <source ref="id0"/>
        <target ref="id1"/>
        <label kind="assignment" x="-782" y="-51">initHuman()</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id9"/>
        <label kind="guard" x="170" y="238">currH==id</label>
        <label kind="synchronisation" x="170" y="255">publish_m[3]!</label>
    </transition>
</template>
	<template>
		<name>Human_Competitor</name>
		<parameter>int id, double _v, int p_f, int p_fw, int path</parameter>
		<declaration>clock t, F;
clock tUpd;
clock tExp;

double Fp;
double lambda, mi;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

//TODO coordinates of the eventual position to take the object. At the moment it is the initial position
double secondDestX = 0.0;
double secondDestY = 0.0;

bool atDestRobot = false;
bool atDestHuman = false;


// Position Sharing Parameters

void updateF(double coeff, bool walking) {
    if(walking) internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    else internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    plan_traj();
}

meta int v;

// double dist_to_dest;
void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 20.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;
    double dice = random(100.0);

    if(dice&gt;50) {
        startX[id-1] = 220.0;
        startY[id-1] = 300.0;
    } else {
        startX[id-1] = 2000.0;
        startY[id-1] = 300.0;
    }

    F = 0;
    Fp = 0;
    t = 0;
    tUpd = 0;

    v = fint(_v);

    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    secondDestX = destX[id-1];
    secondDestY = destY[id-1];

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    }
    else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    }
    else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}

double rob_dist_to_dest;
double dist_to_dest;
void checkFirst() {
    int i;
    rob_dist_to_dest = pt_dist(robPositionX[currR-1], destX[id-1], robPositionY[currR-1], destY[id-1]);
    dist_to_dest = pt_dist(destX[id-1], internalHumX[id-1], destY[id-1], internalHumY[id-1]);
    if(dist_to_dest &lt;= v*1.2){ //priority to human if parity
        atDestHuman = true;
        PATH = 2;

        for(i=0; i&lt;H; i++) {
            patterns[i] = patterns_alt2[i];
            destX[i] = destX_alt2[i];
            destY[i] = destY_alt2[i];
        }

        dX[currR-1] = secondDestX;
        dY[currR-1] = secondDestY;
    } else if(rob_dist_to_dest &lt;= v*1.2){
        PATH = 1;

        for(i=0; i&lt;H; i++) {
            patterns[i] = patterns_alt1[i];
            destX[i] = destX_alt1[i];
            destY[i] = destY_alt1[i];
        }

        atDestRobot = true;
        destX[currH-1] = secondDestX;
        destY[currH-1] = secondDestY;
        dX[currR-1] = secondDestX;
        dY[currR-1] = secondDestY;
    }
}

void checkSuccess(){
    dist_to_dest = pt_dist(secondDestX, internalHumX[id-1], secondDestY, internalHumY[id-1]);
    rob_dist_to_dest = pt_dist(robPositionX[currR-1], secondDestX, robPositionY[currR-1], secondDestY);
    // when humans/robot reach their destination, they can be set as "served"
    served[id-1] = (atDestHuman &amp;&amp; (dist_to_dest &lt;= v*2.0)) ||
                (atDestRobot &amp;&amp; (rob_dist_to_dest &lt;= v*2.0));
}
    </declaration>
		<location id="id17" x="-807" y="8">
			<label kind="comments" x="-467" y="-340">assunzione per semplificare:
            il primo che arriva è quello
            capace di tornare indietro
            con il componente per primo
            (altrimenti dovrebbero esserci
            dei passaggi tipo "staffetta")</label>
			<committed/>
		</location>
		<location id="id18" x="-603" y="8" color="#0000ff">
			<name x="-595" y="-25">idle</name>
			<label kind="invariant" x="-595" y="-68">F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id19" x="-332" y="8">
			<name x="-342" y="-26">c1</name>
			<committed/>
		</location>
		<location id="id20" x="-43" y="8" color="#0000ff">
			<name x="-25" y="-8">way_there</name>
			<label kind="invariant" x="-25" y="8">F &lt;= F_max
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id21" x="-76" y="204">
			<name x="-93" y="221">free_will_dec</name>
			<committed/>
		</location>
		<location id="id22" x="-221" y="8">
			<name x="-231" y="-26">c2</name>
			<committed/>
		</location>
		<location id="id23" x="-42" y="-323" color="#ff0000">
			<name x="-136" y="-314">failed</name>
			<label kind="invariant" x="-136" y="-297">t' == 0 &amp;&amp;
F' == 0</label>
			<label kind="exponentialrate" x="-76" y="-332">1</label>
		</location>
		<location id="id24" x="272" y="178">
			<committed/>
		</location>
		<location id="id25" x="272" y="119">
			<committed/>
		</location>
		<location id="id26" x="272" y="8">
			<name x="255" y="-26">checking</name>
			<committed/>
		</location>
		<location id="id27" x="272" y="-170">
			<committed/>
		</location>
		<location id="id28" x="-603" y="102">
			<name x="-637" y="93">p1</name>
			<committed/>
		</location>
		<location id="id29" x="-603" y="203">
			<committed/>
		</location>
		<location id="id30" x="272" y="-323" color="#0000ff">
			<name x="289" y="-323">way_back</name>
			<label kind="invariant" x="289" y="-306">F &lt;= F_max
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id31" x="272" y="-247">
			<committed/>
		</location>
		<location id="id32" x="501" y="-323">
			<committed/>
		</location>
		<location id="id33" x="552" y="263" color="#0000ff">
			<name x="569" y="246">wait_rob_dest1</name>
			<label kind="invariant" x="569" y="263">F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id34" x="280" y="263">
			<committed/>
		</location>
		<branchpoint id="id35" x="-281" y="8">
		</branchpoint>
		<init ref="id17"/>
		<transition color="#ff0000">
			<source ref="id20"/>
			<target ref="id23"/>
			<label kind="guard" x="-178" y="-153">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
			<nail x="-119" y="-136"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id18"/>
			<target ref="id23"/>
			<label kind="guard" x="-416" y="-170">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id33"/>
			<label kind="guard" x="365" y="221">!served[id-1]</label>
			<nail x="408" y="229"/>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id18"/>
			<label kind="guard" x="-585" y="271">served[id-1]</label>
			<label kind="synchronisation" x="-585" y="288">stop_r_action!</label>
			<label kind="assignment" x="-586" y="255">tExp=0</label>
			<nail x="-603" y="272"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id34"/>
			<label kind="guard" x="365" y="272">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="280" y="289">checkSuccess(), tUpd=0, updateF(-mi, 0)</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id30"/>
			<label kind="guard" x="144" y="-255">currH!=id</label>
			<nail x="212" y="-246"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id20"/>
			<label kind="guard" x="76" y="102">currH!=id</label>
			<label kind="assignment" x="85" y="119">tExp=0</label>
			<nail x="-42" y="119"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id26"/>
			<target ref="id21"/>
			<label kind="guard" x="51" y="212">fw&gt;=freeWillTh</label>
			<nail x="272" y="204"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id33"/>
			<label kind="guard" x="561" y="59">!atDestHuman &amp;&amp; atDestRobot</label>
			<label kind="synchronisation" x="561" y="93">stop_h_action!</label>
			<label kind="assignment" x="561" y="76">updateF(-lambda, 0)</label>
			<nail x="552" y="8"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id18"/>
			<label kind="assignment" x="-357" y="212">Fp=F, tUpd=0, t=0</label>
			<nail x="-603" y="204"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id32"/>
			<target ref="id18"/>
			<label kind="guard" x="-467" y="-399">served[id-1] || fw&gt;=freeWillTh</label>
			<label kind="synchronisation" x="-467" y="-382">stop_h_action!</label>
			<label kind="assignment" x="-467" y="-365">hExe = 0, Fp = F</label>
			<nail x="501" y="-399"/>
			<nail x="-603" y="-399"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id32"/>
			<target ref="id27"/>
			<label kind="guard" x="510" y="-229">!served[id-1]  &amp;&amp; fw&lt;freeWillTh</label>
			<label kind="assignment" x="510" y="-195">updateP(), updateF(-lambda, 1)</label>
			<nail x="501" y="-170"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id32"/>
			<label kind="guard" x="306" y="-383">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="306" y="-366">checkSuccess(),
fw = random(FW_max)</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id23"/>
			<label kind="guard" x="51" y="-374">F &gt;= F_max</label>
			<label kind="synchronisation" x="51" y="-357">h_fail!</label>
			<label kind="assignment" x="51" y="-340">t = 0, hExe = 0</label>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id30"/>
			<label kind="synchronisation" x="170" y="-297">publish_m[3]!</label>
			<label kind="assignment" x="144" y="-280">tUpd=0, tExp=0</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id31"/>
			<label kind="guard" x="187" y="-229">currH==id</label>
			<label kind="synchronisation" x="170" y="-212">publish_m[2]!</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id27"/>
			<label kind="guard" x="280" y="-144">atDestHuman
&amp;&amp; fw&lt;freeWillTh
&amp;&amp; !atDestRobot</label>
			<label kind="synchronisation" x="280" y="-93">stop_r_action!</label>
			<label kind="assignment" x="280" y="-76">updateP(), updateF(-lambda, 1), plan_traj()</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id18"/>
			<label kind="guard" x="-739" y="102">currH!=id</label>
			<label kind="assignment" x="-731" y="119">tExp=0</label>
			<nail x="-663" y="110"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id18"/>
			<label kind="synchronisation" x="-629" y="50">publish_m[3]!</label>
			<label kind="assignment" x="-629" y="68">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="-629" y="135">currH==id</label>
			<label kind="synchronisation" x="-637" y="152">publish_m[2]!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id29"/>
			<label kind="guard" x="-527" y="102">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-527" y="119">updateF(-mi, 0),
tUpd=0,
fw = random(FW_max)</label>
			<nail x="-535" y="110"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id25"/>
			<label kind="guard" x="280" y="25">!atDestHuman
&amp;&amp; !atDestRobot
&amp;&amp; fw&lt;freeWillTh</label>
			<label kind="assignment" x="280" y="76">updateP(),
            updateF(-lambda, 1)</label>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id26"/>
			<label kind="guard" x="42" y="-85">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="42" y="-68">checkFirst(),
fw = random(FW_max),
tUpd=0, updateP(),
updateF(-lambda, 1)</label>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-178" y="93">stop_r_action!</label>
			<label kind="assignment" x="-136" y="110">hExe=0</label>
			<nail x="-76" y="76"/>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id23"/>
			<nail x="-93" y="-374"/>
			<nail x="-42" y="-374"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id23"/>
			<label kind="guard" x="-34" y="-229">F &gt;= F_max</label>
			<label kind="synchronisation" x="-34" y="-212">h_fail!</label>
			<label kind="assignment" x="-34" y="-195">t = 0</label>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id24"/>
			<label kind="guard" x="280" y="127">currH==id</label>
			<label kind="synchronisation" x="280" y="144">publish_m[2]!</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="59" y="153">publish_m[3]!</label>
			<nail x="-42" y="178"/>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id20"/>
			<label kind="guard" x="-170" y="8">F==0</label>
			<label kind="assignment" x="-170" y="25">Fp=1,
            plan_traj()</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id20"/>
			<label kind="guard" x="-170" y="-76">F&gt;0</label>
			<label kind="assignment" x="-170" y="-59">Fp=1-F,
            plan_traj()</label>
			<nail x="-136" y="-25"/>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id22"/>
			<label kind="probability" x="-272" y="8">obey</label>
		</transition>
		<transition color="#ff0000">
			<source ref="id35"/>
			<target ref="id18"/>
			<label kind="probability" x="-476" y="68">disobey</label>
			<nail x="-450" y="68"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id35"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id19"/>
			<label kind="guard" x="-493" y="-25">currH==id</label>
			<label kind="synchronisation" x="-501" y="-9">start_h_action?</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="assignment" x="-739" y="-8">initHuman()</label>
		</transition>
	</template>
	<template>
		<name>Human_Follower</name>
		<parameter>int id, double _v, int p_f, int p_fw, int start_from, int path,const double arg[n_arg_all],const int arg_ad[nr_argAd], const int SEEAO[nr_seeao_max][nc_seeao], const double importance_entity[nr_impEntity_max], const double importance_sense[nr_impSense_max], const double obj_xye[nr_obj_max][nc_obj]</parameter>
		<declaration>

clock t, F, Fp;
clock tUpd;
clock tExp;

double lambda, mi;
const double passout_th = 1.0;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

void updateHealthDangerProb() {
    if(scs) {
        crit = 0.0;
        non_crit = FS;
        return;
    }
    crit = hs + hs * internalFatigue[id-1];
    non_crit = FS - crit;
}

// Fatigue Sharing Parameters
bool ONCE_FTG = true;
bool ONCE_POS = true;

meta int v;

void updateF(double coeff, bool walking) {
    // if two human instances are the same person,
    // residual conditions must be retrieved
    if (ONCE_FTG &amp;&amp; start_from!=-1 &amp;&amp; currH==id) {
        F = internalFatigue[start_from-1];
        Fp = F;
        internalFatigue[id-1] = F;
        ONCE_FTG = false;
    }

    if(walking) internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    else internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        if(neigh[0]==-1) return;
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void updateP() {
    double eps = 0.0;
    // same as ONCE_FTG
    if (ONCE_POS &amp;&amp; start_from!=-1) {
        humanPositionX[id-1] = internalHumX[start_from-1];
        humanPositionY[id-1] = internalHumY[start_from-1];
        internalHumX[id-1] = humanPositionX[id-1];
        internalHumY[id-1] = humanPositionY[id-1];
        ONCE_POS = false;
    }

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void check_crit(){
     double humanRobotDist = calculateDistance();
     if(currH!=id || served[id-1]) return;
     if(humanRobotDist&lt;=0.5) collisions++;

     if(is_crit) v = fint(_v*0.6);
     else v = fint(_v);
}


double crit_prob;
void update_crit() {
    double dice = random(100);
    crit_prob = 1-exp(-lambda_crit*t);

    if(dice&lt;=crit_prob*100) {
        is_crit = false;
        v = fint(_v);
    }
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;

    t = 0;
    tUpd = 0;
    F = 0;
    Fp = 0;
    v = fint(_v);

    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }
    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5) {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    } else if (p_f == 6) {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    }
    else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}
////////////////////////////////////////////////
//extraction declaration code
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

/*
h_b_ultra_cmpc_v1
modello che fa le stesse cose di quello cmpct con una sola funzione

variabili: 
- vettore dei pesi degli eventi
- vettore dei pesi delle azioni
- vettore dei pesi dei sensi
- SEAAO: matrice che lega tutti gli elementi Sense-Entity-Event-Action-Output,
 da n righe = numero di azioni e 5 colonne.
-n_eventi,n_action,n_sense,n_entity
remember: 
- lenght_interval_vector = length_of the id vector, so when we call that function we can use instead of it n_sense, 
n_action, n_events
- lego in modo univoco l'id del senso,dell'evento, dell'entity, e dell'azione finale e dell'output.
- ogni elemento ha il suo id, in modo da aggiornare più facilmente i pesi, che sono univoci rispetto a all'elemento.
*/

    bool id_rows = false; // true NON ANCORA IMPLEMENTATO
                      //per utilizzare la ricerca dell'azione usando la riga =&gt; riga = id azione --&gt;semplifica la ricerca della
                     //outuput id SEAAO [n_riga][4]   
                    // false IMPLEMENTATO 
                    //per avere l'id dell'azione nella matrice e non dato dalla riga --&gt; output dato da selezione 
                    // della riga in base a senso- entità- evento- azione 



    int i,j,k,o,i1,i2,i3,i4,i5,i6,j1,j2,j3,j4; // indexes for the for loops

    const int N_interval = 101; // number for the scale of the the interval vector
    const int N_random = 100; // number to define the scale of the probability
    // li ho settati diversi (dovrebbero essere uguali) perchè è la strada più veloce
    // che mi ha aiutato nel capire che c'è un caso particolare che mi da out of range
    // ho già pensato come risolverlo, lo sto facendo in una versione 1 di questo, per 
    // non mischiare
    // c’è un problema (se N_interval = N_random)
    //quando la somma dei pesi fa tipo 99 e il numero random 
    //che esce è 100, dato che il valore che nell’interval vector non c’è si 
    //ha out of range


    const double upd_weight = arg[0];
    const int caso_upd_weight = fint(arg[1]);
        /*
            * 0 -&gt; nulla
            * 1 -&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm ad ogni ciclo
            * 2--&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm  RANDOMATICAMENTE
        */
    const double stm_weight = arg[2];
    const double ltm_weight = arg[3];
    const int caso_weight_entity = fint(arg[4]);
        /*
            0- nothing; the entity has weight equal to 1;
            1- every entity has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
    const int caso_weight_sense = fint(arg[5]);
          /*
            0- nothing; the sense has weight equal to 1;
            1- every sense has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
  

    // per settare come avviene la modifica del vettore event may happen
    const int caso_event = fint(arg[6]);
        /*
        il vettore event_may_happen diventa 
        0 - uguale a quello initilizzato
        1 - randomico
        2 - in base alla distanza dell'entità con l'umano 
    */ 
    
    const int caso_delay = fint(arg[7]);
        /*
            0- nulla, l'id viene estratto ad ogni chiamata della funzione out_id()
            1- l'id viene estratto ogni n index value 
        */
    const int n_delay_index = fint(arg[8]);
  // ho tolto la costante per fare in modo che le distanze posssano essere cambiate
   // variabili per il valore iniziale (dunque precedente) dell'ultima azione fatta dall'umano
  // è da fare in modo che non sia pari a zero, perchè c'è la possibilità che nel caso in cui tutti i  
   int last_id_extracted_output =fint(arg[9]); // se caso 1,la metto a zero per vedere il suo primo valore
    const int caso_last_id = fint(arg[10]);
    /*
     se 0 - quella iniziale è pari a quella settata sopra ad OGNI ciclo
    se 1 - selezionata randomicamente tra 1 e 4 / n ad OGNI ciclo
    se 2 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
            quando index_cicli &gt; 1 con index_cicli di partenza  = 0;  SOLO per la prima
    se 3 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; ma randomica la scelta di initial_id SOLO per 
        la prima
    */

    const int caso_obj = fint(arg[11]);
    /*
     * 0 -&gt; oggetti fissi secondo la matrice obj_xye
     * 1 -&gt; oggetti che randomicamente cambiano posizione e sono vicini all'umano
     * 2 -&gt; un oggetto, quello selezionato cambia posizione (vicino all'umano), gli altri sono fissi    
    */
    const int obj_selected = fint(arg[12]); 
    // distance treshold
    const double distance_threshold = arg[13];
   // variabili per le funzioni sulla stm and ltm 
    const int caso_stm_ltm = fint(arg[14]);
    /*
    se 0 - parte della perdita di memoria non attiva 
    se 1 - parte della perdita di memoria randomica attiva
    se 2 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) in modo randomico
    se 3 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) quando è piena inizia ad eliminare il primo
    */
    const int n_stm = fint(arg[15]); //massime azioni che si possono memorizzare // se 2 =&gt; n-1 elementi salvati
    const int n_ltm = fint(arg[16]); // posto a 6--&gt; non coincida con id_Action_max = 5 (per la simulazione)
    


    
//////////////////////////////////////////////////////////

//id_entity
const int id_robot=fint(arg[17]);


//id_output
const int id_walk=fint(arg[18]);
const int id_sit=fint(arg[19]);
const int id_run=fint(arg[20]);
const int id_stand=fint(arg[21]);



/////////////////////
const int n_rows = arg_ad[0];
const int n_columns = nc_seeao; //definita a livello globale arg_ad[1]; //5;

const int n_sense=arg_ad[1];//3;
const int n_entity=arg_ad[2];//11;
const int n_event=arg_ad[3];//18;
const int n_action=arg_ad[4];//20;
const int n_output=arg_ad[5];//4;


////////////////////////////////////////
  
  // number of objects in the environment
    // const int n_objects= 5;
 // matrix for the object
   /*
       	N righe = N oggetti 
       	colonna 1 : x-&gt; double
       	colonna 2 : y double 
       	colonna 3 : tipo entità  int (poi tramite conversione double -&gt; int con int = fint(double)) 
   */
const int nr_obj =arg_ad[6];// 7;
//const int nc_obj = 3;//definita a livello globale
double obj_xye_tmp[nr_obj][nc_obj];  
 // altro 
    clock x;

const int nr_obj_dyn = R;// nel Dpa è definita da R
const int nc_obj_dyn = nc_obj; // definita a livello globale
double distance_obj_dyn[nr_obj_dyn];
double obj_xye_dyn[nr_obj_dyn][nc_obj_dyn] ={{0.0,0.0,0.0}};
//int id_robot = 1;

const int nr_object = nr_obj + nr_obj_dyn;

/////////////////////////////////////////////////


//sense importance matrix
//const int n_sense_tot = 5;//in questo momento non ho trovato il modo di legare le info della SEEAO
                          // e questa in cpp, dunque li considero tutti i pesi dei sensi pur sapendo 
                          // che solo i primi 3 vengono usati.
///*
//sense importance matrix
const int n_sense_tot = nr_impSense_max;//definita al livello globale



//entity importance matrix

// in questo momento li posso assegnare in modo con id crescente
    int id_vector_sense[n_sense];
    int id_vector_event[n_event];
    int id_vector_entity[n_entity];
    int id_vector_action[n_action];
    int id_vector_output[n_output];

void init_obj_xye_tmp(int nr, int nc){
        int i = 0;
        int j = 0; 
        for(i  = 0; i &lt; nr; i ++){
            for(j = 0; j &lt; nc; j++){
                obj_xye_tmp[i][j] = obj_xye[i][j];     
            }
        }
    }
    
void id_initialization(){
    for(j1 =0 ; j1&lt;n_sense;j1++){
        id_vector_sense[j1] = j1+1;
    }
    for( j2 =0 ; j2&lt;n_event;j2++){
        id_vector_event[j2] = j2+1;
    }
    for( j3 =0 ; j3&lt;n_action;j3++){
        id_vector_action[j3] = j3+1;
    }
    for( j4 =0 ; j4&lt;n_entity;j4++){
        id_vector_entity[j4] = j4+1;
    }
    for( j4 =0 ; j4&lt;n_output;j4++){
        id_vector_output[j4] = j4+1;
    }

}

void set_to_zero(){//function toset to zero the value of the vectors and the other elements
                    // that are needed to be set to zero 


    }
 


  //matrix for the hb model
 // variabili per la funzione update_weight  
  //variabili per il i pesi dei diversi elementi presenti nel modello
    double action_weight_vector[n_action];//ora si modificano in base agli eventi 
    double sense_weight_vector[n_sense];
    double event_weight_vector[n_event];
    double entity_weight_vector[n_entity];

//variabili per la funzione update_event_may_happen
    int event_may_happen[n_event] ;// {1,1,0,0,1}; // 1 if yes, 0 if no.// it can be modified

    double weight_stm;
    double weight_ltm;
    int stm_action[n_stm];//vettore per memorizzare n_stm output_action
    int ltm_action[n_ltm];
    int stm_index = 0;
    int ltm_index =0;


// variable to count the nnumber of the model iterations over the time
    int index_cycle = 0;


  // variables to memorize the id's extracted
    int id_sense_extracted;
    int id_entity_extracted;
    int id_event_extracted;
    int id_action_extracted;
   // int id_output_extracted;
    int id_out;
    int last_output_id;
    int id_entity;
    int id_sense;
    int id_event;
    int id_action;
  
  
double distance[nr_obj];

void upd_obj_dyn_pos(){
    int i;
    for(i =0 ; i &lt; R; i++){
        obj_xye_dyn[i][0] =robPositionX[i];
        obj_xye_dyn[i][1] =robPositionY[i];
        obj_xye_dyn[i][2] =id_robot;
    }
}

int event_from_entity[n_event];
int id_object;
int neigh[nr_object];
double pos_human;
double pos_object;
// funzione che modifica il event may happen
void update_event_may_happen(){
    int g =0;
    int event_id;
    double numero_random_mh;
    int i;
    int j; 
    int k; 
    double k_th = 0.90;
    double d_th = distance_threshold*k_th; 
    
  // il caso_event definisce se il vettore event_may_happen rimane come fissato(0) o è randomico (=1)
    if(caso_event == 1){
        // associa randomicamente 0(non succede) 1(succede)
        for(g=0; g&lt; n_event; g++){
            numero_random_mh = random(100)+1;
            if(numero_random_mh &lt;= 50){
                event_may_happen[g] = 1;
            }
            else{
                event_may_happen[g] = 0;
            }
        }
    }
    else if(caso_event == 2){
    // initializzo il vettore event_may_happen a zero per fare in modo che poi cambia
    // e non avere problemi che diventino tutti uno 
        for(i = 0; i &lt; n_event; i ++){
            event_may_happen[i] = 0;
        }
        // faccio lo stesso per il vettore event_from_entity per averlo nullo al prossimo ciclo
        // e non dipendente dal ciclo precedente
        for(i = 0; i &lt; n_event; i ++){
            event_from_entity [i] = 0;
        }
      //+ popolo il vettore neighbour per oggetti statici
        for(i = 0; i &lt; nr_obj; i ++){
          //+ verifico la distanza tra entità ed umano
        // ora lo faccio in modo randomico poi posso usare le struct in cui un oggetto
        // è definito da  : object(id,x,y)
            //pos_object = random(N_random)+ 1;
            //pos_human = random(N_random) + 1;
            //pos_object = 4.0;
            //pos_human =3.0;

        // caso 1 della funzione
            init_obj_xye_tmp(nr_obj,nc_obj);
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_tmp[i][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[i][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_tmp[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance[i] = pt_dist(humanPositionX[id -1],obj_xye[i][0],humanPositionY[id -1],obj_xye[i][1]);
        // verifica della condizione sulla distanza 
            if( distance[i] &lt;= distance_threshold){
                id_object =fint(obj_xye[i][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
        
         j = 0;// perchè non faccio più riferimento alla matrice statica ma a quella dynamica che ha 
               // parte da zero come indice e non parte dall'indice finale di quella statica
               // lo faccio soptrattutto per evitare errore di indici perchè accederei a parti della matrice
               // che non esiste
        //+ popolo il vettore neighbour per oggetti dinamici dalla fine degli oggetti statici al numero totale di oggetti
        for(i = nr_obj; i &lt; nr_object; i ++){ // parto da nr_obj perchè il vettore neigh non lo divido tra dinamico
                                              // e statico ma ne mantengo uno solo con dentro sia gli oggetti statici
                                              // che dinamici
        // caso 1 della funzione
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_dyn[j][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[j][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_dyn[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance_obj_dyn[j] = pt_dist(humanPositionX[id -1],obj_xye_dyn[j][0],humanPositionY[id -1],obj_xye_dyn[j][1]);
        // verifica della condizione sulla distanza 
            if( distance_obj_dyn[j] &lt;= distance_threshold){
                id_object =fint(obj_xye_dyn[j][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
      //+ scorro la matrice per associare al vettore event_may_happen il valore 1 per l'entità
      // che rientra nel neighbour
        for(j = 0; j &lt; nr_object; j ++){  
        // scorro la matrice  
            for(i = 0; i &lt; n_rows; i++){
             // trovando l'entità che è nel neighbour of the human
                if(SEEAO[i][1] == neigh[j]){
               // prendo l'evento relativo a quell'entità
                    event_id = SEEAO[i][2];
                // faccio scorrere il vettore degli eventi per attivarli o meno
                    for(k = 0; k &lt; n_event; k++){
                // se trovo un id nel vettore degli id degli eventi uguali, dato che 
                // il vettore event_may_happen ha le stesse celle di quello dell'id_vector
                // prendendo l'indice dell'id_vector event posso porre event_may_happen[k] = 1
                        if(event_id ==id_vector_event[k]){
                           // event_may_happen[k] = 1;
                            
                            // altrimenti posso contare le ricorrenze degli eventi e poi
                            // porre event_may_happen a 1 quando il valore in un vettore che conta 
                            // le ricorrenze è maggiore di zero e gli altri a zero 
                            event_from_entity[k] = event_from_entity[k]+1;
                        }
                    }
                }
            }
        }
        
        // in questo caso l' inizializzazione del vettore event_may_happen non interessa
    // dato che qui vi assegno  ed 1, devo farlo però per il vettore event_from_entity
        for(k = 0; k&lt; n_event; k ++){
            if(event_from_entity[k]&gt;0){
                event_may_happen[k] = 1;
            }
            else{
                event_may_happen[k] = 0;
            }
        }
    }   
}

    //definition of the variable to be used in the update_weight function 
    //defined outside to look what happens over the time for their values
    double event_weight_sum = 0.0;
    double entity_weight_sum = 0.0;
    double sense_weight_sum = 0.0;
    double action_weight_sum = 0.0;

void update_weight(){//funzione per l'update dei pesi     
    int i1=0;
    int o1 = 0;
    // annullare la somma ad ogni inizio della funzione
    event_weight_sum = 0.0;
    entity_weight_sum = 0.0;
    sense_weight_sum = 0.0;
    action_weight_sum = 0.0;
    // setto i vettori dei pesi = 0; mi serve per l'estrazione poi
    for(i1 =0;i1 &lt;n_sense;i1++){
        sense_weight_vector[i1]= 0;
    } 
    i1=0;
    for(i1 =0;i1 &lt;n_entity;i1++){
        entity_weight_vector[i1]= 0;
    }
    i1 =0;    
    for(i1 =0;i1 &lt;n_event;i1++){
        event_weight_vector[i1]= 0;
    }  
    i1 =0;    
    for(i1 =0;i1 &lt;n_action;i1++){
        action_weight_vector[i1]= 0;
    }     
    

    // dal vettore degli eventi che possono succedere definisco quali sono le entità e sensi relativi 
    for(i = 0; i &lt; n_event; i ++){
        if(event_may_happen[i] == 1){
            // definisco l'id dell'evento
                id_event = id_vector_event[i];
                // ricerco nella matrice SEEAO gli eventi con l'id dell'evento che mi interessa, muovendomi lungo le azioni
                for(j= 0; j &lt; n_rows;j ++){
                    if(SEEAO[j][2]==id_event){
                         // assegno gli id_entity ed sense presi dalla matrice nella posizione che  id = id_event
                             id_entity = SEEAO[j][1];
                             id_sense = SEEAO[j][0];
                             id_action = SEEAO[j][3];
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi dell'entità
                            if(caso_weight_entity ==1){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + importance_entity[k];
                                    }
                                }
                            }
                            else if(caso_weight_entity==0){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + 1.00;
                                    }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi per i sense
                            if(caso_weight_sense==1){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] + importance_sense[o];
                                     }
                                }
                            }
                            else if(caso_weight_sense == 0){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] +1.00;
                                     }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi delle azioni
                            for( o1 = 0; o1 &lt; n_action; o1++){
                                 if(id_vector_action[o1]== id_action){
                                        action_weight_vector[o1] = action_weight_vector[o1] + 1.00;
                                        if(caso_upd_weight==1){
                                            // aggiunta pesi dalla stm
                                
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                        else if (caso_upd_weight==2 &amp;&amp; random(N_random)+1 &lt;= upd_weight){
                                            // aggiunta pesi dalla stm
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                 }
                            }

                   }            
              }

        }
    }


    //normalise the weight of the event,
    for( i1 = 0; i1 &lt; n_event; i1 ++ ){
        event_weight_sum = event_weight_sum + event_may_happen[i1];
    }
    for(i2 = 0; i2 &lt; n_event; i2++){
        event_weight_vector[i2] = event_may_happen[i2]/event_weight_sum;
    }
    //normalise the weight of the entity 
    for( i3 = 0; i3 &lt; n_entity; i3++){
        entity_weight_sum = entity_weight_sum + entity_weight_vector[i3];
    }
    for( i4 = 0; i4 &lt; n_entity; i4++){
        entity_weight_vector[i4] = entity_weight_vector[i4]/entity_weight_sum;
    }

    //normalise the weight of the sense 
    for(i5 = 0; i5 &lt; n_sense; i5++){
        sense_weight_sum = sense_weight_sum + sense_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_sense; i6++){
        sense_weight_vector[i6] = sense_weight_vector[i6]/sense_weight_sum;
    }

    // normalise the weight of the action
    for(i5 = 0; i5 &lt; n_action; i5++){
        action_weight_sum = action_weight_sum + action_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_action; i6++){
        action_weight_vector[i6] = action_weight_vector[i6]/action_weight_sum;
    }

}

    // dichirazioni per la sense_id_extraction function (messi fuori perché dentro danno problema di SCN)
    double numero_random_;
    double  interval_vector_sense[n_sense];

// for extraction of the id_sense
int sense_id_extraction(){
    double numero_random = random(N_random)+1;
    
    int q1,q;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int i1 =0;
    int id_selected[n_sense];// vettore di appoggio per i sensi selezionati
    //creare il vettore posso fare come faccio per quello dell’entità considerando solo i sensi che hanno 
    //peso diverso da zero utilizzando un vettore di appoggio per memorizzare i valori degli id di quei sensi che hanno 
    //il peso diverso da zero
    //ciclo per settare i valori del vettore di appoggio degli id = 0
    //  for(q6 = 0; q6 &lt;n_sense;q6 ++){
    //        id_selected[q6] = 0; 
    //}

    //dal vettore dei pesi dei sensi prendo solo quelli che hanno il peso diverso da 0
    //q6 =0;
    //for(i1=0; i1&lt; n_sense;i++){
      //  if(sense_weight_vector(i1)&gt;0){
        //    id_selected[q6] = id_vector_sense[i1];
          //  q6 ++;
        //}
    //}

    //interval vector initialization
    for(q1=0;q1&lt;n_sense;q1++)
    {
    	interval_vector_sense[q1] = sense_weight_vector[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_sense; q ++)//changed
    {
    interval_vector_sense[q] = interval_vector_sense[q-1]+ interval_vector_sense[q];
    }

    l=0;
    // extract the sense from the comparison between the numero random and the interval_vector components
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_sense[l]){
            id_extracted = id_vector_sense[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    } 
    return id_extracted;
}

 double  interval_vector_entity[n_entity];
 double weight_vector_entity[n_entity];//double weight_vector[n_entity];

// modo diverso dal precedente, metto a zero i pesi dell'entità non considerate, evito di usare una funzione esterna
// calcolare il numero di entità derivanti dal senso (perché non ho quell'info al tempo della compilazione)
// for extraction of the entity from the sense--------------------------------------------------
int entity_id_extraction(int sense_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_entity];// int id_selected[n_entity];
    int m1 = 0;
    int selected_id;
    int k; 
    int selected_vector[n_entity];
    //define the interval vector // dichiarazioni spostate per l'errore che danno
    //double  interval_vector[n_entity];
  
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0, comunque per non averlo uguale a non so cosa da zero
    for(q6 = 0; q6 &lt;n_entity;q6 ++){
        id_selected[q6] = 0; 
    }
    
    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_entity;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_entity;k ++){
                    if(id_vector_entity[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
        }
    }
    for(k = 0;k &lt; n_entity; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }

    // creo il vettore dei pesi per l'entità relative al senso estratto

    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_entity; q3 ++){
            if( id_vector_entity[q3] == id_selected[q2]){
                weight_vector_entity[q2] = entity_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_entity[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_entity[q5] = weight_vector_entity[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_entity[q1] = weight_vector_entity[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){//n_selected = n_entity
        interval_vector_entity[q] = interval_vector_entity[q-1]+ interval_vector_entity[q];
    }

    while (id_trovato == true)
    {
        if (numero_random &lt;= interval_vector_entity[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
    return id_extracted;
}


    // definizione esterna per il problema che mi da metterli dentro
    double weight_vector_event[n_event];
    double  interval_vector_event[n_event];
// FUNCTION for extraction of the event id from the entity extracted
int event_id_extraction(int sense_id_extracted, int entity_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number    
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
   // int id_selected[n_event];
    int id_selected[n_event];
    int m1 = 0;
    //double weight_vector[n_event];    
    //double weight_vector[5];
    //define the interval vector
    //double  interval_vector[n_event];
    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id ;
    int selected_vector[n_event];
    int n_dim = n_event;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_dim;q6 ++){
        id_selected[q6] = 0; 
    }

    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }


    // definisco quali sono gli eventi legate a quell'entità
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            if(SEEAO[m][1] == entity_id_extracted){
                selected_id = SEEAO[m][2]; // vettore dell'evento elativo a quell'entità, che dovrò estrarre
                //selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_dim;k ++){
                    if(id_vector_event[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
            }
        }
    }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }


    // creo il vettore dei pesi per l'entità relative al senso estratto
    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_event; q3 ++){
            if( id_vector_event[q3] == id_selected[q2]){
                weight_vector_event[q2] = event_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_event[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_event[q5] = weight_vector_event[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_event[q1] = weight_vector_event[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){
        interval_vector_event[q] = interval_vector_event[q-1]+ interval_vector_event[q];
    }
    l=0;
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_event[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
 
    return id_extracted;
}

    double weight_vector_action[n_action];
    double interval_vector_action[n_action];
// for extraction of the action from the event
int action_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_action];
    int m1 = 0;    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id;
    int n_dim = n_action;
    int selected_vector[n_action];


    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_action;q6 ++){
            id_selected[q6] = 0; 
        }
    
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso

    if(id_rows == false){// caso con la ricerca dell'azione andando per esclusione tra quelle con sense, entity and event extracted
                        // che usa l'id dell'azione nella matrice SEEAO nella posizione 3 (colonnna 4)
        for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        selected_id = SEEAO[m][3]; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        for(k =0; k&lt; n_dim;k ++){
                            if(id_vector_action[k] == selected_id){
                                selected_vector[k] = selected_vector[k] + 1;
                            }
                        }

                    }
                }
            }
        }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }



        for(q2 = 0; q2 &lt; n_selected ;q2 ++){
            for(q3 =0 ; q3 &lt; n_action; q3 ++){
                if( id_vector_action[q3] == id_selected[q2]){
                    weight_vector_action[q2] = action_weight_vector[q3];
                }
            }

        }
        // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_selected; q4 ++){
            weight_sum = weight_sum + weight_vector_action[q4];
        }
        //normalizzo i pesi 
        for(q5 = 0; q5 &lt; n_selected; q5 ++){
            weight_vector_action[q5] = weight_vector_action[q5]/weight_sum;
        }

        //interval vector initialization
        for(q1=0;q1 &lt; n_selected;q1++){
	        interval_vector_action[q1] = weight_vector_action[q1]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q = 1 ; q &lt; n_selected; q ++){
            interval_vector_action[q] = interval_vector_action[q-1]+ interval_vector_action[q];
        }
         while (id_trovato == true){
             if (numero_random &lt;= interval_vector_action[l]){
               id_extracted = id_selected[l];
               id_trovato = false;
             }
             else{
                 l ++;
             }
       }



    }
    else{// caso id_rows = true 
         for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        id_selected[j] = m; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                      //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
                        n_selected ++; 
                    }
                }
            }
        }
    }

   
    return id_extracted;
}



//function for the id of the output action--&gt; non è corretta perché l'azione estratta è definita dalla n_row 
// e non dall'id della azione

int output_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted, int action_id_extracted){
    int id_extracted = 0;
    int m = 0;
 for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){//seleziono la riga con il senso estratto
            if(SEEAO[m][1] == entity_id_extracted){//seleziono la riga con il senso e l'entità estratto
                if(SEEAO[m][2] == event_id_extracted){// seleziono la riga con il senso, entità ed evento estratto
                   if(SEEAO[m][3] == action_id_extracted){ // seleziono la riga con il senso,l'entità,l'evento,l'azione estratta
                      id_extracted = SEEAO[m][4]; // 4 th column defines the output action of the action
                    }
                }
            } 
        }
    }
  
    return id_extracted;
}


double update_stm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

double update_ltm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

int add_1(int a){
    return a + 1;
}

// funzione per la short-term memory 
void stm(){
    stm_action[stm_index] = id_action_extracted;
    stm_index = add_1(stm_index);
}

// funzione per la long-term memory
void ltm(){
    ltm_action[ltm_index] = id_action_extracted;
    ltm_index = add_1(ltm_index);
}

int stm_head ;
int stm_tail=0;
int ltm_head;
int ltm_tail=0;
int stm_deleted;
int ltm_deleted; 

int stm_full = 0;//0 -&gt;false; -1 -&gt;true to see the difference in the simulation
int ltm_full = 0;

void stm_enqueue (){
    if(stm_tail == n_stm){
        stm_full = -1; 
    }
    else{
        stm_action[stm_tail] = id_action_extracted;
        stm_tail ++;
        stm_full = 0;
    }
}

void stm_dequeue(){
    int i;
    if(stm_tail &gt; 0){
        stm_deleted = stm_action[0];
        for(i = 1; i &lt; n_stm ; i++){
            stm_action[i-1] = stm_action[i];
        }
        for(i = stm_tail ; i &lt; n_stm ; i ++){
            stm_action[i] = 0;
        }
        stm_tail --;
        
    }    
}


void ltm_enqueue (){
    if(ltm_tail == n_ltm){
        ltm_full = -1; 
    }
    else{
        ltm_action[ltm_tail] = id_action_extracted;
        ltm_tail ++;
        ltm_full = 0;
    }
}

void ltm_dequeue(){
    int i;
    if(ltm_tail &gt; 0){
        ltm_deleted = ltm_action[0];
        for(i = 1; i &lt; n_ltm ; i++){
            ltm_action[i-1] = ltm_action[i];
        }
        for(i = ltm_tail ; i &lt; n_ltm ; i ++){
            ltm_action[i] = 0;
        }
        ltm_tail --;
    }    
}



void stm_ltm(){
    double weight_lost_action_stm;
    double weight_lost_action_ltm;
    double index_random_double;
    int index_random;
    int i;
    
    int action_removed;
      if(caso_stm_ltm == 0){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm
    } // not case 0
  // possibility to lose an action in the stm or in the ltm 
    if(caso_stm_ltm == 1){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm

        // in stm 
            weight_stm = update_stm_weight();
        if(random(N_random)+1 &lt;= weight_stm ){
          //define the index extracted to remove the action
            index_random_double = random(stm_index+1); // aggiunto l'uno per evitare il problema di random(0)
            index_random = fint(index_random_double);
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(random(stm_index+1)); // from zero to index_stm
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_stm -1; i ++){
                stm_action[i] = stm_action[i+1];
            }
          // reduce the stm_index of 1
            if(stm_index &gt;= 1){ // aggiunto il controllo per evitare il caso stm_index = -1 allo step dopo
                stm_index = stm_index -1;
            }
        }

        // in ltm 
            weight_ltm = update_ltm_weight();
        if(random(N_random)+1 &lt;= weight_ltm ){
          //define the index extracted to remove the action
            index_random_double =random(ltm_index); 
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(index_random_double); // from zero to index_stm-1
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_ltm -1; i ++){
                ltm_action[i] = ltm_action[i+1];
            }
          // reduce the ltm_index of 1
            if (ltm_index &gt;=1){
                ltm_index = ltm_index -1;
            }
        }
    }
    // else no loss of memory

   
  // memoria che si aggiorna in in modo FIFO
    if(caso_stm_ltm == 2){
    // caso per stm
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_enqueue();
        }
        
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_dequeue();
        }
    // caso per ltm
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_enqueue();
        }
        
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_dequeue();
        }
        
    }
    if (caso_stm_ltm == 3){
        if(stm_tail == n_stm){
            stm_dequeue();
            stm_enqueue();
        }
        else{
            stm_enqueue();
        }

        if(ltm_tail == n_ltm){
            ltm_dequeue();
            ltm_enqueue();
        }
        else{
            ltm_enqueue();
        }
    }    
 
}



    double weight_vector_output[n_output];
    double interval_vector_output[n_output];
// funzione per come vado ad assegnare il last_id
void assignment_last_id(){
    int q4;
    int l;
    double weight_sum = 0.0;
    double numero_random = random(N_random)+1;
    bool id_trovato = false;
    int id_extracted;

  //
    // caso 0
    if(caso_last_id ==0){
        last_id_extracted_output = last_id_extracted_output;
        // so che non è necessario ma è solo per avere chiaro i vari casi, posso anche levarlo
    }
  // assegnazione stesso peso per ogni output 
    for(q4=0;q4&lt;n_output;q4++){
        weight_vector_output[q4] = 1;
    }
  // cicli per l'estrazione del last id in modo randomico ad ogni ciclo
    if(caso_last_id == 1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    } 

    //caso 2
    /*
        – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; 
    */

    if (caso_last_id == 2 &amp;&amp; index_cycle &lt;=1){
       last_id_extracted_output = last_id_extracted_output;
        //sembra un po contorta come assegnazione ma rispetto a quella precedente questa avviene solo 
        // al primo avvio del programma, ovvero solo nel caso in cui gli event sono tutti zero all'inizio
        // quando è già avviato la last_id_extracted_outpput = id_output_extracted assumento che venga estratta 
        // se non viene estratta rimarrà sempre uguale a quella iniziale
    }

    if (caso_last_id == 3 &amp;&amp; index_cycle &lt;=1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    }

}

//assignment
 bool event_all_zero = true;
//unica funzione che fa tutto quello che il modello cmpct fa
int out_id_ref(){
    int id_extracted_output;
    int j = 0;
    event_all_zero = true;//to set at all the call of this function the doubt to have all event = zero
   // index_cycle ++;
   // set_to_zero();
// update the position of the dynamic objects
        upd_obj_dyn_pos();
    // per avere che gli id vector siano dipendenti dal numero di entità, sense etc.... presenti
    id_initialization();
  // funzione per definire il valore della last_id a tempo zero
    assignment_last_id();
  // funzione per modificare il vettore degli eventi che potrebbero succedere 
    update_event_may_happen();
  // controllo che almeno un evento sia diverso da zero 
    while(event_all_zero == true and j &lt; n_event){
        if(event_may_happen[j]==1){
            event_all_zero = false;
        }
        j++;
    }
    if(event_all_zero == false){
      
      // funzione per l'update dei weights
        update_weight();
      // funzione per l'estrazione del senso 
        id_sense_extracted = sense_id_extraction();
      // funzione per l'estrazione dell'entità
        id_entity_extracted = entity_id_extraction(id_sense_extracted);
      // funzione per l'estrazione dell'evento
        id_event_extracted = event_id_extraction(id_sense_extracted, id_entity_extracted);
      // funzione per l'estrazione dell'azione
        id_action_extracted = action_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted);
      // funzionne per l'estrazione dell output finale
        id_extracted_output= output_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted, id_action_extracted);
        last_id_extracted_output = id_extracted_output;
      // funzione per li modulo stm and ltm
        stm_ltm();
        }
    else{
         // in questo caso solo per vedere se funziona, nel modello protrebbe essere
          id_extracted_output = last_id_extracted_output; // in questo caso è zero
        // id_extracted_output = 6;   
        }
return id_extracted_output;
}

int next_time = n_delay_index;
int n_extraction = 0;
int extraction_new = 0; 
int last_id_extracted_tmp = 0; // inserito per fare in modo che nel caso_deelay == 1 l'estrazione sia uguale alla precedente
                               // messa fuori perchè dentro viene definita = 0 ad ogni ciclo e quindi si blocca 
                               // il modello  
// funzione che viene usata e poi 
int out_id(){
    int id_extracted_output;
    index_cycle ++;
    if(caso_delay==0){
        id_extracted_output = out_id_ref();
        extraction_new = 1;
    }

    if(caso_delay==1){
        if(index_cycle&lt;=1||index_cycle%n_delay_index ==0){//devo fare l'estrazione almeno una volta
            id_extracted_output = out_id_ref();
            extraction_new = 1;
            last_id_extracted_tmp = id_extracted_output;
        }
       else{
        extraction_new = 0;
        id_extracted_output = last_id_extracted_tmp;
      }
    }
    else if(caso_delay ==2){
                if(index_cycle&lt;=1||fint(x)%n_delay_index ==0){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    } 
            }
    else if(caso_delay ==3){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index*n_extraction){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==4){
                if(index_cycle&lt;=1||fint(x)&gt;=next_time){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    next_time = fint(x) + n_delay_index;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==5){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    x = 0.0;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }

return id_extracted_output;
}

////////////////////////////////////////////////
</declaration>
		<location id="id0" x="-390" y="-255">
			<name x="-425" y="-246">idle</name>
			<label kind="invariant" x="-467" y="-229">Fp'==0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id1" x="365" y="-255">
			<name x="357" y="-289">busy</name>
			<label kind="invariant" x="356" y="-374">Fp'==0
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id2" x="-585" y="-254">
			<name x="-628" y="-271">Init</name>
			<committed/>
		</location>
		<location id="id3" x="518" y="-255">
			<name x="535" y="-272">passed_out</name>
			<label kind="invariant" x="535" y="-255">t' == 0 &amp;&amp;
F' == 0</label>
			<label kind="exponentialrate" x="510" y="-238">1</label>
		</location>
		<location id="id4" x="-127" y="-357">
			<name x="-127" y="-391">c1</name>
			<committed/>
		</location>
		<location id="id5" x="136" y="-17">
			<name x="144" y="-51">c3</name>
			<committed/>
		</location>
		<location id="id6" x="221" y="-357">
			<name x="238" y="-382">c2</name>
			<committed/>
		</location>
		<location id="id7" x="-390" y="-476">
			<name x="-400" y="-510">p_2</name>
			<committed/>
		</location>
		<location id="id8" x="365" y="-34">
			<name x="355" y="-68">p_4</name>
			<committed/>
		</location>
		<location id="id9" x="-390" y="-366">
			<name x="-400" y="-400">p_1</name>
			<committed/>
		</location>
		<location id="id10" x="365" y="-119">
			<name x="355" y="-153">p_3</name>
			<committed/>
		</location>
		<location id="id11" x="-42" y="-263">
			<name x="-68" y="-255">d_2</name>
			<committed/>
		</location>
		<location id="id12" x="-51" y="-102">
			<name x="-61" y="-136">d_4</name>
			<committed/>
		</location>
		<location id="id13" x="-51" y="144">
			<name x="-43" y="110">d_5</name>
			<committed/>
		</location>
		<location id="id14" x="-34" y="-493">
			<name x="-44" y="-527">d_6</name>
			<committed/>
		</location>
		<init ref="id2"/>
		<transition color="#0000ff">
			<source ref="id14"/>
			<target ref="id0"/>
			<label kind="guard" x="-348" y="-714">id_out == id_sit</label>
			<nail x="-289" y="-688"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id14"/>
			<target ref="id0"/>
			<label kind="guard" x="-314" y="-621">id_out == id_stand</label>
			<nail x="-255" y="-604"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id14"/>
			<target ref="id6"/>
			<label kind="guard" x="161" y="-697">id_out == id_walk</label>
			<label kind="assignment" x="-16" y="-578">t = 0, tUpd=0</label>
			<nail x="221" y="-663"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id14"/>
			<target ref="id6"/>
			<label kind="guard" x="34" y="-519">id_out== id_run</label>
			<label kind="assignment" x="-16" y="-493">t = 0, tUpd=0</label>
			<nail x="204" y="-493"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id13"/>
			<target ref="id1"/>
			<label kind="guard" x="102" y="238">id_out ==id_run</label>
			<nail x="170" y="238"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id13"/>
			<target ref="id1"/>
			<label kind="guard" x="272" y="314">id_out == id_walk</label>
			<nail x="255" y="357"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id13"/>
			<target ref="id0"/>
			<label kind="guard" x="-408" y="323">id_out == id_sit</label>
			<label kind="assignment" x="-459" y="238">t = 0, Fp = F,
tUpd=0</label>
			<nail x="-340" y="306"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id12"/>
			<target ref="id0"/>
			<label kind="guard" x="-297" y="-110">id_out == id_sit</label>
			<label kind="assignment" x="-204" y="-93">t = 0, Fp=F, 
tUpd=0</label>
			<nail x="-280" y="-119"/>
			<nail x="-280" y="-119"/>
		</transition>
		<transition color="#0000ff">
			<source ref="id12"/>
			<target ref="id0"/>
			<label kind="guard" x="-289" y="-153">id_out == id_stand</label>
			<label kind="assignment" x="-127" y="-204">t = 0, Fp=F, 
tUpd=0</label>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id12"/>
			<target ref="id1"/>
			<label kind="guard" x="34" y="-153">id_out == id_walk</label>
			<nail x="119" y="-204"/>
			<nail x="119" y="-204"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id12"/>
			<target ref="id1"/>
			<label kind="guard" x="-8" y="-195">id_out == id_run</label>
		</transition>
		<transition color="#ffa500">
			<source ref="id11"/>
			<target ref="id0"/>
			<label kind="guard" x="-255" y="-229">id_out == id_sit</label>
			<nail x="-255" y="-238"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id11"/>
			<target ref="id6"/>
			<label kind="guard" x="-34" y="-331">id_out == id_walk</label>
			<label kind="assignment" x="51" y="-365">t = 0, 
tUpd=0</label>
		</transition>
		<transition color="#0000ff">
			<source ref="id11"/>
			<target ref="id0"/>
			<label kind="guard" x="-306" y="-297">id_out == id_stand</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id5"/>
			<label kind="guard" x="143" y="-117">served[id-1]</label>
			<nail x="245" y="-100"/>
			<nail x="134" y="-100"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id1"/>
			<label kind="guard" x="280" y="-119">currH!=id</label>
			<nail x="322" y="-136"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id0"/>
			<label kind="guard" x="-339" y="-391">currH!=id</label>
			<nail x="-339" y="-374"/>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="356" y="-178">publish_m[4]!</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id10"/>
			<label kind="guard" x="339" y="-102">currH==id</label>
			<label kind="synchronisation" x="314" y="-85">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-390" y="-327">publish_m[4]!</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-390" y="-455">currH==id</label>
			<label kind="synchronisation" x="-390" y="-425">publish_m[3]!</label>
		</transition>
		<transition color="#00ff00">
			<source ref="id1"/>
			<target ref="id8"/>
			<label kind="guard" x="416" y="-162">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="416" y="-145">updateF(-lambda, 1),
updateP(), tUpd=0,
id_out = out_id()</label>
			<nail x="416" y="-145"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id0"/>
			<target ref="id7"/>
			<label kind="guard" x="-527" y="-382">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-535" y="-357">updateF(-mi, 0), 
tUpd=0, 
id_out = out_id()</label>
			<nail x="-442" y="-399"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id14"/>
			<label kind="guard" x="-263" y="-536">!served[id-1]</label>
			<nail x="-263" y="-494"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id1"/>
			<label kind="guard" x="178" y="-289">F&lt;=0</label>
			<label kind="assignment" x="178" y="-272">Fp=1,
plan_traj(),
F = 0</label>
			<nail x="221" y="-255"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id1"/>
			<label kind="guard" x="238" y="-357">F&gt;0</label>
			<label kind="assignment" x="237" y="-340">Fp=1-F,
plan_traj()</label>
			<nail x="289" y="-357"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id13"/>
			<label kind="guard" x="17" y="102">served[id-1] ||(!served[id-1])</label>
			<nail x="127" y="42"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id5"/>
			<target ref="id12"/>
			<label kind="assignment" x="-187" y="-17">id_out = out_id()</label>
			<nail x="-51" y="-17"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="143" y="-92">stop_h_action?</label>
			<nail x="314" y="-170"/>
			<nail x="136" y="-119"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="guard" x="-238" y="-348">currH==id</label>
			<label kind="synchronisation" x="-246" y="-374">start_h_action?</label>
			<nail x="-263" y="-357"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id4"/>
			<target ref="id11"/>
			<label kind="assignment" x="-85" y="-382">id_out = out_id()</label>
			<nail x="-42" y="-357"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="383" y="-272">F &gt;= passout_th</label>
			<label kind="synchronisation" x="408" y="-255">h_fail!</label>
			<label kind="assignment" x="459" y="-238">t = 0</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id3"/>
			<nail x="493" y="-204"/>
			<nail x="535" y="-204"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="assignment" x="-586" y="-229">initHuman(),
id_out = out_id()</label>
		</transition>
		<transition color="#00ffff">
			<source ref="id11"/>
			<target ref="id6"/>
			<label kind="guard" x="-17" y="-246">id_out == id_run</label>
			<label kind="assignment" x="51" y="-280">t = 0, 
tUpd=0</label>
			<nail x="136" y="-289"/>
		</transition>
		<transition color="#0000ff">
			<source ref="id13"/>
			<target ref="id0"/>
			<label kind="guard" x="-306" y="153">id_out == id_stand</label>
			<label kind="assignment" x="-314" y="178">t = 0, Fp = F,
tUpd=0</label>
			<nail x="-255" y="144"/>
		</transition>
	
</template>

<template>
		<name>Human_Leader</name>
		<parameter>int id, double _v, int p_f, int p_fw, int start_from, int path,const double arg[n_arg_all],const int arg_ad[nr_argAd], const int SEEAO[nr_seeao_max][nc_seeao], const double importance_entity[nr_impEntity_max], const double importance_sense[nr_impSense_max], const double obj_xye[nr_obj_max][nc_obj]</parameter>
		<declaration>

clock t, F, Fp;
clock tUpd;
clock tExp;

double lambda, mi;
const double passout_th = 1.0;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

// Fatigue Sharing Parameters
bool DO_START = true;
bool ONCE_FTG = true;
bool ONCE_POS = true;

int v;

// Position Sharing Parameters
bool access() {
    return true;
}

void updateF(double coeff, bool walking) {
    // if two human instances are the same person,
    // residual conditions must be retrieved
    if (ONCE_FTG &amp;&amp; start_from!=-1 &amp;&amp; currH==id) {
        F = internalFatigue[start_from-1];
        Fp = F;
        internalFatigue[id-1] = F;
        ONCE_FTG = false;
    }

    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        if(neigh[0]==-1) return;
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    // same as ONCE_FTG
    if (ONCE_POS &amp;&amp; start_from!=-1) {
        humanPositionX[id-1] = internalHumX[start_from-1];
        humanPositionY[id-1] = internalHumY[start_from-1];
        internalHumX[id-1] = humanPositionX[id-1];
        internalHumY[id-1] = humanPositionY[id-1];
        ONCE_POS = false;
    }

    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    fw=0;
    plan_traj();
    DO_START = false;
}

double dist_to_dest;
double humanRobotDist;
void checkSuccess() {
    dist_to_dest = pt_dist(destX[id-1], internalHumX[id-1], destY[id-1], internalHumY[id-1]);
    humanRobotDist = calculateDistance();
    // when humans reach their destination, they can set themselves as "served"
    if(dist_to_dest &lt;= v*3.0 &amp;&amp; humanRobotDist&lt;=5.0) {
        served[id-1] = true;
    }
}

void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void check_crit(){
     double humanRobotDist = calculateDistance();
     if(currH!=id || served[id-1]) return;
     if(humanRobotDist&lt;=0.5) collisions++;

     if(is_crit) v = fint(_v*0.6);
     else v = fint(_v);
}

double crit_prob;
void update_crit() {
    double dice = random(100);
    crit_prob = 1-exp(-lambda_crit*t);

    if(dice&lt;=crit_prob*100) {
        is_crit = false;
        v = fint(_v);
    }
}

void initHuman() {
    double dist_to_dest;
    ERR_PROF error_profile;

    F = 0;
    Fp = 0;
    t = 0;
    v = fint(_v);

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
        dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
        dist_to_dest = pt_dist(startX_alt1[id-1], destX_alt1[id-1], startY_alt1[id-1], destY_alt1[id-1]);
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
        dist_to_dest = pt_dist(startX_alt2[id-1], destX_alt2[id-1], startY_alt2[id-1], destY_alt2[id-1]);
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    // unfortunately the switch case is not supported yet
    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    } else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    if(_v&gt;50.0)
        TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    else TE = 999;
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}
////////////////////////////////////////////////
//extraction declaration code
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

/*
h_b_ultra_cmpc_v1
modello che fa le stesse cose di quello cmpct con una sola funzione

variabili: 
- vettore dei pesi degli eventi
- vettore dei pesi delle azioni
- vettore dei pesi dei sensi
- SEAAO: matrice che lega tutti gli elementi Sense-Entity-Event-Action-Output,
 da n righe = numero di azioni e 5 colonne.
-n_eventi,n_action,n_sense,n_entity
remember: 
- lenght_interval_vector = length_of the id vector, so when we call that function we can use instead of it n_sense, 
n_action, n_events
- lego in modo univoco l'id del senso,dell'evento, dell'entity, e dell'azione finale e dell'output.
- ogni elemento ha il suo id, in modo da aggiornare più facilmente i pesi, che sono univoci rispetto a all'elemento.
*/

    bool id_rows = false; // true NON ANCORA IMPLEMENTATO
                      //per utilizzare la ricerca dell'azione usando la riga =&gt; riga = id azione --&gt;semplifica la ricerca della
                     //outuput id SEAAO [n_riga][4]   
                    // false IMPLEMENTATO 
                    //per avere l'id dell'azione nella matrice e non dato dalla riga --&gt; output dato da selezione 
                    // della riga in base a senso- entità- evento- azione 



    int i,j,k,o,i1,i2,i3,i4,i5,i6,j1,j2,j3,j4; // indexes for the for loops

    const int N_interval = 101; // number for the scale of the the interval vector
    const int N_random = 100; // number to define the scale of the probability
    // li ho settati diversi (dovrebbero essere uguali) perchè è la strada più veloce
    // che mi ha aiutato nel capire che c'è un caso particolare che mi da out of range
    // ho già pensato come risolverlo, lo sto facendo in una versione 1 di questo, per 
    // non mischiare
    // c’è un problema (se N_interval = N_random)
    //quando la somma dei pesi fa tipo 99 e il numero random 
    //che esce è 100, dato che il valore che nell’interval vector non c’è si 
    //ha out of range


    const double upd_weight = arg[0];
    const int caso_upd_weight = fint(arg[1]);
        /*
            * 0 -&gt; nulla
            * 1 -&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm ad ogni ciclo
            * 2--&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm  RANDOMATICAMENTE
        */
    const double stm_weight = arg[2];
    const double ltm_weight = arg[3];
    const int caso_weight_entity = fint(arg[4]);
        /*
            0- nothing; the entity has weight equal to 1;
            1- every entity has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
    const int caso_weight_sense = fint(arg[5]);
          /*
            0- nothing; the sense has weight equal to 1;
            1- every sense has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
  

    // per settare come avviene la modifica del vettore event may happen
    const int caso_event = fint(arg[6]);
        /*
        il vettore event_may_happen diventa 
        0 - uguale a quello initilizzato
        1 - randomico
        2 - in base alla distanza dell'entità con l'umano 
    */ 
    
    const int caso_delay = fint(arg[7]);
        /*
            0- nulla, l'id viene estratto ad ogni chiamata della funzione out_id()
            1- l'id viene estratto ogni n index value 
        */
    const int n_delay_index = fint(arg[8]);
  // ho tolto la costante per fare in modo che le distanze posssano essere cambiate
   // variabili per il valore iniziale (dunque precedente) dell'ultima azione fatta dall'umano
  // è da fare in modo che non sia pari a zero, perchè c'è la possibilità che nel caso in cui tutti i  
   int last_id_extracted_output =fint(arg[9]); // se caso 1,la metto a zero per vedere il suo primo valore
    const int caso_last_id = fint(arg[10]);
    /*
     se 0 - quella iniziale è pari a quella settata sopra ad OGNI ciclo
    se 1 - selezionata randomicamente tra 1 e 4 / n ad OGNI ciclo
    se 2 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
            quando index_cicli &gt; 1 con index_cicli di partenza  = 0;  SOLO per la prima
    se 3 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; ma randomica la scelta di initial_id SOLO per 
        la prima
    */

    const int caso_obj = fint(arg[11]);
    /*
     * 0 -&gt; oggetti fissi secondo la matrice obj_xye
     * 1 -&gt; oggetti che randomicamente cambiano posizione e sono vicini all'umano
     * 2 -&gt; un oggetto, quello selezionato cambia posizione (vicino all'umano), gli altri sono fissi    
    */
    const int obj_selected = fint(arg[12]); 
    // distance treshold
    const double distance_threshold = arg[13];
   // variabili per le funzioni sulla stm and ltm 
    const int caso_stm_ltm = fint(arg[14]);
    /*
    se 0 - parte della perdita di memoria non attiva 
    se 1 - parte della perdita di memoria randomica attiva
    se 2 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) in modo randomico
    se 3 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) quando è piena inizia ad eliminare il primo
    */
    const int n_stm = fint(arg[15]); //massime azioni che si possono memorizzare // se 2 =&gt; n-1 elementi salvati
    const int n_ltm = fint(arg[16]); // posto a 6--&gt; non coincida con id_Action_max = 5 (per la simulazione)
    


    
//////////////////////////////////////////////////////////

//id_entity
const int id_robot=fint(arg[17]);


//id_output
const int id_walk=fint(arg[18]);
const int id_sit=fint(arg[19]);
const int id_run=fint(arg[20]);
const int id_stand=fint(arg[21]);



/////////////////////
const int n_rows = arg_ad[0];
const int n_columns = nc_seeao; //definita a livello globale arg_ad[1]; //5;

const int n_sense=arg_ad[1];//3;
const int n_entity=arg_ad[2];//11;
const int n_event=arg_ad[3];//18;
const int n_action=arg_ad[4];//20;
const int n_output=arg_ad[5];//4;


////////////////////////////////////////
  
  // number of objects in the environment
    // const int n_objects= 5;
 // matrix for the object
   /*
       	N righe = N oggetti 
       	colonna 1 : x-&gt; double
       	colonna 2 : y double 
       	colonna 3 : tipo entità  int (poi tramite conversione double -&gt; int con int = fint(double)) 
   */
const int nr_obj =arg_ad[6];// 7;
//const int nc_obj = 3;//definita a livello globale
double obj_xye_tmp[nr_obj][nc_obj];  
 // altro 
    clock x;

const int nr_obj_dyn = R;// nel Dpa è definita da R
const int nc_obj_dyn = nc_obj; // definita a livello globale
double distance_obj_dyn[nr_obj_dyn];
double obj_xye_dyn[nr_obj_dyn][nc_obj_dyn] ={{0.0,0.0,0.0}};
//int id_robot = 1;

const int nr_object = nr_obj + nr_obj_dyn;

/////////////////////////////////////////////////


//sense importance matrix
//const int n_sense_tot = 5;//in questo momento non ho trovato il modo di legare le info della SEEAO
                          // e questa in cpp, dunque li considero tutti i pesi dei sensi pur sapendo 
                          // che solo i primi 3 vengono usati.
///*
//sense importance matrix
const int n_sense_tot = nr_impSense_max;//definita al livello globale



//entity importance matrix

// in questo momento li posso assegnare in modo con id crescente
    int id_vector_sense[n_sense];
    int id_vector_event[n_event];
    int id_vector_entity[n_entity];
    int id_vector_action[n_action];
    int id_vector_output[n_output];

void init_obj_xye_tmp(int nr, int nc){
        int i = 0;
        int j = 0; 
        for(i  = 0; i &lt; nr; i ++){
            for(j = 0; j &lt; nc; j++){
                obj_xye_tmp[i][j] = obj_xye[i][j];     
            }
        }
    }
    
void id_initialization(){
    for(j1 =0 ; j1&lt;n_sense;j1++){
        id_vector_sense[j1] = j1+1;
    }
    for( j2 =0 ; j2&lt;n_event;j2++){
        id_vector_event[j2] = j2+1;
    }
    for( j3 =0 ; j3&lt;n_action;j3++){
        id_vector_action[j3] = j3+1;
    }
    for( j4 =0 ; j4&lt;n_entity;j4++){
        id_vector_entity[j4] = j4+1;
    }
    for( j4 =0 ; j4&lt;n_output;j4++){
        id_vector_output[j4] = j4+1;
    }

}

void set_to_zero(){//function toset to zero the value of the vectors and the other elements
                    // that are needed to be set to zero 


    }
 


  //matrix for the hb model
 // variabili per la funzione update_weight  
  //variabili per il i pesi dei diversi elementi presenti nel modello
    double action_weight_vector[n_action];//ora si modificano in base agli eventi 
    double sense_weight_vector[n_sense];
    double event_weight_vector[n_event];
    double entity_weight_vector[n_entity];

//variabili per la funzione update_event_may_happen
    int event_may_happen[n_event] ;// {1,1,0,0,1}; // 1 if yes, 0 if no.// it can be modified

    double weight_stm;
    double weight_ltm;
    int stm_action[n_stm];//vettore per memorizzare n_stm output_action
    int ltm_action[n_ltm];
    int stm_index = 0;
    int ltm_index =0;


// variable to count the nnumber of the model iterations over the time
    int index_cycle = 0;


  // variables to memorize the id's extracted
    int id_sense_extracted;
    int id_entity_extracted;
    int id_event_extracted;
    int id_action_extracted;
   // int id_output_extracted;
    int id_out;
    int last_output_id;
    int id_entity;
    int id_sense;
    int id_event;
    int id_action;
  
  
double distance[nr_obj];

void upd_obj_dyn_pos(){
    int i;
    for(i =0 ; i &lt; R; i++){
        obj_xye_dyn[i][0] =robPositionX[i];
        obj_xye_dyn[i][1] =robPositionY[i];
        obj_xye_dyn[i][2] =id_robot;
    }
}

int event_from_entity[n_event];
int id_object;
int neigh[nr_object];
double pos_human;
double pos_object;
// funzione che modifica il event may happen
void update_event_may_happen(){
    int g =0;
    int event_id;
    double numero_random_mh;
    int i;
    int j; 
    int k; 
    double k_th = 0.90;
    double d_th = distance_threshold*k_th; 
    
  // il caso_event definisce se il vettore event_may_happen rimane come fissato(0) o è randomico (=1)
    if(caso_event == 1){
        // associa randomicamente 0(non succede) 1(succede)
        for(g=0; g&lt; n_event; g++){
            numero_random_mh = random(100)+1;
            if(numero_random_mh &lt;= 50){
                event_may_happen[g] = 1;
            }
            else{
                event_may_happen[g] = 0;
            }
        }
    }
    else if(caso_event == 2){
    // initializzo il vettore event_may_happen a zero per fare in modo che poi cambia
    // e non avere problemi che diventino tutti uno 
        for(i = 0; i &lt; n_event; i ++){
            event_may_happen[i] = 0;
        }
        // faccio lo stesso per il vettore event_from_entity per averlo nullo al prossimo ciclo
        // e non dipendente dal ciclo precedente
        for(i = 0; i &lt; n_event; i ++){
            event_from_entity [i] = 0;
        }
      //+ popolo il vettore neighbour per oggetti statici
        for(i = 0; i &lt; nr_obj; i ++){
          //+ verifico la distanza tra entità ed umano
        // ora lo faccio in modo randomico poi posso usare le struct in cui un oggetto
        // è definito da  : object(id,x,y)
            //pos_object = random(N_random)+ 1;
            //pos_human = random(N_random) + 1;
            //pos_object = 4.0;
            //pos_human =3.0;

        // caso 1 della funzione
            init_obj_xye_tmp(nr_obj,nc_obj);
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_tmp[i][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[i][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_tmp[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance[i] = pt_dist(humanPositionX[id -1],obj_xye[i][0],humanPositionY[id -1],obj_xye[i][1]);
        // verifica della condizione sulla distanza 
            if( distance[i] &lt;= distance_threshold){
                id_object =fint(obj_xye[i][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
        
         j = 0;// perchè non faccio più riferimento alla matrice statica ma a quella dynamica che ha 
               // parte da zero come indice e non parte dall'indice finale di quella statica
               // lo faccio soptrattutto per evitare errore di indici perchè accederei a parti della matrice
               // che non esiste
        //+ popolo il vettore neighbour per oggetti dinamici dalla fine degli oggetti statici al numero totale di oggetti
        for(i = nr_obj; i &lt; nr_object; i ++){ // parto da nr_obj perchè il vettore neigh non lo divido tra dinamico
                                              // e statico ma ne mantengo uno solo con dentro sia gli oggetti statici
                                              // che dinamici
        // caso 1 della funzione
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_dyn[j][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[j][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_dyn[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance_obj_dyn[j] = pt_dist(humanPositionX[id -1],obj_xye_dyn[j][0],humanPositionY[id -1],obj_xye_dyn[j][1]);
        // verifica della condizione sulla distanza 
            if( distance_obj_dyn[j] &lt;= distance_threshold){
                id_object =fint(obj_xye_dyn[j][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
      //+ scorro la matrice per associare al vettore event_may_happen il valore 1 per l'entità
      // che rientra nel neighbour
        for(j = 0; j &lt; nr_object; j ++){  
        // scorro la matrice  
            for(i = 0; i &lt; n_rows; i++){
             // trovando l'entità che è nel neighbour of the human
                if(SEEAO[i][1] == neigh[j]){
               // prendo l'evento relativo a quell'entità
                    event_id = SEEAO[i][2];
                // faccio scorrere il vettore degli eventi per attivarli o meno
                    for(k = 0; k &lt; n_event; k++){
                // se trovo un id nel vettore degli id degli eventi uguali, dato che 
                // il vettore event_may_happen ha le stesse celle di quello dell'id_vector
                // prendendo l'indice dell'id_vector event posso porre event_may_happen[k] = 1
                        if(event_id ==id_vector_event[k]){
                           // event_may_happen[k] = 1;
                            
                            // altrimenti posso contare le ricorrenze degli eventi e poi
                            // porre event_may_happen a 1 quando il valore in un vettore che conta 
                            // le ricorrenze è maggiore di zero e gli altri a zero 
                            event_from_entity[k] = event_from_entity[k]+1;
                        }
                    }
                }
            }
        }
        
        // in questo caso l' inizializzazione del vettore event_may_happen non interessa
    // dato che qui vi assegno  ed 1, devo farlo però per il vettore event_from_entity
        for(k = 0; k&lt; n_event; k ++){
            if(event_from_entity[k]&gt;0){
                event_may_happen[k] = 1;
            }
            else{
                event_may_happen[k] = 0;
            }
        }
    }   
}

    //definition of the variable to be used in the update_weight function 
    //defined outside to look what happens over the time for their values
    double event_weight_sum = 0.0;
    double entity_weight_sum = 0.0;
    double sense_weight_sum = 0.0;
    double action_weight_sum = 0.0;

void update_weight(){//funzione per l'update dei pesi     
    int i1=0;
    int o1 = 0;
    // annullare la somma ad ogni inizio della funzione
    event_weight_sum = 0.0;
    entity_weight_sum = 0.0;
    sense_weight_sum = 0.0;
    action_weight_sum = 0.0;
    // setto i vettori dei pesi = 0; mi serve per l'estrazione poi
    for(i1 =0;i1 &lt;n_sense;i1++){
        sense_weight_vector[i1]= 0;
    } 
    i1=0;
    for(i1 =0;i1 &lt;n_entity;i1++){
        entity_weight_vector[i1]= 0;
    }
    i1 =0;    
    for(i1 =0;i1 &lt;n_event;i1++){
        event_weight_vector[i1]= 0;
    }  
    i1 =0;    
    for(i1 =0;i1 &lt;n_action;i1++){
        action_weight_vector[i1]= 0;
    }     
    

    // dal vettore degli eventi che possono succedere definisco quali sono le entità e sensi relativi 
    for(i = 0; i &lt; n_event; i ++){
        if(event_may_happen[i] == 1){
            // definisco l'id dell'evento
                id_event = id_vector_event[i];
                // ricerco nella matrice SEEAO gli eventi con l'id dell'evento che mi interessa, muovendomi lungo le azioni
                for(j= 0; j &lt; n_rows;j ++){
                    if(SEEAO[j][2]==id_event){
                         // assegno gli id_entity ed sense presi dalla matrice nella posizione che  id = id_event
                             id_entity = SEEAO[j][1];
                             id_sense = SEEAO[j][0];
                             id_action = SEEAO[j][3];
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi dell'entità
                            if(caso_weight_entity ==1){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + importance_entity[k];
                                    }
                                }
                            }
                            else if(caso_weight_entity==0){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + 1.00;
                                    }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi per i sense
                            if(caso_weight_sense==1){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] + importance_sense[o];
                                     }
                                }
                            }
                            else if(caso_weight_sense == 0){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] +1.00;
                                     }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi delle azioni
                            for( o1 = 0; o1 &lt; n_action; o1++){
                                 if(id_vector_action[o1]== id_action){
                                        action_weight_vector[o1] = action_weight_vector[o1] + 1.00;
                                        if(caso_upd_weight==1){
                                            // aggiunta pesi dalla stm
                                
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                        else if (caso_upd_weight==2 &amp;&amp; random(N_random)+1 &lt;= upd_weight){
                                            // aggiunta pesi dalla stm
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                 }
                            }

                   }            
              }

        }
    }


    //normalise the weight of the event,
    for( i1 = 0; i1 &lt; n_event; i1 ++ ){
        event_weight_sum = event_weight_sum + event_may_happen[i1];
    }
    for(i2 = 0; i2 &lt; n_event; i2++){
        event_weight_vector[i2] = event_may_happen[i2]/event_weight_sum;
    }
    //normalise the weight of the entity 
    for( i3 = 0; i3 &lt; n_entity; i3++){
        entity_weight_sum = entity_weight_sum + entity_weight_vector[i3];
    }
    for( i4 = 0; i4 &lt; n_entity; i4++){
        entity_weight_vector[i4] = entity_weight_vector[i4]/entity_weight_sum;
    }

    //normalise the weight of the sense 
    for(i5 = 0; i5 &lt; n_sense; i5++){
        sense_weight_sum = sense_weight_sum + sense_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_sense; i6++){
        sense_weight_vector[i6] = sense_weight_vector[i6]/sense_weight_sum;
    }

    // normalise the weight of the action
    for(i5 = 0; i5 &lt; n_action; i5++){
        action_weight_sum = action_weight_sum + action_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_action; i6++){
        action_weight_vector[i6] = action_weight_vector[i6]/action_weight_sum;
    }

}

    // dichirazioni per la sense_id_extraction function (messi fuori perché dentro danno problema di SCN)
    double numero_random_;
    double  interval_vector_sense[n_sense];

// for extraction of the id_sense
int sense_id_extraction(){
    double numero_random = random(N_random)+1;
    
    int q1,q;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int i1 =0;
    int id_selected[n_sense];// vettore di appoggio per i sensi selezionati
    //creare il vettore posso fare come faccio per quello dell’entità considerando solo i sensi che hanno 
    //peso diverso da zero utilizzando un vettore di appoggio per memorizzare i valori degli id di quei sensi che hanno 
    //il peso diverso da zero
    //ciclo per settare i valori del vettore di appoggio degli id = 0
    //  for(q6 = 0; q6 &lt;n_sense;q6 ++){
    //        id_selected[q6] = 0; 
    //}

    //dal vettore dei pesi dei sensi prendo solo quelli che hanno il peso diverso da 0
    //q6 =0;
    //for(i1=0; i1&lt; n_sense;i++){
      //  if(sense_weight_vector(i1)&gt;0){
        //    id_selected[q6] = id_vector_sense[i1];
          //  q6 ++;
        //}
    //}

    //interval vector initialization
    for(q1=0;q1&lt;n_sense;q1++)
    {
    	interval_vector_sense[q1] = sense_weight_vector[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_sense; q ++)//changed
    {
    interval_vector_sense[q] = interval_vector_sense[q-1]+ interval_vector_sense[q];
    }

    l=0;
    // extract the sense from the comparison between the numero random and the interval_vector components
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_sense[l]){
            id_extracted = id_vector_sense[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    } 
    return id_extracted;
}

 double  interval_vector_entity[n_entity];
 double weight_vector_entity[n_entity];//double weight_vector[n_entity];

// modo diverso dal precedente, metto a zero i pesi dell'entità non considerate, evito di usare una funzione esterna
// calcolare il numero di entità derivanti dal senso (perché non ho quell'info al tempo della compilazione)
// for extraction of the entity from the sense--------------------------------------------------
int entity_id_extraction(int sense_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_entity];// int id_selected[n_entity];
    int m1 = 0;
    int selected_id;
    int k; 
    int selected_vector[n_entity];
    //define the interval vector // dichiarazioni spostate per l'errore che danno
    //double  interval_vector[n_entity];
  
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0, comunque per non averlo uguale a non so cosa da zero
    for(q6 = 0; q6 &lt;n_entity;q6 ++){
        id_selected[q6] = 0; 
    }
    
    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_entity;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_entity;k ++){
                    if(id_vector_entity[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
        }
    }
    for(k = 0;k &lt; n_entity; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }

    // creo il vettore dei pesi per l'entità relative al senso estratto

    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_entity; q3 ++){
            if( id_vector_entity[q3] == id_selected[q2]){
                weight_vector_entity[q2] = entity_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_entity[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_entity[q5] = weight_vector_entity[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_entity[q1] = weight_vector_entity[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){//n_selected = n_entity
        interval_vector_entity[q] = interval_vector_entity[q-1]+ interval_vector_entity[q];
    }

    while (id_trovato == true)
    {
        if (numero_random &lt;= interval_vector_entity[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
    return id_extracted;
}


    // definizione esterna per il problema che mi da metterli dentro
    double weight_vector_event[n_event];
    double  interval_vector_event[n_event];
// FUNCTION for extraction of the event id from the entity extracted
int event_id_extraction(int sense_id_extracted, int entity_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number    
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
   // int id_selected[n_event];
    int id_selected[n_event];
    int m1 = 0;
    //double weight_vector[n_event];    
    //double weight_vector[5];
    //define the interval vector
    //double  interval_vector[n_event];
    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id ;
    int selected_vector[n_event];
    int n_dim = n_event;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_dim;q6 ++){
        id_selected[q6] = 0; 
    }

    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }


    // definisco quali sono gli eventi legate a quell'entità
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            if(SEEAO[m][1] == entity_id_extracted){
                selected_id = SEEAO[m][2]; // vettore dell'evento elativo a quell'entità, che dovrò estrarre
                //selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_dim;k ++){
                    if(id_vector_event[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
            }
        }
    }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }


    // creo il vettore dei pesi per l'entità relative al senso estratto
    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_event; q3 ++){
            if( id_vector_event[q3] == id_selected[q2]){
                weight_vector_event[q2] = event_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_event[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_event[q5] = weight_vector_event[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_event[q1] = weight_vector_event[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){
        interval_vector_event[q] = interval_vector_event[q-1]+ interval_vector_event[q];
    }
    l=0;
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_event[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
 
    return id_extracted;
}

    double weight_vector_action[n_action];
    double interval_vector_action[n_action];
// for extraction of the action from the event
int action_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_action];
    int m1 = 0;    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id;
    int n_dim = n_action;
    int selected_vector[n_action];


    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_action;q6 ++){
            id_selected[q6] = 0; 
        }
    
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso

    if(id_rows == false){// caso con la ricerca dell'azione andando per esclusione tra quelle con sense, entity and event extracted
                        // che usa l'id dell'azione nella matrice SEEAO nella posizione 3 (colonnna 4)
        for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        selected_id = SEEAO[m][3]; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        for(k =0; k&lt; n_dim;k ++){
                            if(id_vector_action[k] == selected_id){
                                selected_vector[k] = selected_vector[k] + 1;
                            }
                        }

                    }
                }
            }
        }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }



        for(q2 = 0; q2 &lt; n_selected ;q2 ++){
            for(q3 =0 ; q3 &lt; n_action; q3 ++){
                if( id_vector_action[q3] == id_selected[q2]){
                    weight_vector_action[q2] = action_weight_vector[q3];
                }
            }

        }
        // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_selected; q4 ++){
            weight_sum = weight_sum + weight_vector_action[q4];
        }
        //normalizzo i pesi 
        for(q5 = 0; q5 &lt; n_selected; q5 ++){
            weight_vector_action[q5] = weight_vector_action[q5]/weight_sum;
        }

        //interval vector initialization
        for(q1=0;q1 &lt; n_selected;q1++){
	        interval_vector_action[q1] = weight_vector_action[q1]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q = 1 ; q &lt; n_selected; q ++){
            interval_vector_action[q] = interval_vector_action[q-1]+ interval_vector_action[q];
        }
         while (id_trovato == true){
             if (numero_random &lt;= interval_vector_action[l]){
               id_extracted = id_selected[l];
               id_trovato = false;
             }
             else{
                 l ++;
             }
       }



    }
    else{// caso id_rows = true 
         for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        id_selected[j] = m; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                      //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
                        n_selected ++; 
                    }
                }
            }
        }
    }

   
    return id_extracted;
}



//function for the id of the output action--&gt; non è corretta perché l'azione estratta è definita dalla n_row 
// e non dall'id della azione

int output_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted, int action_id_extracted){
    int id_extracted = 0;
    int m = 0;
 for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){//seleziono la riga con il senso estratto
            if(SEEAO[m][1] == entity_id_extracted){//seleziono la riga con il senso e l'entità estratto
                if(SEEAO[m][2] == event_id_extracted){// seleziono la riga con il senso, entità ed evento estratto
                   if(SEEAO[m][3] == action_id_extracted){ // seleziono la riga con il senso,l'entità,l'evento,l'azione estratta
                      id_extracted = SEEAO[m][4]; // 4 th column defines the output action of the action
                    }
                }
            } 
        }
    }
  
    return id_extracted;
}


double update_stm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

double update_ltm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

int add_1(int a){
    return a + 1;
}

// funzione per la short-term memory 
void stm(){
    stm_action[stm_index] = id_action_extracted;
    stm_index = add_1(stm_index);
}

// funzione per la long-term memory
void ltm(){
    ltm_action[ltm_index] = id_action_extracted;
    ltm_index = add_1(ltm_index);
}

int stm_head ;
int stm_tail=0;
int ltm_head;
int ltm_tail=0;
int stm_deleted;
int ltm_deleted; 

int stm_full = 0;//0 -&gt;false; -1 -&gt;true to see the difference in the simulation
int ltm_full = 0;

void stm_enqueue (){
    if(stm_tail == n_stm){
        stm_full = -1; 
    }
    else{
        stm_action[stm_tail] = id_action_extracted;
        stm_tail ++;
        stm_full = 0;
    }
}

void stm_dequeue(){
    int i;
    if(stm_tail &gt; 0){
        stm_deleted = stm_action[0];
        for(i = 1; i &lt; n_stm ; i++){
            stm_action[i-1] = stm_action[i];
        }
        for(i = stm_tail ; i &lt; n_stm ; i ++){
            stm_action[i] = 0;
        }
        stm_tail --;
        
    }    
}


void ltm_enqueue (){
    if(ltm_tail == n_ltm){
        ltm_full = -1; 
    }
    else{
        ltm_action[ltm_tail] = id_action_extracted;
        ltm_tail ++;
        ltm_full = 0;
    }
}

void ltm_dequeue(){
    int i;
    if(ltm_tail &gt; 0){
        ltm_deleted = ltm_action[0];
        for(i = 1; i &lt; n_ltm ; i++){
            ltm_action[i-1] = ltm_action[i];
        }
        for(i = ltm_tail ; i &lt; n_ltm ; i ++){
            ltm_action[i] = 0;
        }
        ltm_tail --;
    }    
}



void stm_ltm(){
    double weight_lost_action_stm;
    double weight_lost_action_ltm;
    double index_random_double;
    int index_random;
    int i;
    
    int action_removed;
      if(caso_stm_ltm == 0){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm
    } // not case 0
  // possibility to lose an action in the stm or in the ltm 
    if(caso_stm_ltm == 1){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm

        // in stm 
            weight_stm = update_stm_weight();
        if(random(N_random)+1 &lt;= weight_stm ){
          //define the index extracted to remove the action
            index_random_double = random(stm_index+1); // aggiunto l'uno per evitare il problema di random(0)
            index_random = fint(index_random_double);
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(random(stm_index+1)); // from zero to index_stm
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_stm -1; i ++){
                stm_action[i] = stm_action[i+1];
            }
          // reduce the stm_index of 1
            if(stm_index &gt;= 1){ // aggiunto il controllo per evitare il caso stm_index = -1 allo step dopo
                stm_index = stm_index -1;
            }
        }

        // in ltm 
            weight_ltm = update_ltm_weight();
        if(random(N_random)+1 &lt;= weight_ltm ){
          //define the index extracted to remove the action
            index_random_double =random(ltm_index); 
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(index_random_double); // from zero to index_stm-1
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_ltm -1; i ++){
                ltm_action[i] = ltm_action[i+1];
            }
          // reduce the ltm_index of 1
            if (ltm_index &gt;=1){
                ltm_index = ltm_index -1;
            }
        }
    }
    // else no loss of memory

   
  // memoria che si aggiorna in in modo FIFO
    if(caso_stm_ltm == 2){
    // caso per stm
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_enqueue();
        }
        
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_dequeue();
        }
    // caso per ltm
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_enqueue();
        }
        
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_dequeue();
        }
        
    }
    if (caso_stm_ltm == 3){
        if(stm_tail == n_stm){
            stm_dequeue();
            stm_enqueue();
        }
        else{
            stm_enqueue();
        }

        if(ltm_tail == n_ltm){
            ltm_dequeue();
            ltm_enqueue();
        }
        else{
            ltm_enqueue();
        }
    }    
 
}



    double weight_vector_output[n_output];
    double interval_vector_output[n_output];
// funzione per come vado ad assegnare il last_id
void assignment_last_id(){
    int q4;
    int l;
    double weight_sum = 0.0;
    double numero_random = random(N_random)+1;
    bool id_trovato = false;
    int id_extracted;

  //
    // caso 0
    if(caso_last_id ==0){
        last_id_extracted_output = last_id_extracted_output;
        // so che non è necessario ma è solo per avere chiaro i vari casi, posso anche levarlo
    }
  // assegnazione stesso peso per ogni output 
    for(q4=0;q4&lt;n_output;q4++){
        weight_vector_output[q4] = 1;
    }
  // cicli per l'estrazione del last id in modo randomico ad ogni ciclo
    if(caso_last_id == 1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    } 

    //caso 2
    /*
        – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; 
    */

    if (caso_last_id == 2 &amp;&amp; index_cycle &lt;=1){
       last_id_extracted_output = last_id_extracted_output;
        //sembra un po contorta come assegnazione ma rispetto a quella precedente questa avviene solo 
        // al primo avvio del programma, ovvero solo nel caso in cui gli event sono tutti zero all'inizio
        // quando è già avviato la last_id_extracted_outpput = id_output_extracted assumento che venga estratta 
        // se non viene estratta rimarrà sempre uguale a quella iniziale
    }

    if (caso_last_id == 3 &amp;&amp; index_cycle &lt;=1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    }

}

//assignment
 bool event_all_zero = true;
//unica funzione che fa tutto quello che il modello cmpct fa
int out_id_ref(){
    int id_extracted_output;
    int j = 0;
    event_all_zero = true;//to set at all the call of this function the doubt to have all event = zero
   // index_cycle ++;
   // set_to_zero();
// update the position of the dynamic objects
        upd_obj_dyn_pos();
    // per avere che gli id vector siano dipendenti dal numero di entità, sense etc.... presenti
    id_initialization();
  // funzione per definire il valore della last_id a tempo zero
    assignment_last_id();
  // funzione per modificare il vettore degli eventi che potrebbero succedere 
    update_event_may_happen();
  // controllo che almeno un evento sia diverso da zero 
    while(event_all_zero == true and j &lt; n_event){
        if(event_may_happen[j]==1){
            event_all_zero = false;
        }
        j++;
    }
    if(event_all_zero == false){
      
      // funzione per l'update dei weights
        update_weight();
      // funzione per l'estrazione del senso 
        id_sense_extracted = sense_id_extraction();
      // funzione per l'estrazione dell'entità
        id_entity_extracted = entity_id_extraction(id_sense_extracted);
      // funzione per l'estrazione dell'evento
        id_event_extracted = event_id_extraction(id_sense_extracted, id_entity_extracted);
      // funzione per l'estrazione dell'azione
        id_action_extracted = action_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted);
      // funzionne per l'estrazione dell output finale
        id_extracted_output= output_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted, id_action_extracted);
        last_id_extracted_output = id_extracted_output;
      // funzione per li modulo stm and ltm
        stm_ltm();
        }
    else{
         // in questo caso solo per vedere se funziona, nel modello protrebbe essere
          id_extracted_output = last_id_extracted_output; // in questo caso è zero
        // id_extracted_output = 6;   
        }
return id_extracted_output;
}

int next_time = n_delay_index;
int n_extraction = 0;
int extraction_new = 0; 
int last_id_extracted_tmp = 0; // inserito per fare in modo che nel caso_deelay == 1 l'estrazione sia uguale alla precedente
                               // messa fuori perchè dentro viene definita = 0 ad ogni ciclo e quindi si blocca 
                               // il modello  
// funzione che viene usata e poi 
int out_id(){
    int id_extracted_output;
    index_cycle ++;
    if(caso_delay==0){
        id_extracted_output = out_id_ref();
        extraction_new = 1;
    }

    if(caso_delay==1){
        if(index_cycle&lt;=1||index_cycle%n_delay_index ==0){//devo fare l'estrazione almeno una volta
            id_extracted_output = out_id_ref();
            extraction_new = 1;
            last_id_extracted_tmp = id_extracted_output;
        }
       else{
        extraction_new = 0;
        id_extracted_output = last_id_extracted_tmp;
      }
    }
    else if(caso_delay ==2){
                if(index_cycle&lt;=1||fint(x)%n_delay_index ==0){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    } 
            }
    else if(caso_delay ==3){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index*n_extraction){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==4){
                if(index_cycle&lt;=1||fint(x)&gt;=next_time){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    next_time = fint(x) + n_delay_index;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==5){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    x = 0.0;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }

return id_extracted_output;
}

////////////////////////////////////////////////
</declaration>
<location id="id290" x="59" y="-110">
			<name x="49" y="-144">d_2</name>
			<committed/>
		</location>
		<location id="id291" x="254" y="-221">
			<name x="263" y="-255">busy</name>
			<label kind="invariant" x="263" y="-357">Fp' == 0
&amp;&amp; F &lt;= passout_th 

&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id292" x="-246" y="-110">
			<name x="-314" y="-136">stopping</name>
		</location>
		<location id="id293" x="-170" y="-348">
			<name x="-180" y="-382">d_1</name>
			<committed/>
		</location>
		<location id="id294" x="-357" y="-221">
			<name x="-399" y="-246">idle</name>
			<label kind="invariant" x="-340" y="-229">Fp' == 0
&amp;&amp; F' == -Fp*mi*exp(-mi*t)

&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id295" x="-42" y="-272">
			<name x="-52" y="-306">starting</name>
			<urgent/>
		</location>
		<location id="id296" x="-552" y="-220">
			<name x="-595" y="-237">Init</name>
			<committed/>
		</location>
		<location id="id297" x="425" y="-221">
			<name x="442" y="-238">passed_out</name>
			<label kind="invariant" x="442" y="-221">t' == 0 &amp;&amp; 
F' == 0</label>
			<label kind="exponentialrate" x="417" y="-204">1</label>
		</location>
		<location id="id298" x="255" y="-42">
			<name x="272" y="-42">checking</name>
			<committed/>
		</location>
		<location id="id299" x="-484" y="-408">
			<name x="-527" y="-416">p_2</name>
			<committed/>
		</location>
		<location id="id300" x="-357" y="-408">
			<name x="-367" y="-442">p_1</name>
			<committed/>
		</location>
		<location id="id301" x="195" y="-221">
			<name x="178" y="-255">p_4</name>
			<committed/>
		</location>
		<location id="id302" x="195" y="42">
			<name x="178" y="59">p_3</name>
			<committed/>
		</location>
		<location id="id303" x="59" y="-42">
			<name x="49" y="-76">d_3</name>
			<committed/>
		</location>
		<location id="id304" x="-450" y="-42" color="#a9a9a9">
			<name x="-552" y="-59">not_needed</name>
			<label kind="exponentialrate" x="-433" y="-51">1</label>
		</location>
		<init ref="id296"/>
		<transition color="#00ffff">
			<source ref="id303"/>
			<target ref="id291"/>
			<label kind="guard" x="127" y="-85">id_out == id_run</label>
			<nail x="221" y="-76"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id303"/>
			<target ref="id291"/>
			<label kind="guard" x="-8" y="-93">id_out == id_walk</label>
		</transition>
		<transition color="#00ffff">
			<source ref="id290"/>
			<target ref="id291"/>
			<label kind="guard" x="34" y="-161">id_out == id_run</label>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id290"/>
			<target ref="id291"/>
			<label kind="guard" x="17" y="-204">id_out == id_walk</label>
			<nail x="102" y="-178"/>
			<nail x="102" y="-178"/>
		</transition>
		<transition color="#0000ff">
			<source ref="id290"/>
			<target ref="id292"/>
			<label kind="guard" x="-170" y="-195">id_out == id_sit</label>
			<label kind="synchronisation" x="-170" y="-178">stop_h_action!</label>
			<label kind="assignment" x="-170" y="-161">hExe = 0, Fp = F</label>
			<nail x="-85" y="-178"/>
			<nail x="-85" y="-178"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id290"/>
			<target ref="id292"/>
			<label kind="guard" x="-161" y="-110">id_out == id_stand</label>
			<label kind="synchronisation" x="-161" y="-93">stop_h_action!</label>
			<label kind="assignment" x="-161" y="-76">hExe=0,Fp = F</label>
		</transition>
		<transition color="#0000ff">
			<source ref="id293"/>
			<target ref="id294"/>
			<label kind="guard" x="-255" y="-425">id_out == id_sit</label>
			<nail x="-204" y="-391"/>
			<nail x="-212" y="-382"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id293"/>
			<target ref="id294"/>
			<label kind="guard" x="-212" y="-238">id_out == id_stand</label>
			<nail x="-171" y="-234"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id293"/>
			<target ref="id295"/>
			<label kind="guard" x="-178" y="-314">id_out == id_run</label>
			<label kind="synchronisation" x="-170" y="-297">start_h_action!</label>
			<label kind="assignment" x="-161" y="-280">start_moving()</label>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id293"/>
			<target ref="id295"/>
			<label kind="guard" x="-144" y="-408">id_out == id_walk</label>
			<label kind="synchronisation" x="-136" y="-391">start_h_action!</label>
			<label kind="assignment" x="-136" y="-374">start_moving()</label>
			<nail x="-59" y="-348"/>
		</transition>
		<transition>
			<source ref="id298"/>
			<target ref="id303"/>
			<label kind="guard" x="119" y="-59">served[id-1]</label>
		</transition>
		<transition>
			<source ref="id292"/>
			<target ref="id294"/>
			<label kind="synchronisation" x="-357" y="-110">r_still?</label>
			<label kind="assignment" x="-357" y="-93">t = 0, tUpd=0</label>
			<nail x="-357" y="-110"/>
		</transition>
		<transition>
			<source ref="id291"/>
			<target ref="id290"/>
			<label kind="guard" x="93" y="-136">!served[id-1] &amp;&amp;

tUpd&lt;=Tpoll</label>
			<nail x="255" y="-110"/>
		</transition>
		<transition>
			<source ref="id300"/>
			<target ref="id294"/>
			<label kind="guard" x="-459" y="-323">currH!=id</label>
			<nail x="-416" y="-408"/>
			<nail x="-416" y="-221"/>
		</transition>
		<transition>
			<source ref="id301"/>
			<target ref="id291"/>
			<label kind="synchronisation" x="136" y="-187">publish_m[4]!</label>
			<label kind="assignment" x="136" y="-170">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id302"/>
			<target ref="id301"/>
			<label kind="synchronisation" x="136" y="-8">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id298"/>
			<target ref="id302"/>
			<label kind="guard" x="263" y="-8">!served[id-1]</label>
			<label kind="assignment" x="263" y="25">updateP(),
updateF(-lambda, 1)</label>
			<nail x="255" y="42"/>
		</transition>
		<transition>
			<source ref="id299"/>
			<target ref="id294"/>
			<label kind="synchronisation" x="-484" y="-289">publish_m[4]!</label>
			<label kind="assignment" x="-484" y="-272">tUpd=0</label>
			<nail x="-484" y="-221"/>
		</transition>
		<transition>
			<source ref="id300"/>
			<target ref="id299"/>
			<label kind="guard" x="-467" y="-450">currH==id</label>
			<label kind="synchronisation" x="-467" y="-433">publish_m[3]!</label>
		</transition>
		<transition color="#00ff00">
			<source ref="id294"/>
			<target ref="id300"/>
			<label kind="guard" x="-348" y="-391">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-348" y="-374">updateF(-mi, 0), 
tUpd=0, 
id_out = out_id()</label>
		</transition>
		<transition>
			<source ref="id295"/>
			<target ref="id291"/>
			<label kind="guard" x="34" y="-238">F==0</label>
			<label kind="assignment" x="85" y="-238">Fp=1</label>
			<nail x="-42" y="-221"/>
		</transition>
		<transition>
			<source ref="id295"/>
			<target ref="id291"/>
			<label kind="guard" x="-17" y="-289">F&gt;0</label>
			<label kind="assignment" x="17" y="-289">Fp=1-F</label>
			<nail x="255" y="-272"/>
		</transition>
		<transition>
			<source ref="id294"/>
			<target ref="id293"/>
			<label kind="guard" x="-289" y="-297">!served[id-1] 
&amp;&amp; currH == id</label>
			<nail x="-306" y="-255"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id291"/>
			<target ref="id298"/>
			<label kind="guard" x="263" y="-153">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="263" y="-136">checkSuccess(),
id_out = out_id()</label>
		</transition>
		<transition>
			<source ref="id291"/>
			<target ref="id297"/>
			<label kind="guard" x="272" y="-238">F &gt;= passout_th</label>
			<label kind="synchronisation" x="289" y="-221">h_fail!</label>
			<label kind="assignment" x="289" y="-204">t = 0, hExe = 0</label>
		</transition>
		<transition>
			<source ref="id297"/>
			<target ref="id297"/>
			<nail x="400" y="-170"/>
			<nail x="442" y="-170"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id296"/>
			<target ref="id294"/>
			<label kind="assignment" x="-535" y="-212">initHuman()
,id_out = out_id()</label>
		</transition>
		<transition color="#0000ff">
			<source ref="id303"/>
			<target ref="id292"/>
			<label kind="guard" x="-297" y="0">id_out == id_sit</label>
			<label kind="synchronisation" x="-297" y="17">stop_h_action!</label>
			<label kind="assignment" x="-297" y="34">hExe = 0, Fp = F</label>
			<nail x="-178" y="42"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id303"/>
			<target ref="id292"/>
			<label kind="guard" x="-153" y="-42">id_out == id_stand</label>
			<label kind="synchronisation" x="-153" y="-25">stop_h_action!</label>
			<label kind="assignment" x="-153" y="-8">hExe=0,Fp = F</label>
			<nail x="-144" y="-17"/>
		</transition>
		<transition>
			<source ref="id304"/>
			<target ref="id304"/>
			<nail x="-450" y="9"/>
			<nail x="-425" y="9"/>
		</transition>
		<transition>
			<source ref="id294"/>
			<target ref="id304"/>
			<label kind="guard" x="-518" y="-127">PATH!=0
            &amp;&amp; PATH!=path</label>
			<nail x="-450" y="-127"/>
		</transition>
</template>

<template>
		<name>Human_Recipient</name>
		<parameter>int id, double _v, int p_f, int p_fw, int path,const double arg[n_arg_all],const int arg_ad[nr_argAd], const int SEEAO[nr_seeao_max][nc_seeao], const double importance_entity[nr_impEntity_max], const double importance_sense[nr_impSense_max], const double obj_xye[nr_obj_max][nc_obj]</parameter>
		<declaration>

clock t, F, Fp;
clock tUpd;
clock tExp;

double lambda, mi;
const double passout_th = 1.0;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;

meta int v;

bool access() {
    return true;
}

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}

void start_moving() {
    F = 0;
    t = 0;
    tUpd=0;
    hExe = 1;
    plan_traj();
}

double dist_to_dest;
void updateP() {
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; 20.0) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;

    F = 0;
    Fp = 0;
    t = 0;
    v = fint(_v);

    tUpd = 0;
    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    }
    else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    } else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}
////////////////////////////////////////////////
//extraction declaration code
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/
/**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**//**/

/*
h_b_ultra_cmpc_v1
modello che fa le stesse cose di quello cmpct con una sola funzione

variabili: 
- vettore dei pesi degli eventi
- vettore dei pesi delle azioni
- vettore dei pesi dei sensi
- SEAAO: matrice che lega tutti gli elementi Sense-Entity-Event-Action-Output,
 da n righe = numero di azioni e 5 colonne.
-n_eventi,n_action,n_sense,n_entity
remember: 
- lenght_interval_vector = length_of the id vector, so when we call that function we can use instead of it n_sense, 
n_action, n_events
- lego in modo univoco l'id del senso,dell'evento, dell'entity, e dell'azione finale e dell'output.
- ogni elemento ha il suo id, in modo da aggiornare più facilmente i pesi, che sono univoci rispetto a all'elemento.
*/

    bool id_rows = false; // true NON ANCORA IMPLEMENTATO
                      //per utilizzare la ricerca dell'azione usando la riga =&gt; riga = id azione --&gt;semplifica la ricerca della
                     //outuput id SEAAO [n_riga][4]   
                    // false IMPLEMENTATO 
                    //per avere l'id dell'azione nella matrice e non dato dalla riga --&gt; output dato da selezione 
                    // della riga in base a senso- entità- evento- azione 



    int i,j,k,o,i1,i2,i3,i4,i5,i6,j1,j2,j3,j4; // indexes for the for loops

    const int N_interval = 101; // number for the scale of the the interval vector
    const int N_random = 100; // number to define the scale of the probability
    // li ho settati diversi (dovrebbero essere uguali) perchè è la strada più veloce
    // che mi ha aiutato nel capire che c'è un caso particolare che mi da out of range
    // ho già pensato come risolverlo, lo sto facendo in una versione 1 di questo, per 
    // non mischiare
    // c’è un problema (se N_interval = N_random)
    //quando la somma dei pesi fa tipo 99 e il numero random 
    //che esce è 100, dato che il valore che nell’interval vector non c’è si 
    //ha out of range


    const double upd_weight = arg[0];
    const int caso_upd_weight = fint(arg[1]);
        /*
            * 0 -&gt; nulla
            * 1 -&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm ad ogni ciclo
            * 2--&gt; per avere che la funzione dei pesi tenga conto delle azioni in stm e ltm  RANDOMATICAMENTE
        */
    const double stm_weight = arg[2];
    const double ltm_weight = arg[3];
    const int caso_weight_entity = fint(arg[4]);
        /*
            0- nothing; the entity has weight equal to 1;
            1- every entity has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
    const int caso_weight_sense = fint(arg[5]);
          /*
            0- nothing; the sense has weight equal to 1;
            1- every sense has a desired weight to give to them difference importance
               that weight is used to sum it into the update weight function
        */
  

    // per settare come avviene la modifica del vettore event may happen
    const int caso_event = fint(arg[6]);
        /*
        il vettore event_may_happen diventa 
        0 - uguale a quello initilizzato
        1 - randomico
        2 - in base alla distanza dell'entità con l'umano 
    */ 
    
    const int caso_delay = fint(arg[7]);
        /*
            0- nulla, l'id viene estratto ad ogni chiamata della funzione out_id()
            1- l'id viene estratto ogni n index value 
        */
    const int n_delay_index = fint(arg[8]);
  // ho tolto la costante per fare in modo che le distanze posssano essere cambiate
   // variabili per il valore iniziale (dunque precedente) dell'ultima azione fatta dall'umano
  // è da fare in modo che non sia pari a zero, perchè c'è la possibilità che nel caso in cui tutti i  
   int last_id_extracted_output =fint(arg[9]); // se caso 1,la metto a zero per vedere il suo primo valore
    const int caso_last_id = fint(arg[10]);
    /*
     se 0 - quella iniziale è pari a quella settata sopra ad OGNI ciclo
    se 1 - selezionata randomicamente tra 1 e 4 / n ad OGNI ciclo
    se 2 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
            quando index_cicli &gt; 1 con index_cicli di partenza  = 0;  SOLO per la prima
    se 3 – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; ma randomica la scelta di initial_id SOLO per 
        la prima
    */

    const int caso_obj = fint(arg[11]);
    /*
     * 0 -&gt; oggetti fissi secondo la matrice obj_xye
     * 1 -&gt; oggetti che randomicamente cambiano posizione e sono vicini all'umano
     * 2 -&gt; un oggetto, quello selezionato cambia posizione (vicino all'umano), gli altri sono fissi    
    */
    const int obj_selected = fint(arg[12]); 
    // distance treshold
    const double distance_threshold = arg[13];
   // variabili per le funzioni sulla stm and ltm 
    const int caso_stm_ltm = fint(arg[14]);
    /*
    se 0 - parte della perdita di memoria non attiva 
    se 1 - parte della perdita di memoria randomica attiva
    se 2 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) in modo randomico
    se 3 - parte della perdita di memoria in modo FIFO (enqueque - dequeue) quando è piena inizia ad eliminare il primo
    */
    const int n_stm = fint(arg[15]); //massime azioni che si possono memorizzare // se 2 =&gt; n-1 elementi salvati
    const int n_ltm = fint(arg[16]); // posto a 6--&gt; non coincida con id_Action_max = 5 (per la simulazione)
    


    
//////////////////////////////////////////////////////////

//id_entity
const int id_robot=fint(arg[17]);


//id_output
const int id_walk=fint(arg[18]);
const int id_sit=fint(arg[19]);
const int id_run=fint(arg[20]);
const int id_stand=fint(arg[21]);



/////////////////////
const int n_rows = arg_ad[0];
const int n_columns = nc_seeao; //definita a livello globale arg_ad[1]; //5;

const int n_sense=arg_ad[1];//3;
const int n_entity=arg_ad[2];//11;
const int n_event=arg_ad[3];//18;
const int n_action=arg_ad[4];//20;
const int n_output=arg_ad[5];//4;


////////////////////////////////////////
  
  // number of objects in the environment
    // const int n_objects= 5;
 // matrix for the object
   /*
       	N righe = N oggetti 
       	colonna 1 : x-&gt; double
       	colonna 2 : y double 
       	colonna 3 : tipo entità  int (poi tramite conversione double -&gt; int con int = fint(double)) 
   */
const int nr_obj =arg_ad[6];// 7;
//const int nc_obj = 3;//definita a livello globale
double obj_xye_tmp[nr_obj][nc_obj];  
 // altro 
    clock x;

const int nr_obj_dyn = R;// nel Dpa è definita da R
const int nc_obj_dyn = nc_obj; // definita a livello globale
double distance_obj_dyn[nr_obj_dyn];
double obj_xye_dyn[nr_obj_dyn][nc_obj_dyn] ={{0.0,0.0,0.0}};
//int id_robot = 1;

const int nr_object = nr_obj + nr_obj_dyn;

/////////////////////////////////////////////////


//sense importance matrix
//const int n_sense_tot = 5;//in questo momento non ho trovato il modo di legare le info della SEEAO
                          // e questa in cpp, dunque li considero tutti i pesi dei sensi pur sapendo 
                          // che solo i primi 3 vengono usati.
///*
//sense importance matrix
const int n_sense_tot = nr_impSense_max;//definita al livello globale



//entity importance matrix

// in questo momento li posso assegnare in modo con id crescente
    int id_vector_sense[n_sense];
    int id_vector_event[n_event];
    int id_vector_entity[n_entity];
    int id_vector_action[n_action];
    int id_vector_output[n_output];

void init_obj_xye_tmp(int nr, int nc){
        int i = 0;
        int j = 0; 
        for(i  = 0; i &lt; nr; i ++){
            for(j = 0; j &lt; nc; j++){
                obj_xye_tmp[i][j] = obj_xye[i][j];     
            }
        }
    }
    
void id_initialization(){
    for(j1 =0 ; j1&lt;n_sense;j1++){
        id_vector_sense[j1] = j1+1;
    }
    for( j2 =0 ; j2&lt;n_event;j2++){
        id_vector_event[j2] = j2+1;
    }
    for( j3 =0 ; j3&lt;n_action;j3++){
        id_vector_action[j3] = j3+1;
    }
    for( j4 =0 ; j4&lt;n_entity;j4++){
        id_vector_entity[j4] = j4+1;
    }
    for( j4 =0 ; j4&lt;n_output;j4++){
        id_vector_output[j4] = j4+1;
    }

}

void set_to_zero(){//function toset to zero the value of the vectors and the other elements
                    // that are needed to be set to zero 


    }
 


  //matrix for the hb model
 // variabili per la funzione update_weight  
  //variabili per il i pesi dei diversi elementi presenti nel modello
    double action_weight_vector[n_action];//ora si modificano in base agli eventi 
    double sense_weight_vector[n_sense];
    double event_weight_vector[n_event];
    double entity_weight_vector[n_entity];

//variabili per la funzione update_event_may_happen
    int event_may_happen[n_event] ;// {1,1,0,0,1}; // 1 if yes, 0 if no.// it can be modified

    double weight_stm;
    double weight_ltm;
    int stm_action[n_stm];//vettore per memorizzare n_stm output_action
    int ltm_action[n_ltm];
    int stm_index = 0;
    int ltm_index =0;


// variable to count the nnumber of the model iterations over the time
    int index_cycle = 0;


  // variables to memorize the id's extracted
    int id_sense_extracted;
    int id_entity_extracted;
    int id_event_extracted;
    int id_action_extracted;
   // int id_output_extracted;
    int id_out;
    int last_output_id;
    int id_entity;
    int id_sense;
    int id_event;
    int id_action;
  
  
double distance[nr_obj];

void upd_obj_dyn_pos(){
    int i;
    for(i =0 ; i &lt; R; i++){
        obj_xye_dyn[i][0] =robPositionX[i];
        obj_xye_dyn[i][1] =robPositionY[i];
        obj_xye_dyn[i][2] =id_robot;
    }
}

int event_from_entity[n_event];
int id_object;
int neigh[nr_object];
double pos_human;
double pos_object;
// funzione che modifica il event may happen
void update_event_may_happen(){
    int g =0;
    int event_id;
    double numero_random_mh;
    int i;
    int j; 
    int k; 
    double k_th = 0.90;
    double d_th = distance_threshold*k_th; 
    
  // il caso_event definisce se il vettore event_may_happen rimane come fissato(0) o è randomico (=1)
    if(caso_event == 1){
        // associa randomicamente 0(non succede) 1(succede)
        for(g=0; g&lt; n_event; g++){
            numero_random_mh = random(100)+1;
            if(numero_random_mh &lt;= 50){
                event_may_happen[g] = 1;
            }
            else{
                event_may_happen[g] = 0;
            }
        }
    }
    else if(caso_event == 2){
    // initializzo il vettore event_may_happen a zero per fare in modo che poi cambia
    // e non avere problemi che diventino tutti uno 
        for(i = 0; i &lt; n_event; i ++){
            event_may_happen[i] = 0;
        }
        // faccio lo stesso per il vettore event_from_entity per averlo nullo al prossimo ciclo
        // e non dipendente dal ciclo precedente
        for(i = 0; i &lt; n_event; i ++){
            event_from_entity [i] = 0;
        }
      //+ popolo il vettore neighbour per oggetti statici
        for(i = 0; i &lt; nr_obj; i ++){
          //+ verifico la distanza tra entità ed umano
        // ora lo faccio in modo randomico poi posso usare le struct in cui un oggetto
        // è definito da  : object(id,x,y)
            //pos_object = random(N_random)+ 1;
            //pos_human = random(N_random) + 1;
            //pos_object = 4.0;
            //pos_human =3.0;

        // caso 1 della funzione
            init_obj_xye_tmp(nr_obj,nc_obj);
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_tmp[i][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[i][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_tmp[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_tmp[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance[i] = pt_dist(humanPositionX[id -1],obj_xye[i][0],humanPositionY[id -1],obj_xye[i][1]);
        // verifica della condizione sulla distanza 
            if( distance[i] &lt;= distance_threshold){
                id_object =fint(obj_xye[i][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
        
         j = 0;// perchè non faccio più riferimento alla matrice statica ma a quella dynamica che ha 
               // parte da zero come indice e non parte dall'indice finale di quella statica
               // lo faccio soptrattutto per evitare errore di indici perchè accederei a parti della matrice
               // che non esiste
        //+ popolo il vettore neighbour per oggetti dinamici dalla fine degli oggetti statici al numero totale di oggetti
        for(i = nr_obj; i &lt; nr_object; i ++){ // parto da nr_obj perchè il vettore neigh non lo divido tra dinamico
                                              // e statico ma ne mantengo uno solo con dentro sia gli oggetti statici
                                              // che dinamici
        // caso 1 della funzione
            if(random(N_random)+1&lt;= 50 &amp;&amp; caso_obj == 1){
                obj_xye_dyn[j][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[j][1] = 0;
            }
        // caso 2 della fuzione 
            if(caso_obj == 2){
                obj_xye_dyn[obj_selected][0] = humanPositionX[id -1] + sqrt(pow(d_th,2) - pow(humanPositionY[id -1],2));
                obj_xye_dyn[obj_selected][1] = 0;
            }
        // calcolo della distanza
            distance_obj_dyn[j] = pt_dist(humanPositionX[id -1],obj_xye_dyn[j][0],humanPositionY[id -1],obj_xye_dyn[j][1]);
        // verifica della condizione sulla distanza 
            if( distance_obj_dyn[j] &lt;= distance_threshold){
                id_object =fint(obj_xye_dyn[j][2]);
                neigh[i] = id_object;    
            }
            else{// posso fare un assegnazione qui o settarlo prima tutto a zero per perdere 
                // l'indipendenza con il caso precedente
                neigh[i] = -1;
            }
        }
      //+ scorro la matrice per associare al vettore event_may_happen il valore 1 per l'entità
      // che rientra nel neighbour
        for(j = 0; j &lt; nr_object; j ++){  
        // scorro la matrice  
            for(i = 0; i &lt; n_rows; i++){
             // trovando l'entità che è nel neighbour of the human
                if(SEEAO[i][1] == neigh[j]){
               // prendo l'evento relativo a quell'entità
                    event_id = SEEAO[i][2];
                // faccio scorrere il vettore degli eventi per attivarli o meno
                    for(k = 0; k &lt; n_event; k++){
                // se trovo un id nel vettore degli id degli eventi uguali, dato che 
                // il vettore event_may_happen ha le stesse celle di quello dell'id_vector
                // prendendo l'indice dell'id_vector event posso porre event_may_happen[k] = 1
                        if(event_id ==id_vector_event[k]){
                           // event_may_happen[k] = 1;
                            
                            // altrimenti posso contare le ricorrenze degli eventi e poi
                            // porre event_may_happen a 1 quando il valore in un vettore che conta 
                            // le ricorrenze è maggiore di zero e gli altri a zero 
                            event_from_entity[k] = event_from_entity[k]+1;
                        }
                    }
                }
            }
        }
        
        // in questo caso l' inizializzazione del vettore event_may_happen non interessa
    // dato che qui vi assegno  ed 1, devo farlo però per il vettore event_from_entity
        for(k = 0; k&lt; n_event; k ++){
            if(event_from_entity[k]&gt;0){
                event_may_happen[k] = 1;
            }
            else{
                event_may_happen[k] = 0;
            }
        }
    }   
}

    //definition of the variable to be used in the update_weight function 
    //defined outside to look what happens over the time for their values
    double event_weight_sum = 0.0;
    double entity_weight_sum = 0.0;
    double sense_weight_sum = 0.0;
    double action_weight_sum = 0.0;

void update_weight(){//funzione per l'update dei pesi     
    int i1=0;
    int o1 = 0;
    // annullare la somma ad ogni inizio della funzione
    event_weight_sum = 0.0;
    entity_weight_sum = 0.0;
    sense_weight_sum = 0.0;
    action_weight_sum = 0.0;
    // setto i vettori dei pesi = 0; mi serve per l'estrazione poi
    for(i1 =0;i1 &lt;n_sense;i1++){
        sense_weight_vector[i1]= 0;
    } 
    i1=0;
    for(i1 =0;i1 &lt;n_entity;i1++){
        entity_weight_vector[i1]= 0;
    }
    i1 =0;    
    for(i1 =0;i1 &lt;n_event;i1++){
        event_weight_vector[i1]= 0;
    }  
    i1 =0;    
    for(i1 =0;i1 &lt;n_action;i1++){
        action_weight_vector[i1]= 0;
    }     
    

    // dal vettore degli eventi che possono succedere definisco quali sono le entità e sensi relativi 
    for(i = 0; i &lt; n_event; i ++){
        if(event_may_happen[i] == 1){
            // definisco l'id dell'evento
                id_event = id_vector_event[i];
                // ricerco nella matrice SEEAO gli eventi con l'id dell'evento che mi interessa, muovendomi lungo le azioni
                for(j= 0; j &lt; n_rows;j ++){
                    if(SEEAO[j][2]==id_event){
                         // assegno gli id_entity ed sense presi dalla matrice nella posizione che  id = id_event
                             id_entity = SEEAO[j][1];
                             id_sense = SEEAO[j][0];
                             id_action = SEEAO[j][3];
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi dell'entità
                            if(caso_weight_entity ==1){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + importance_entity[k];
                                    }
                                }
                            }
                            else if(caso_weight_entity==0){
                                for(k =0; k&lt; n_entity;k ++){
                                    if(id_vector_entity[k] == id_entity){
                                        entity_weight_vector[k] = entity_weight_vector[k] + 1.00;
                                    }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi per i sense
                            if(caso_weight_sense==1){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] + importance_sense[o];
                                     }
                                }
                            }
                            else if(caso_weight_sense == 0){
                                for( o = 0; o &lt; n_sense; o++){
                                     if(id_vector_sense[o]== id_sense){
                                            sense_weight_vector[o] = sense_weight_vector[o] +1.00;
                                     }
                                }
                            }
                            // dagli id selezionati vado a sommare 1 al peso del vettore dei pesi delle azioni
                            for( o1 = 0; o1 &lt; n_action; o1++){
                                 if(id_vector_action[o1]== id_action){
                                        action_weight_vector[o1] = action_weight_vector[o1] + 1.00;
                                        if(caso_upd_weight==1){
                                            // aggiunta pesi dalla stm
                                
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                        else if (caso_upd_weight==2 &amp;&amp; random(N_random)+1 &lt;= upd_weight){
                                            // aggiunta pesi dalla stm
                                            for(i1 = 0;i1 &lt; n_stm;i1++){
                                                if(stm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + stm_weight;
                                                }    
                                            }
                                            for(i1 = 0;i1 &lt; n_ltm;i1++){
                                                if(ltm_action[i1] == id_action ){
                                                    action_weight_vector[o1] = action_weight_vector[o1] + ltm_weight;
                                                }    
                                            }
                                            
                                        }
                                 }
                            }

                   }            
              }

        }
    }


    //normalise the weight of the event,
    for( i1 = 0; i1 &lt; n_event; i1 ++ ){
        event_weight_sum = event_weight_sum + event_may_happen[i1];
    }
    for(i2 = 0; i2 &lt; n_event; i2++){
        event_weight_vector[i2] = event_may_happen[i2]/event_weight_sum;
    }
    //normalise the weight of the entity 
    for( i3 = 0; i3 &lt; n_entity; i3++){
        entity_weight_sum = entity_weight_sum + entity_weight_vector[i3];
    }
    for( i4 = 0; i4 &lt; n_entity; i4++){
        entity_weight_vector[i4] = entity_weight_vector[i4]/entity_weight_sum;
    }

    //normalise the weight of the sense 
    for(i5 = 0; i5 &lt; n_sense; i5++){
        sense_weight_sum = sense_weight_sum + sense_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_sense; i6++){
        sense_weight_vector[i6] = sense_weight_vector[i6]/sense_weight_sum;
    }

    // normalise the weight of the action
    for(i5 = 0; i5 &lt; n_action; i5++){
        action_weight_sum = action_weight_sum + action_weight_vector[i5];
    }
    for(i6 = 0; i6 &lt; n_action; i6++){
        action_weight_vector[i6] = action_weight_vector[i6]/action_weight_sum;
    }

}

    // dichirazioni per la sense_id_extraction function (messi fuori perché dentro danno problema di SCN)
    double numero_random_;
    double  interval_vector_sense[n_sense];

// for extraction of the id_sense
int sense_id_extraction(){
    double numero_random = random(N_random)+1;
    
    int q1,q;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int i1 =0;
    int id_selected[n_sense];// vettore di appoggio per i sensi selezionati
    //creare il vettore posso fare come faccio per quello dell’entità considerando solo i sensi che hanno 
    //peso diverso da zero utilizzando un vettore di appoggio per memorizzare i valori degli id di quei sensi che hanno 
    //il peso diverso da zero
    //ciclo per settare i valori del vettore di appoggio degli id = 0
    //  for(q6 = 0; q6 &lt;n_sense;q6 ++){
    //        id_selected[q6] = 0; 
    //}

    //dal vettore dei pesi dei sensi prendo solo quelli che hanno il peso diverso da 0
    //q6 =0;
    //for(i1=0; i1&lt; n_sense;i++){
      //  if(sense_weight_vector(i1)&gt;0){
        //    id_selected[q6] = id_vector_sense[i1];
          //  q6 ++;
        //}
    //}

    //interval vector initialization
    for(q1=0;q1&lt;n_sense;q1++)
    {
    	interval_vector_sense[q1] = sense_weight_vector[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_sense; q ++)//changed
    {
    interval_vector_sense[q] = interval_vector_sense[q-1]+ interval_vector_sense[q];
    }

    l=0;
    // extract the sense from the comparison between the numero random and the interval_vector components
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_sense[l]){
            id_extracted = id_vector_sense[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    } 
    return id_extracted;
}

 double  interval_vector_entity[n_entity];
 double weight_vector_entity[n_entity];//double weight_vector[n_entity];

// modo diverso dal precedente, metto a zero i pesi dell'entità non considerate, evito di usare una funzione esterna
// calcolare il numero di entità derivanti dal senso (perché non ho quell'info al tempo della compilazione)
// for extraction of the entity from the sense--------------------------------------------------
int entity_id_extraction(int sense_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_entity];// int id_selected[n_entity];
    int m1 = 0;
    int selected_id;
    int k; 
    int selected_vector[n_entity];
    //define the interval vector // dichiarazioni spostate per l'errore che danno
    //double  interval_vector[n_entity];
  
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0, comunque per non averlo uguale a non so cosa da zero
    for(q6 = 0; q6 &lt;n_entity;q6 ++){
        id_selected[q6] = 0; 
    }
    
    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_entity;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_entity;k ++){
                    if(id_vector_entity[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
        }
    }
    for(k = 0;k &lt; n_entity; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }

    // creo il vettore dei pesi per l'entità relative al senso estratto

    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_entity; q3 ++){
            if( id_vector_entity[q3] == id_selected[q2]){
                weight_vector_entity[q2] = entity_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_entity[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_entity[q5] = weight_vector_entity[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_entity[q1] = weight_vector_entity[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){//n_selected = n_entity
        interval_vector_entity[q] = interval_vector_entity[q-1]+ interval_vector_entity[q];
    }

    while (id_trovato == true)
    {
        if (numero_random &lt;= interval_vector_entity[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
    return id_extracted;
}


    // definizione esterna per il problema che mi da metterli dentro
    double weight_vector_event[n_event];
    double  interval_vector_event[n_event];
// FUNCTION for extraction of the event id from the entity extracted
int event_id_extraction(int sense_id_extracted, int entity_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number    
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
   // int id_selected[n_event];
    int id_selected[n_event];
    int m1 = 0;
    //double weight_vector[n_event];    
    //double weight_vector[5];
    //define the interval vector
    //double  interval_vector[n_event];
    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id ;
    int selected_vector[n_event];
    int n_dim = n_event;
    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_dim;q6 ++){
        id_selected[q6] = 0; 
    }

    // impongo il vettore del numero delle selezioni pari a zero
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }


    // definisco quali sono gli eventi legate a quell'entità
    for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){
            if(SEEAO[m][1] == entity_id_extracted){
                selected_id = SEEAO[m][2]; // vettore dell'evento elativo a quell'entità, che dovrò estrarre
                //selected_id = SEEAO[m][1];
                for(k =0; k&lt; n_dim;k ++){
                    if(id_vector_event[k] == selected_id){
                        selected_vector[k] = selected_vector[k] + 1;
                    }
                }
            }
        }
    }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }


    // creo il vettore dei pesi per l'entità relative al senso estratto
    //n_selected = n_selected -1; pootrebbe essere errata dato che n_selected parte da 0
    for(q2 = 0; q2 &lt; n_selected ;q2 ++){
        for(q3 =0 ; q3 &lt; n_event; q3 ++){
            if( id_vector_event[q3] == id_selected[q2]){
                weight_vector_event[q2] = event_weight_vector[q3];
            }
        }

    }

    // sommo i pesi trovati
    for(q4 =0; q4 &lt; n_selected; q4 ++){
        weight_sum = weight_sum + weight_vector_event[q4];
    }
    //normalizzo i pesi 
    for(q5 = 0; q5 &lt; n_selected; q5 ++){
        weight_vector_event[q5] = weight_vector_event[q5]/weight_sum;
    }

    //interval vector initialization
    for(q1=0;q1 &lt; n_selected;q1++){
	    interval_vector_event[q1] = weight_vector_event[q1]*N_interval;
    }
    // adjust of the interval vector elements 
    for (q = 1 ; q &lt; n_selected; q ++){
        interval_vector_event[q] = interval_vector_event[q-1]+ interval_vector_event[q];
    }
    l=0;
    while (id_trovato == true){
        if (numero_random &lt;= interval_vector_event[l]){
            id_extracted = id_selected[l];
            id_trovato = false;
        }
        else{
            l ++;
        }
    }
 
    return id_extracted;
}

    double weight_vector_action[n_action];
    double interval_vector_action[n_action];
// for extraction of the action from the event
int action_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted){

    double numero_random = random(N_random)+1;
    int q1,q,q2=0,q3,q4,q5,q6;
    // find the index related to the random number
    bool id_trovato = true;
    int l = 0;
    int id_extracted = 0;
    int m = 0;
    int id_selected[n_action];
    int m1 = 0;    
    double weight_sum = 0.0;
    int j = 0;
    int n_selected = 0;
    int selected_id;
    int n_dim = n_action;
    int selected_vector[n_action];


    // assegno zero ad ogni elemento dell'index selected, mi serve per dopo per usare solo la 
    //prima parte di questo, scartando la parte diversa da 0
    for(q6 = 0; q6 &lt;n_action;q6 ++){
            id_selected[q6] = 0; 
        }
    
    for(k= 0; k&lt;n_dim;k++){
        selected_vector[k] = 0;
    }

    // definisco quali sono le entità legate a quel senso

    if(id_rows == false){// caso con la ricerca dell'azione andando per esclusione tra quelle con sense, entity and event extracted
                        // che usa l'id dell'azione nella matrice SEEAO nella posizione 3 (colonnna 4)
        for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        selected_id = SEEAO[m][3]; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        for(k =0; k&lt; n_dim;k ++){
                            if(id_vector_action[k] == selected_id){
                                selected_vector[k] = selected_vector[k] + 1;
                            }
                        }

                    }
                }
            }
        }

    for(k = 0;k &lt; n_dim; k++ ){
        if(selected_vector[k]&gt;0){
            id_selected[j] = k+1;
            j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
            n_selected ++; 
         }
                // vettore dell'entità relative a quel senso, che dovrò estrarre  
    }



        for(q2 = 0; q2 &lt; n_selected ;q2 ++){
            for(q3 =0 ; q3 &lt; n_action; q3 ++){
                if( id_vector_action[q3] == id_selected[q2]){
                    weight_vector_action[q2] = action_weight_vector[q3];
                }
            }

        }
        // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_selected; q4 ++){
            weight_sum = weight_sum + weight_vector_action[q4];
        }
        //normalizzo i pesi 
        for(q5 = 0; q5 &lt; n_selected; q5 ++){
            weight_vector_action[q5] = weight_vector_action[q5]/weight_sum;
        }

        //interval vector initialization
        for(q1=0;q1 &lt; n_selected;q1++){
	        interval_vector_action[q1] = weight_vector_action[q1]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q = 1 ; q &lt; n_selected; q ++){
            interval_vector_action[q] = interval_vector_action[q-1]+ interval_vector_action[q];
        }
         while (id_trovato == true){
             if (numero_random &lt;= interval_vector_action[l]){
               id_extracted = id_selected[l];
               id_trovato = false;
             }
             else{
                 l ++;
             }
       }



    }
    else{// caso id_rows = true 
         for(m =0; m &lt; n_rows ;m++){
            if(SEEAO[m][0] == sense_id_extracted){
                if(SEEAO[m][1] == entity_id_extracted){
                    if(SEEAO[m][2] == event_id_extracted){
                        id_selected[j] = m; // vettore dell'azione relativa a quel evento, che dovrò estrarre
                        j ++; // creo il vettore id_selected lungo al più al numero di entità che ho legate a quell'index
                      //info data a priori), ed utilizzerò solo la prima parte che è diversa da zero
                        n_selected ++; 
                    }
                }
            }
        }
    }

   
    return id_extracted;
}



//function for the id of the output action--&gt; non è corretta perché l'azione estratta è definita dalla n_row 
// e non dall'id della azione

int output_id_extraction(int sense_id_extracted, int entity_id_extracted, int event_id_extracted, int action_id_extracted){
    int id_extracted = 0;
    int m = 0;
 for(m =0; m &lt; n_rows ;m++){
        if(SEEAO[m][0] == sense_id_extracted){//seleziono la riga con il senso estratto
            if(SEEAO[m][1] == entity_id_extracted){//seleziono la riga con il senso e l'entità estratto
                if(SEEAO[m][2] == event_id_extracted){// seleziono la riga con il senso, entità ed evento estratto
                   if(SEEAO[m][3] == action_id_extracted){ // seleziono la riga con il senso,l'entità,l'evento,l'azione estratta
                      id_extracted = SEEAO[m][4]; // 4 th column defines the output action of the action
                    }
                }
            } 
        }
    }
  
    return id_extracted;
}


double update_stm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

double update_ltm_weight(){
    double weight_1;
    weight_1 = random(N_random)+1;
    return weight_1;
}

int add_1(int a){
    return a + 1;
}

// funzione per la short-term memory 
void stm(){
    stm_action[stm_index] = id_action_extracted;
    stm_index = add_1(stm_index);
}

// funzione per la long-term memory
void ltm(){
    ltm_action[ltm_index] = id_action_extracted;
    ltm_index = add_1(ltm_index);
}

int stm_head ;
int stm_tail=0;
int ltm_head;
int ltm_tail=0;
int stm_deleted;
int ltm_deleted; 

int stm_full = 0;//0 -&gt;false; -1 -&gt;true to see the difference in the simulation
int ltm_full = 0;

void stm_enqueue (){
    if(stm_tail == n_stm){
        stm_full = -1; 
    }
    else{
        stm_action[stm_tail] = id_action_extracted;
        stm_tail ++;
        stm_full = 0;
    }
}

void stm_dequeue(){
    int i;
    if(stm_tail &gt; 0){
        stm_deleted = stm_action[0];
        for(i = 1; i &lt; n_stm ; i++){
            stm_action[i-1] = stm_action[i];
        }
        for(i = stm_tail ; i &lt; n_stm ; i ++){
            stm_action[i] = 0;
        }
        stm_tail --;
        
    }    
}


void ltm_enqueue (){
    if(ltm_tail == n_ltm){
        ltm_full = -1; 
    }
    else{
        ltm_action[ltm_tail] = id_action_extracted;
        ltm_tail ++;
        ltm_full = 0;
    }
}

void ltm_dequeue(){
    int i;
    if(ltm_tail &gt; 0){
        ltm_deleted = ltm_action[0];
        for(i = 1; i &lt; n_ltm ; i++){
            ltm_action[i-1] = ltm_action[i];
        }
        for(i = ltm_tail ; i &lt; n_ltm ; i ++){
            ltm_action[i] = 0;
        }
        ltm_tail --;
    }    
}



void stm_ltm(){
    double weight_lost_action_stm;
    double weight_lost_action_ltm;
    double index_random_double;
    int index_random;
    int i;
    
    int action_removed;
      if(caso_stm_ltm == 0){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm
    } // not case 0
  // possibility to lose an action in the stm or in the ltm 
    if(caso_stm_ltm == 1){
        if(stm_index &lt; n_stm){
        // stm strucure
          // save or not the action
            weight_stm = update_stm_weight();
          // differenzio il salvataggio facendo un confronto tra peso ed un numero random, come faccio anche per le altre
          // estrazioni
            if(random(N_random)+1 &lt;= weight_stm){
                stm();  
         // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            }
            // else non saving in stm

        }
        // else not saving in stm

        if(ltm_index &lt; n_ltm){
            // doing the same for the ltm, I put that in this loop, because if i save the action in the stm, maybe 
            weight_ltm = update_ltm_weight();          
            if(random(N_random)+1 &lt;= weight_ltm){
                ltm();  
            }
                // else not saved in ltm
        }
        // else not saved in ltm

        // in stm 
            weight_stm = update_stm_weight();
        if(random(N_random)+1 &lt;= weight_stm ){
          //define the index extracted to remove the action
            index_random_double = random(stm_index+1); // aggiunto l'uno per evitare il problema di random(0)
            index_random = fint(index_random_double);
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(random(stm_index+1)); // from zero to index_stm
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_stm -1; i ++){
                stm_action[i] = stm_action[i+1];
            }
          // reduce the stm_index of 1
            if(stm_index &gt;= 1){ // aggiunto il controllo per evitare il caso stm_index = -1 allo step dopo
                stm_index = stm_index -1;
            }
        }

        // in ltm 
            weight_ltm = update_ltm_weight();
        if(random(N_random)+1 &lt;= weight_ltm ){
          //define the index extracted to remove the action
            index_random_double =random(ltm_index); 
            //int fint(double x) — converts floating point value into integer (works like trunc())
            index_random = fint(index_random_double); // from zero to index_stm-1
          // move to left the element from index_extracted till the end of the vector  
            for(i = index_random;i &lt; n_ltm -1; i ++){
                ltm_action[i] = ltm_action[i+1];
            }
          // reduce the ltm_index of 1
            if (ltm_index &gt;=1){
                ltm_index = ltm_index -1;
            }
        }
    }
    // else no loss of memory

   
  // memoria che si aggiorna in in modo FIFO
    if(caso_stm_ltm == 2){
    // caso per stm
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_enqueue();
        }
        
        weight_stm = update_stm_weight();
        if(weight_stm &lt;= random(N_random)+1){
            stm_dequeue();
        }
    // caso per ltm
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_enqueue();
        }
        
        weight_ltm = update_ltm_weight();
        if(weight_ltm &lt;= random(N_random)+1){
            ltm_dequeue();
        }
        
    }
    if (caso_stm_ltm == 3){
        if(stm_tail == n_stm){
            stm_dequeue();
            stm_enqueue();
        }
        else{
            stm_enqueue();
        }

        if(ltm_tail == n_ltm){
            ltm_dequeue();
            ltm_enqueue();
        }
        else{
            ltm_enqueue();
        }
    }    
 
}



    double weight_vector_output[n_output];
    double interval_vector_output[n_output];
// funzione per come vado ad assegnare il last_id
void assignment_last_id(){
    int q4;
    int l;
    double weight_sum = 0.0;
    double numero_random = random(N_random)+1;
    bool id_trovato = false;
    int id_extracted;

  //
    // caso 0
    if(caso_last_id ==0){
        last_id_extracted_output = last_id_extracted_output;
        // so che non è necessario ma è solo per avere chiaro i vari casi, posso anche levarlo
    }
  // assegnazione stesso peso per ogni output 
    for(q4=0;q4&lt;n_output;q4++){
        weight_vector_output[q4] = 1;
    }
  // cicli per l'estrazione del last id in modo randomico ad ogni ciclo
    if(caso_last_id == 1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    } 

    //caso 2
    /*
        – initial id= last id se index cicli &lt;= 1 e poi last_id_extracted = id_output_extracted 
        quando index_cicli &gt; 1 con index_cicli di partenza  = 0; 
    */

    if (caso_last_id == 2 &amp;&amp; index_cycle &lt;=1){
       last_id_extracted_output = last_id_extracted_output;
        //sembra un po contorta come assegnazione ma rispetto a quella precedente questa avviene solo 
        // al primo avvio del programma, ovvero solo nel caso in cui gli event sono tutti zero all'inizio
        // quando è già avviato la last_id_extracted_outpput = id_output_extracted assumento che venga estratta 
        // se non viene estratta rimarrà sempre uguale a quella iniziale
    }

    if (caso_last_id == 3 &amp;&amp; index_cycle &lt;=1){
        last_id_extracted_output = 0; //per capire il suo valore iniziale
            // sommo i pesi trovati
        for(q4 =0; q4 &lt; n_output; q4 ++){
            weight_sum = weight_sum + weight_vector_output[q4];
        }
        //normalizzo i pesi 
        for(q4 = 0; q4 &lt; n_output; q4 ++){
            weight_vector_output[q4] = weight_vector_output[q4]/weight_sum;
        }

        //interval vector initialization
        for(q4=0;q4 &lt; n_output;q4++){
	        interval_vector_output[q4] = weight_vector_output[q4]*N_interval;
        }
        // adjust of the interval vector elements 
        for (q4 = 1 ; q4 &lt; n_output; q4 ++){ //ho messo &lt; anzichè &lt;= (out of range) perchè non sto usando n_selected
            interval_vector_output[q4] = interval_vector_output[q4-1]+ interval_vector_output[q4];
        }
        l=0;
        while (id_trovato == false){
            if (numero_random &lt;= interval_vector_output[l]){
                id_extracted = id_vector_output[l];
                id_trovato = true;
            }
            else{
                l ++;
            }
        }
    last_id_extracted_output = id_extracted;
    }

}

//assignment
 bool event_all_zero = true;
//unica funzione che fa tutto quello che il modello cmpct fa
int out_id_ref(){
    int id_extracted_output;
    int j = 0;
    event_all_zero = true;//to set at all the call of this function the doubt to have all event = zero
   // index_cycle ++;
   // set_to_zero();
// update the position of the dynamic objects
        upd_obj_dyn_pos();
    // per avere che gli id vector siano dipendenti dal numero di entità, sense etc.... presenti
    id_initialization();
  // funzione per definire il valore della last_id a tempo zero
    assignment_last_id();
  // funzione per modificare il vettore degli eventi che potrebbero succedere 
    update_event_may_happen();
  // controllo che almeno un evento sia diverso da zero 
    while(event_all_zero == true and j &lt; n_event){
        if(event_may_happen[j]==1){
            event_all_zero = false;
        }
        j++;
    }
    if(event_all_zero == false){
      
      // funzione per l'update dei weights
        update_weight();
      // funzione per l'estrazione del senso 
        id_sense_extracted = sense_id_extraction();
      // funzione per l'estrazione dell'entità
        id_entity_extracted = entity_id_extraction(id_sense_extracted);
      // funzione per l'estrazione dell'evento
        id_event_extracted = event_id_extraction(id_sense_extracted, id_entity_extracted);
      // funzione per l'estrazione dell'azione
        id_action_extracted = action_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted);
      // funzionne per l'estrazione dell output finale
        id_extracted_output= output_id_extraction(id_sense_extracted, id_entity_extracted, id_event_extracted, id_action_extracted);
        last_id_extracted_output = id_extracted_output;
      // funzione per li modulo stm and ltm
        stm_ltm();
        }
    else{
         // in questo caso solo per vedere se funziona, nel modello protrebbe essere
          id_extracted_output = last_id_extracted_output; // in questo caso è zero
        // id_extracted_output = 6;   
        }
return id_extracted_output;
}

int next_time = n_delay_index;
int n_extraction = 0;
int extraction_new = 0; 
int last_id_extracted_tmp = 0; // inserito per fare in modo che nel caso_deelay == 1 l'estrazione sia uguale alla precedente
                               // messa fuori perchè dentro viene definita = 0 ad ogni ciclo e quindi si blocca 
                               // il modello  
// funzione che viene usata e poi 
int out_id(){
    int id_extracted_output;
    index_cycle ++;
    if(caso_delay==0){
        id_extracted_output = out_id_ref();
        extraction_new = 1;
    }

    if(caso_delay==1){
        if(index_cycle&lt;=1||index_cycle%n_delay_index ==0){//devo fare l'estrazione almeno una volta
            id_extracted_output = out_id_ref();
            extraction_new = 1;
            last_id_extracted_tmp = id_extracted_output;
        }
       else{
        extraction_new = 0;
        id_extracted_output = last_id_extracted_tmp;
      }
    }
    else if(caso_delay ==2){
                if(index_cycle&lt;=1||fint(x)%n_delay_index ==0){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    } 
            }
    else if(caso_delay ==3){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index*n_extraction){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==4){
                if(index_cycle&lt;=1||fint(x)&gt;=next_time){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    next_time = fint(x) + n_delay_index;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }
      else if(caso_delay ==5){
                if(index_cycle&lt;=1||fint(x)&gt;=n_delay_index){//devo fare l'estrazione almeno una volta
                    id_extracted_output = out_id_ref();
                    extraction_new = 1;
                    last_id_extracted_tmp = id_extracted_output;
                    n_extraction ++;
                    index_cycle = 3;
                    x = 0.0;
                }
               else{
                    extraction_new = 0;
                    id_extracted_output = last_id_extracted_tmp;
                    index_cycle = 2;
                    } 
            }

return id_extracted_output;
}

////////////////////////////////////////////////
</declaration>
<location id="id361" x="-492" y="-399">
			<name x="-526" y="-425">idle</name>
			<label kind="invariant" x="-612" y="-518">Fp' == 0 

&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id362" x="119" y="-399">
			<name x="127" y="-442">busy_mov</name>
			<label kind="invariant" x="127" y="-544">Fp' == 0 
&amp;&amp; F &lt;= passout_th 
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id363" x="-687" y="-398">
			<name x="-730" y="-415">Init</name>
			<committed/>
		</location>
		<location id="id364" x="272" y="-399">
			<name x="289" y="-416">passed_out</name>
			<label kind="invariant" x="289" y="-399">t' == 0 &amp;&amp;
F' == 0</label>
			<label kind="exponentialrate" x="264" y="-382">1</label>
		</location>
		<location id="id365" x="-195" y="-569">
			<name x="-186" y="-561">busy_rec</name>
			<label kind="invariant" x="-187" y="-544">Fp' == 0 
&amp;&amp; F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id366" x="-493" y="-246">
			<name x="-476" y="-238">p_1</name>
			<committed/>
		</location>
		<location id="id367" x="-578" y="-246">
			<name x="-620" y="-255">p_2</name>
			<committed/>
		</location>
		<location id="id368" x="119" y="-246">
			<name x="102" y="-229">p_5</name>
			<committed/>
		</location>
		<location id="id369" x="119" y="-323">
			<name x="76" y="-331">p_6</name>
			<committed/>
		</location>
		<location id="id370" x="-85" y="-714">
			<name x="-95" y="-748">p_4</name>
			<committed/>
		</location>
		<location id="id371" x="-195" y="-714">
			<name x="-205" y="-748">p_3</name>
			<committed/>
		</location>
		<location id="id372" x="-42" y="-399">
			<name x="-52" y="-433">d_2</name>
			<committed/>
		</location>
		<location id="id373" x="-306" y="-399">
			<name x="-316" y="-433">d_1</name>
			<committed/>
		</location>
		<location id="id374" x="-722" y="-535" color="#a9a9a9">
			<name x="-732" y="-569">not_needed</name>
			<label kind="exponentialrate" x="-748" y="-544">1</label>
		</location>
		<init ref="id363"/>
		<transition color="#ffc0cb">
			<source ref="id373"/>
			<target ref="id368"/>
			<label kind="guard" x="-229" y="-212">id_out == id_walk</label>
			<nail x="-306" y="-187"/>
			<nail x="-306" y="-187"/>
			<nail x="119" y="-187"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id373"/>
			<target ref="id368"/>
			<label kind="guard" x="-17" y="-229">id_out==id_run</label>
			<nail x="-306" y="-229"/>
			<nail x="-306" y="-229"/>
			<nail x="102" y="-229"/>
		</transition>
		<transition color="#0000ff">
			<source ref="id373"/>
			<target ref="id361"/>
			<label kind="guard" x="-348" y="-382">id_out == id_sit</label>
			<label kind="assignment" x="-297" y="-365">t = 0, Fp = F, 
tUpd=0</label>
			<nail x="-365" y="-374"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id373"/>
			<target ref="id361"/>
			<label kind="guard" x="-314" y="-450">id_out== id_stand</label>
			<label kind="assignment" x="-289" y="-433">t = 0, Fp = F, 
tUpd=0</label>
		</transition>
		<transition color="#0000ff">
			<source ref="id372"/>
			<target ref="id366"/>
			<label kind="guard" x="-280" y="-144">id_out==id_sit</label>
			<nail x="-42" y="-119"/>
			<nail x="-493" y="-119"/>
		</transition>
		<transition color="#ffa500">
			<source ref="id372"/>
			<target ref="id366"/>
			<label kind="guard" x="-408" y="-178">id_out== id_stand</label>
			<nail x="-42" y="-153"/>
			<nail x="-493" y="-153"/>
		</transition>
		<transition color="#00ffff">
			<source ref="id372"/>
			<target ref="id362"/>
			<label kind="guard" x="8" y="-501">id_out== id_run</label>
			<label kind="assignment" x="17" y="-484">t = 0, Fp = 1-F,
tUpd=0, 
plan_traj()</label>
			<nail x="-42" y="-459"/>
		</transition>
		<transition color="#ffc0cb">
			<source ref="id372"/>
			<target ref="id362"/>
			<label kind="guard" x="-34" y="-391">id_out== id_walk</label>
			<label kind="assignment" x="-34" y="-374">t = 0, Fp = 1-F,
tUpd=0, 
plan_traj()</label>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id372"/>
			<label kind="guard" x="-382" y="-272">currH == id</label>
			<nail x="-187" y="-246"/>
			<nail x="-187" y="-399"/>
		</transition>
		<transition>
			<source ref="id368"/>
			<target ref="id373"/>
			<label kind="guard" x="-153" y="-280">currH==id</label>
			<nail x="-229" y="-246"/>
			<nail x="-229" y="-399"/>
		</transition>
		<transition>
			<source ref="id370"/>
			<target ref="id365"/>
			<label kind="synchronisation" x="-136" y="-663">publish_m[4]!</label>
			<label kind="assignment" x="-136" y="-646">tUpd=0</label>
			<nail x="-85" y="-569"/>
		</transition>
		<transition>
			<source ref="id371"/>
			<target ref="id370"/>
			<label kind="guard" x="-178" y="-714">currH==id</label>
			<label kind="synchronisation" x="-161" y="-697">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id365"/>
			<target ref="id371"/>
			<label kind="guard" x="-289" y="-663">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-289" y="-646">updateF(-mi, 0), 
tUpd=0</label>
		</transition>
		<transition>
			<source ref="id369"/>
			<target ref="id362"/>
			<label kind="synchronisation" x="68" y="-357">publish_m[4]!</label>
			<label kind="assignment" x="59" y="-374">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id368"/>
			<target ref="id369"/>
			<label kind="guard" x="17" y="-306">currH==id</label>
			<label kind="synchronisation" x="17" y="-272">publish_m[3]!</label>
		</transition>
		<transition color="#00ff00">
			<source ref="id362"/>
			<target ref="id368"/>
			<label kind="guard" x="204" y="-314">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="204" y="-297">updateF(-lambda, 1),
updateP(), tUpd=0,
id_out=out_id()</label>
			<nail x="195" y="-399"/>
			<nail x="195" y="-246"/>
		</transition>
		<transition>
			<source ref="id367"/>
			<target ref="id361"/>
			<label kind="synchronisation" x="-637" y="-331">publish_m[4]!</label>
			<label kind="assignment" x="-637" y="-314">tUpd=0</label>
			<nail x="-578" y="-399"/>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id367"/>
			<label kind="guard" x="-561" y="-289">currH==id</label>
			<label kind="synchronisation" x="-561" y="-306">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id366"/>
			<target ref="id361"/>
			<label kind="guard" x="-484" y="-297">currH!=id</label>
			<nail x="-493" y="-314"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id361"/>
			<target ref="id366"/>
			<label kind="guard" x="-399" y="-357">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-399" y="-340">updateF(-mi, 0), 
tUpd=0, 
id_out = out_id()</label>
			<nail x="-408" y="-399"/>
			<nail x="-408" y="-246"/>
		</transition>
		<transition>
			<source ref="id365"/>
			<target ref="id361"/>
			<label kind="synchronisation" x="-484" y="-569">stop_h_action?</label>
			<label kind="assignment" x="-484" y="-620">t = 0, Fp = F,

tUpd=0</label>
			<nail x="-493" y="-569"/>
		</transition>
		<transition>
			<source ref="id362"/>
			<target ref="id365"/>
			<label kind="guard" x="-17" y="-552">currH==id</label>
			<label kind="synchronisation" x="-17" y="-569">start_h_action?</label>
			<label kind="assignment" x="-17" y="-620">t = 0, Fp = F, 
tUpd=0</label>
			<nail x="119" y="-569"/>
		</transition>
		<transition>
			<source ref="id361"/>
			<target ref="id365"/>
			<label kind="guard" x="-357" y="-518">currH==id</label>
			<label kind="synchronisation" x="-357" y="-501">start_h_action?</label>
			<label kind="assignment" x="-357" y="-484">F = 0, t = 0,
tUpd=0</label>
			<nail x="-365" y="-399"/>
			<nail x="-365" y="-569"/>
		</transition>
		<transition>
			<source ref="id362"/>
			<target ref="id364"/>
			<label kind="guard" x="137" y="-416">F &gt;= passout_th</label>
			<label kind="synchronisation" x="162" y="-399">h_fail!</label>
			<label kind="assignment" x="213" y="-382">t = 0</label>
		</transition>
		<transition>
			<source ref="id364"/>
			<target ref="id364"/>
			<nail x="247" y="-348"/>
			<nail x="289" y="-348"/>
		</transition>
		<transition color="#00ff00">
			<source ref="id363"/>
			<target ref="id361"/>
			<label kind="assignment" x="-671" y="-416">initHuman()
,id_out= out_id()</label>
		</transition>
		<transition>
			<source ref="id374"/>
			<target ref="id374"/>
			<nail x="-663" y="-535"/>
			<nail x="-663" y="-501"/>
		</transition>
		<transition>
			<source ref="id361"/>
			<target ref="id374"/>
			<label kind="guard" x="-765" y="-510">PATH!=0
            &amp;&amp; PATH!=path</label>
			<nail x="-722" y="-459"/>
		</transition>
</template>

	<template>
		<name>Human_Rescuer</name>
		<parameter>int id, double _v, int p_f, int p_fw, int p_dext, int path</parameter>
		<declaration>//PATTERN N°10
clock t, F;
clock tUpd;
clock tExp;

double Fp;
double lambda, mi;

// Errors Model
int obey, disobey;
double freeWillTh;
double fw;
int TE;
double lambda_crit;
double hs, crit, non_crit;


bool nearRobot = false;

void updateF(double coeff, bool walking) {
    if(walking) {
        internalFatigue[id-1] = 1-(1-internalFatigue[id-1])*exp(coeff*Tpoll);
    } else {
        internalFatigue[id-1] = internalFatigue[id-1]*exp(coeff*Tpoll);
    }

    internalFatigue[id-1] = fmax(0, internalFatigue[id-1]);
}

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};
double ort = 0.0;
int curr_traj = 0;

void change_orientation(double sx, double sy, double dx, double dy) {
    double cos_alpha, alpha, theta, delta;
    double AC, AB;
    bool turnLeft, needsTurning = false;

    AC = pt_dist(sx, dx, sy, sy);
    AB = pt_dist(sx, dx, sy, dy);

    if (AB == 0)
    {
        return;
    }

    cos_alpha = AC / AB;
    // angle between destination and hor. line
    alpha = acos(cos_alpha);
    // angle between robot axis and hor. line
    theta = ort * 180 / PI;
    // how much the robot should rotate [deg]
    delta = 0.0;
    turnLeft = false;

    if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 1st quadrant
        alpha = alpha * (180 / PI);
        if (alpha &gt; theta)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 2nd quadrant
        alpha = -alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
    { // Destination in 3rd quadrant
        alpha = -(180 - alpha * (180 / PI));
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }
    else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
    { // Destination in 4th quadrant
        alpha = 180 - alpha * (180 / PI);
        if (theta &lt; alpha)
        {
            delta = alpha - theta;
            turnLeft = true;
        }
        else
        {
            delta = theta - alpha;
            turnLeft = false;
        }
    }

    needsTurning = delta &gt; 0.0;

    if (needsTurning &amp;&amp; turnLeft)
    {
        ort = ort * 180 / PI + delta;
    }
    else if (needsTurning &amp;&amp; !turnLeft)
    {
        ort = ort * 180 / PI - delta;
    }
}

point curr, dest;

void plan_traj() {
    int i, j, next_inters = -1;
    int neigh[5] = {-1,-1,-1,-1,-1};
    int k = 0;
    double dist, min_dist;
    bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
            curr[0] = internalHumX[id-1]; curr[1] = internalHumY[id-1];
    dest[0] = destX[id-1]; dest[1] = destY[id-1];
    // init trajectory
    for (i = 0; i &lt; N_P; i++)
    {
        traj[i][0] = 0.0;
        traj[i][1] = 0.0;
    }
    i = 0;
    curr_traj = 0;

    // builds trajectory by finding a path among adjacent areas
    // (the existence of an intersection point means two areas are adjacent to each other)
    // until the destination area is reached
    while (!same_area(curr[0], curr[1], dest[0], dest[1]))
    {
        for (j = 0; j &lt; N_I; j++)
        {
            // find all int. pts which are a neighbor of curr. point
            // there are max. 3 in the long left hall
            if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
            {
                neigh[k] = j;
                k++;
            }
        }
        // next int. point to add to traj. is the closest to destination
        min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
        next_inters = neigh[0];
        for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
        {
            dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
            if (dist &lt; min_dist)
            {
                min_dist = dist;
                next_inters = neigh[j];
            }
        }
        // if trajectory is full, or no next point has been found,
        // something has gone wrong, but I cannot raise an exception
        if (i == N_P - 1 || next_inters == -1)
            return;
        // next inters point is set as visited,
        visited[next_inters] = true;
        // added to the trajectory,
        traj[i][0] = INTERSECTIONS[next_inters][0];
        traj[i][1] = INTERSECTIONS[next_inters][1];
        i++;
        // and set as current point
        curr[0] = INTERSECTIONS[next_inters][0];
        curr[1] = INTERSECTIONS[next_inters][1];
        // reset
        next_inters = -1;
        k = 0;
        for(j=0; j&lt;5;j++) neigh[j] = -1;
    }
    // destination point is always part of the trajectory
    traj[i][0] = dest[0];
    traj[i][1] = dest[1];

    //sets initial orientation
    change_orientation(internalHumX[id-1], internalHumY[id-1], traj[0][0], traj[0][1]);
}


double dist_to_dest;
meta int v;

void updateP(){
    double eps = 0.0;

    if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
    return;

    if (pt_dist(internalHumX[id-1], traj[curr_traj][0], internalHumY[id-1], traj[curr_traj][1]) &lt; v) {
        curr_traj++;
        if (curr_traj &gt;= N_P)
        return;
        change_orientation(internalHumX[id-1], internalHumY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
    }

    internalHumX[id-1] = internalHumX[id-1] + v*Tpoll*cos(ort*PI/180);
    internalHumY[id-1] = internalHumY[id-1] + v*Tpoll*sin(ort*PI/180);
}

void initHuman() {
    double dist_to_dest = pt_dist(startX[id-1], destX[id-1], startY[id-1], destY[id-1]);
    ERR_PROF error_profile;

    F = 0;
    Fp = 0;
    t = 0;
    tUpd = 0;

    v = fint(_v);

    if(path==ND) {
        humanPositionX[id - 1] = startX[id-1];
        humanPositionY[id - 1] = startY[id-1];
    } else if(path==1) {
        humanPositionX[id - 1] = startX_alt1[id-1];
        humanPositionY[id - 1] = startY_alt1[id-1];
    } else {
        humanPositionX[id - 1] = startX_alt2[id-1];
        humanPositionY[id - 1] = startY_alt2[id-1];
    }

    internalHumX[id-1] = humanPositionX[id-1];
    internalHumY[id-1] = humanPositionY[id-1];

    dext = p_dext;
    task_completion = 0;

    if(p_f==1) {
        lambda = YOUNG_HEALTHY[0]; mi = YOUNG_HEALTHY[1];
    } else if(p_f==2) {
        lambda = random_normal(YOUNG_SICK[0], YOUNG_SICK_SIGMA[0]);
        mi = random_normal(YOUNG_SICK[1], YOUNG_SICK_SIGMA[1]);
    } else if(p_f==3) {
        lambda = random_normal(ELDERLY_HEALTHY[0], ELDERLY_HEALTHY_SIGMA[0]);
        mi = random_normal(ELDERLY_HEALTHY[1], ELDERLY_HEALTHY_SIGMA[1]);
    } else if(p_f==4) {
        lambda = ELDERLY_SICK[0]; mi = ELDERLY_SICK[1];
    } else if (p_f == 5)
    {
        lambda = YOUNG_UNSTEADY[0];
        mi = YOUNG_UNSTEADY[1];
    }
    else if (p_f == 6)
    {
        lambda = ELDERLY_UNSTEADY[0];
        mi = ELDERLY_UNSTEADY[1];
    }
	else {
        lambda = 0.005; mi = 0.005; //default values
    }

    error_profile = get_error_params(p_fw);
    obey = error_profile.obey;
    disobey = error_profile.disobey;
    freeWillTh = error_profile.FW_th;
    if(dist_to_dest&lt;1.0) TE = 999;
    else TE = fint(dist_to_dest / v * (error_profile.delta_x100/100));
    lambda_crit = 1/error_profile.lambda_inv;
    hs = error_profile.crit;
    crit = 1.0;
    non_crit = 999.0;
}

void updateT(){
    task_completion += dext * (random(1)&gt;=0.5);
}

void checkRobot(){
    nearRobot = calculateDistance() &lt;= _v/100.0*2.0;
}
    </declaration>
		<location id="id84" x="-595" y="17">
			<name x="-605" y="-17">Init</name>
			<committed/>
		</location>
		<location id="id85" x="-391" y="204">
			<name x="-391" y="213">c1</name>
			<committed/>
		</location>
		<location id="id86" x="204" y="17" color="#0000ff">
			<name x="212" y="-8">exec</name>
			<label kind="invariant" x="212" y="25">F &lt;= F_max &amp;&amp; tExp'==0
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id87" x="-391" y="17" color="#0000ff">
			<name x="-425" y="25">idle</name>
			<label kind="invariant" x="-510" y="42">F' == -Fp*mi*exp(-mi*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id88" x="-391" y="-68">
			<committed/>
		</location>
		<location id="id89" x="-391" y="-221">
			<committed/>
		</location>
		<location id="id90" x="204" y="-153">
			<name x="194" y="-187">checking</name>
			<committed/>
		</location>
		<location id="id91" x="450" y="-153">
			<committed/>
		</location>
		<location id="id92" x="450" y="17">
			<committed/>
		</location>
		<location id="id93" x="-34" y="204">
			<name x="-44" y="170">c2</name>
			<committed/>
		</location>
		<location id="id94" x="17" y="-34">
			<committed/>
		</location>
		<location id="id95" x="204" y="204" color="#0000ff">
			<name x="194" y="170">moving</name>
			<label kind="invariant" x="195" y="229">F &lt;= F_max
&amp;&amp; F' == Fp*lambda*exp(-lambda*t)
&amp;&amp; tUpd&lt;=Tpoll</label>
		</location>
		<location id="id96" x="433" y="255">
			<name x="423" y="221">c3</name>
			<committed/>
		</location>
		<location id="id97" x="663" y="204">
			<name x="671" y="221">checking_2</name>
			<committed/>
		</location>
		<location id="id98" x="799" y="17" color="#ff0000">
			<name x="807" y="25">passed_out</name>
			<label kind="invariant" x="807" y="42">t' == 0 &amp;&amp;
F' == 0</label>
			<label kind="exponentialrate" x="782" y="-17">1</label>
		</location>
		<location id="id99" x="204" y="476">
			<committed/>
		</location>
		<branchpoint id="id101" x="-391" y="476">
		</branchpoint>
		<branchpoint id="id102" x="17" y="17">
		</branchpoint>
		<branchpoint id="id103" x="-102" y="204">
		</branchpoint>
		<init ref="id84"/>
		<transition color="#ff0000">
			<source ref="id95"/>
			<target ref="id98"/>
			<label kind="guard" x="578" y="68">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
			<nail x="714" y="68"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id87"/>
			<target ref="id98"/>
			<label kind="guard" x="-484" y="-272">tExp &gt;= TE &amp;&amp; !served[id-1]</label>
			<nail x="-493" y="-76"/>
			<nail x="-493" y="-280"/>
			<nail x="535" y="-280"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id90"/>
			<target ref="id86"/>
			<label kind="guard" x="323" y="-136">currH!=id &amp;&amp;
!served[id-1] &amp;&amp;
fw&lt;freeWillTh</label>
			<label kind="assignment" x="323" y="-85">tUpd=0</label>
			<nail x="323" y="-153"/>
			<nail x="323" y="-42"/>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id95"/>
			<label kind="guard" x="382" y="161">currH!=id &amp;&amp;
fw&lt;freeWillTh</label>
			<label kind="assignment" x="408" y="187">tExp=0</label>
			<nail x="433" y="187"/>
		</transition>
		<transition>
			<source ref="id90"/>
			<target ref="id87"/>
			<label kind="guard" x="-8" y="-212">served[id-1]</label>
			<label kind="assignment" x="-8" y="-195">hExe = 0, Fp = F,
tUpd=0, t = 0</label>
			<nail x="-34" y="-153"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id89"/>
			<target ref="id93"/>
			<label kind="guard" x="-272" y="-280">currH==id
&amp;&amp; fw&gt;=freeWillTh
&amp;&amp; task_completion &lt; task_size</label>
			<label kind="assignment" x="-373" y="-221">fw=0</label>
			<nail x="-34" y="-221"/>
		</transition>
		<transition color="#ff0000">
			<source ref="id97"/>
			<target ref="id87"/>
			<label kind="guard" x="357" y="348">fw&gt;=freeWillTh</label>
			<label kind="assignment" x="357" y="365">hExe=0, t = 0,
Fp=F, tUpd=0</label>
			<nail x="663" y="365"/>
			<nail x="-391" y="365"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id86"/>
			<label kind="guard" x="127" y="76">nearRobot</label>
			<label kind="assignment" x="127" y="93">t = 0, tUpd=0,
Fp=F, fw=0</label>
			<label kind="comments" x="484" y="-161">//errore se metto &amp;&amp; freeWill&lt;=freeWillTh.
            general hybrid guard without urgent channel</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id98"/>
			<label kind="guard" x="535" y="17">F &gt;= F_max</label>
			<label kind="synchronisation" x="535" y="34">h_fail!</label>
			<label kind="assignment" x="535" y="51">t=0</label>
		</transition>
		<transition>
			<source ref="id101"/>
			<target ref="id87"/>
			<label kind="assignment" x="-518" y="416">t = 0, Fp=F,
tUpd=0, hExe=0</label>
			<label kind="probability" x="-518" y="399">obey</label>
		</transition>
		<transition color="#ff0000">
			<source ref="id101"/>
			<target ref="id95"/>
			<label kind="probability" x="-59" y="382">disobey</label>
		</transition>
		<transition>
			<source ref="id99"/>
			<target ref="id101"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id99"/>
			<label kind="synchronisation" x="170" y="399">stop_h_action?</label>
		</transition>
		<transition>
			<source ref="id98"/>
			<target ref="id98"/>
			<nail x="841" y="-8"/>
			<nail x="841" y="17"/>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id98"/>
			<label kind="guard" x="807" y="127">F &gt;= F_max</label>
			<label kind="synchronisation" x="807" y="144">h_fail!</label>
			<label kind="assignment" x="807" y="161">t = 0</label>
			<nail x="799" y="204"/>
		</transition>
		<transition>
			<source ref="id96"/>
			<target ref="id95"/>
			<label kind="synchronisation" x="289" y="221">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id97"/>
			<target ref="id96"/>
			<label kind="guard" x="484" y="221">currH==id &amp;&amp;
fw&lt;freeWillTh</label>
			<label kind="synchronisation" x="484" y="255">publish_m[2]!</label>
		</transition>
		<transition>
			<source ref="id95"/>
			<target ref="id97"/>
			<label kind="guard" x="331" y="127">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="433" y="110">updateF(-lambda, 1), checkRobot(),
updateP(), tUpd=0, fw = random(FW_max)</label>
			<nail x="433" y="144"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id95"/>
			<label kind="guard" x="59" y="136">F==0</label>
			<label kind="assignment" x="-8" y="153">Fp=1, plan_traj(), hExe = 1</label>
			<nail x="76" y="153"/>
		</transition>
		<transition>
			<source ref="id93"/>
			<target ref="id95"/>
			<label kind="guard" x="59" y="204">F&gt;0</label>
			<label kind="assignment" x="-17" y="221">Fp=1-F, plan_traj(), hExe = 1</label>
		</transition>
		<transition>
			<source ref="id102"/>
			<target ref="id87"/>
			<label kind="assignment" x="-127" y="17">t = 0, Fp=F,
tUpd=0, hExe=0</label>
			<label kind="probability" x="-136" y="0">obey</label>
		</transition>
		<transition>
			<source ref="id102"/>
			<target ref="id86"/>
			<label kind="probability" x="76" y="0">disobey</label>
		</transition>
		<transition>
			<source ref="id94"/>
			<target ref="id102"/>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id94"/>
			<label kind="synchronisation" x="76" y="-34">stop_h_action?</label>
			<nail x="204" y="-34"/>
		</transition>
		<transition>
			<source ref="id103"/>
			<target ref="id93"/>
			<label kind="probability" x="-93" y="136">obey</label>
		</transition>
		<transition color="#ff0000">
			<source ref="id90"/>
			<target ref="id87"/>
			<label kind="guard" x="-144" y="-102">fw&gt;=freeWillTh
&amp;&amp; !served[id-1]</label>
			<label kind="assignment" x="-221" y="-51">hExe = 0, Fp = F,
tUpd=0, t = 0,
fw=0</label>
			<label kind="comments" x="68" y="-263">human autonomously decides to leave --&gt; insuccess</label>
		</transition>
		<transition>
			<source ref="id92"/>
			<target ref="id86"/>
			<label kind="synchronisation" x="263" y="-17">publish_m[3]!</label>
			<label kind="assignment" x="263" y="0">tUpd=0</label>
		</transition>
		<transition>
			<source ref="id91"/>
			<target ref="id92"/>
			<label kind="synchronisation" x="425" y="-42">publish_m[2]!</label>
		</transition>
		<transition color="#ff0000">
			<source ref="id90"/>
			<target ref="id91"/>
			<label kind="guard" x="272" y="-238">currH==id &amp;&amp;
!served[id-1] &amp;&amp;
fw&lt;freeWillTh</label>
			<label kind="assignment" x="272" y="-187">updateT(),
            updateF(-lambda, 1)</label>
		</transition>
		<transition>
			<source ref="id86"/>
			<target ref="id90"/>
			<label kind="guard" x="204" y="-119">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="76" y="-85">fw = random(FW_max)</label>
		</transition>
		<transition color="#ff0000">
			<source ref="id103"/>
			<target ref="id87"/>
			<label kind="probability" x="-357" y="51">disobey</label>
		</transition>
		<transition>
			<source ref="id85"/>
			<target ref="id103"/>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id88"/>
			<label kind="guard" x="-399" y="-170">currH==id
&amp;&amp; fw&lt;=freeWillTh</label>
			<label kind="synchronisation" x="-391" y="-119">publish_m[2]!</label>
		</transition>
		<transition>
			<source ref="id88"/>
			<target ref="id87"/>
			<label kind="synchronisation" x="-425" y="-51">publish_m[3]!</label>
		</transition>
		<transition>
			<source ref="id89"/>
			<target ref="id87"/>
			<label kind="guard" x="-382" y="-187">currH!=id || served[id-1]</label>
			<label kind="assignment" x="-314" y="-170">tExp=0</label>
			<nail x="-306" y="-102"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id89"/>
			<label kind="guard" x="-527" y="-153">tUpd&gt;=Tpoll</label>
			<label kind="assignment" x="-527" y="-136">updateF(-mi, 0), tUpd=0,
fw = random(FW_max)</label>
			<nail x="-459" y="-85"/>
		</transition>
		<transition>
			<source ref="id87"/>
			<target ref="id85"/>
			<label kind="guard" x="-476" y="144">currH==id</label>
			<label kind="synchronisation" x="-501" y="161">start_h_action?</label>
			<label kind="comments" x="-612" y="127">The human "notices" the robot</label>
		</transition>
		<transition>
			<source ref="id84"/>
			<target ref="id87"/>
			<label kind="assignment" x="-578" y="0">initHuman()</label>
		</transition>
	</template>
<template>
<name>Robot</name>
<parameter>int id, double _v_max, double _a_max, double posX, double posY</parameter>
<declaration>
clock V, Th, tUpd;

trajectory traj = {{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0},{0.0, 0.0}};

double ort = 0.0;
int curr_traj = 0;

// Position Sharing parameters
int t = 0;
const int T_poll = 1;
int v_max;
int a_max;

bool needsTurning = false;
void change_orientation(double sx, double sy, double dx, double dy) {
	double cos_alpha, alpha, theta, delta;
	double AC, AB;
	bool turnLeft;

	AC = pt_dist(sx, dx, sy, sy);
	AB = pt_dist(sx, dx, sy, dy);

	if (AB == 0)
	{
		return;
	}

	cos_alpha = AC / AB;
	// angle between destination and hor. line
	alpha = acos(cos_alpha);
	// angle between robot axis and hor. line
	theta = ort * 180 / PI;
	// how much the robot should rotate [deg]
	delta = 0.0;
	turnLeft = false;

	if (dx &gt;= sx &amp;&amp; dy &gt;= sy)
	{ // Destination in 1st quadrant
		alpha = alpha * (180 / PI);
		if (alpha &gt; theta)
		{
			delta = alpha - theta;
			turnLeft = true;
		}
		else
		{
			delta = theta - alpha;
			turnLeft = false;
		}
	}
	else if (dx &gt;= sx &amp;&amp; dy &lt;= sy)
	{ // Destination in 2nd quadrant
		alpha = -alpha * (180 / PI);
		if (theta &lt; alpha)
		{
			delta = alpha - theta;
			turnLeft = true;
		}
		else
		{
			delta = theta - alpha;
			turnLeft = false;
		}
	}
	else if (dx &lt;= sx &amp;&amp; dy &lt;= sy)
	{ // Destination in 3rd quadrant
		alpha = -(180 - alpha * (180 / PI));
		if (theta &lt; alpha)
		{
			delta = alpha - theta;
			turnLeft = true;
		}
		else
		{
			delta = theta - alpha;
			turnLeft = false;
		}
	}
	else if (dx &lt;= sx &amp;&amp; dy &gt;= sy)
	{ // Destination in 4th quadrant
		alpha = 180 - alpha * (180 / PI);
		if (theta &lt; alpha)
		{
			delta = alpha - theta;
			turnLeft = true;
		}
		else
		{
			delta = theta - alpha;
			turnLeft = false;
		}
	}

	needsTurning = delta &gt; 0.0;

	if (needsTurning &amp;&amp; turnLeft)
	{
		ort = ort * 180 / PI + delta;
	}
	else if (needsTurning &amp;&amp; !turnLeft)
	{
		ort = ort * 180 / PI - delta;
	}
}

point curr, dest;
void plan_traj() {
	int i, j, next_inters = -1;
	int neigh[5] = {-1,-1,-1,-1,-1};
	int	k = 0;
	double dist, min_dist;
	bool visited[N_I] = {false,false,false,false,false,false,false,false,false};
	bool close;
	curr[0] = internalRobX[id-1]; curr[1] = internalRobY[id-1];
	dest[0] = dX[id-1]; dest[1] = dY[id-1];
	// init trajectory
	for (i = 0; i &lt; N_P; i++)
	{
		traj[i][0] = 0.0;
		traj[i][1] = 0.0;
	}
	i = 0;
	curr_traj = 0;

	// builds trajectory by finding a path among adjacent areas
	// (the existence of an intersection point means two areas are adjacent to each other)
	// until the destination area is reached
	close = same_area(curr[0], curr[1], dest[0], dest[1]);
	while (!close)
	{
		for (j = 0; j &lt; N_I &amp;&amp; k&lt;3; j++)
		{
			// find all int. pts which are a neighbor of curr. point
			// there are max. 3 in the long left hall
			if (same_area(curr[0], curr[1], INTERSECTIONS[j][0], INTERSECTIONS[j][1]) &amp;&amp; !visited[j])
			{
				neigh[k] = j;
				k++;
			}
		}
		if(neigh[0]==-1) close = true;
		else {
		// next int. point to add to traj. is the closest to destination
		min_dist = pt_dist(INTERSECTIONS[neigh[0]][0], dest[0], INTERSECTIONS[neigh[0]][1], dest[1]);
		next_inters = neigh[0];
		for (j = 1; j &lt; 5 &amp;&amp; neigh[j] != -1; j++)
		{
			dist = pt_dist(INTERSECTIONS[neigh[j]][0], dest[0], INTERSECTIONS[neigh[j]][1], dest[1]);
			if (dist &lt; min_dist)
			{
				min_dist = dist;
				next_inters = neigh[j];
			}
		}
		// if trajectory is full, or no next point has been found,
		// something has gone wrong, but I cannot raise an exception
		if (i == N_P - 1 || next_inters == -1)
			return;
		// next inters point is set as visited,
		visited[next_inters] = true;
		// added to the trajectory,
		traj[i][0] = INTERSECTIONS[next_inters][0];
		traj[i][1] = INTERSECTIONS[next_inters][1];
		i++;
		// and set as current point
		curr[0] = INTERSECTIONS[next_inters][0];
		curr[1] = INTERSECTIONS[next_inters][1];
		// reset
		next_inters = -1;
		k = 0;
		for(j=0; j&lt;5;j++) neigh[j] = -1;
		close = same_area(curr[0], curr[1], dest[0], dest[1]);
		}
	}
	// destination point is always part of the trajectory
	traj[i][0] = dest[0];
	traj[i][1] = dest[1];

	//sets initial orientation
	change_orientation(internalRobX[id-1], internalRobY[id-1], traj[0][0], traj[0][1]);
}

void update_pos(double coeff) {
	internalRobX[id-1] = internalRobX[id-1] + coeff*Tpoll*cos(ort*PI/180);
	internalRobY[id-1] = internalRobY[id-1] + coeff*Tpoll*sin(ort*PI/180);
}

void initRobot() {
	t = 0;
	V = 0;
	robPositionX[id-1] = posX;
	robPositionY[id-1] = posY;
	internalRobX[id-1] = posX;
	internalRobY[id-1] = posY;
	tUpd=0;
	v_max = fint(_v_max);
	a_max = fint(_a_max);
}

void varsUpdate(double coeff) {
	tUpd = 0;

	if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
		return;

	if (pt_dist(internalRobX[id-1], traj[curr_traj][0], internalRobY[id-1], traj[curr_traj][1]) &lt; v_max*1.1) {
		curr_traj++;
		if (curr_traj &gt;= N_P || (traj[curr_traj][0]==0.0 &amp;&amp; traj[curr_traj][1]==0.0))
			plan_traj();
		change_orientation(internalRobX[id-1], internalRobY[id-1], traj[curr_traj][0], traj[curr_traj][1]);
	}

	update_pos(coeff);
}
</declaration>
	<location id="id104" x="-629" y="-348">
		<name x="-672" y="-365">idle</name>
		<label kind="invariant" x="-722" y="-348">V' == 0 &amp;&amp;
tUpd'==0</label>
	</location>
	<location id="id105" x="-424" y="-144">
		<name x="-501" y="-144">stopping</name>
		<label kind="invariant" x="-603" y="-144">V' == -a_max
&amp;&amp; tUpd&lt;=Tpoll</label>
		<label kind="comments" x="-603" y="-110">&amp;&amp; V &gt;=0</label>
	</location>
	<location id="id106" x="-425" y="-348">
		<name x="-408" y="-366">starting</name>
		<label kind="invariant" x="-348" y="-382">V' == a_max
&amp;&amp; V &lt;= v_max
&amp;&amp; tUpd&lt;=Tpoll</label>
	</location>
	<location id="id107" x="-161" y="-246">
		<name x="-229" y="-263">moving</name>
		<label kind="invariant" x="-263" y="-246">V' == 0 &amp;&amp;
tUpd&lt;=Tpoll</label>
	</location>
	<location id="id108" x="-629" y="-527">
		<name x="-639" y="-561">Init</name>
		<committed/>
	</location>
	<location id="id109" x="-850" y="-459">
		<name x="-943" y="-467">recharging</name>
		<label kind="invariant" x="-926" y="-450">V'==0 &amp;&amp;
tUpd'==0</label>
	</location>
	<location id="id110" x="195" y="-246">
		<name x="212" y="-272">turning</name>
		<label kind="invariant" x="212" y="-255">V'==0 &amp;&amp;
Th&lt;=fabs(ort*PI/180)</label>
	</location>
	<location id="id111" x="51" y="-246">
		<committed/>
	</location>
	<location id="id112" x="-425" y="-527">
		<committed/>
	</location>
	<location id="id113" x="-425" y="76">
		<committed/>
	</location>
	<location id="id114" x="-59" y="-204">
		<committed/>
	</location>
	<location id="id115" x="-629" y="-144">
		<committed/>
	</location>
	<init ref="id108"/>
	<transition>
		<source ref="id105"/>
		<target ref="id115"/>
		<label kind="guard" x="-612" y="-187">V &lt;= 0</label>
		<label kind="assignment" x="-612" y="-170">active_robot[id-1] = true</label>
	</transition>
	<transition>
		<source ref="id114"/>
		<target ref="id107"/>
		<label kind="synchronisation" x="-153" y="-229">publish_m[id]!</label>
	</transition>
	<transition>
		<source ref="id111"/>
		<target ref="id114"/>
		<label kind="guard" x="-25" y="-229">!needsTurning</label>
		<label kind="assignment" x="-25" y="-212">tUpd=0</label>
	</transition>
	<transition>
		<source ref="id113"/>
		<target ref="id105"/>
		<label kind="synchronisation" x="-561" y="-42">publish_m[id]!</label>
		<nail x="-459" y="17"/>
		<nail x="-459" y="-85"/>
	</transition>
	<transition>
		<source ref="id112"/>
		<target ref="id106"/>
		<label kind="synchronisation" x="-382" y="-467">publish_m[1]!</label>
		<nail x="-391" y="-484"/>
		<nail x="-391" y="-399"/>
	</transition>
	<transition>
		<source ref="id105"/>
		<target ref="id113"/>
		<label kind="guard" x="-416" y="-25">tUpd&gt;=Tpoll
&amp;&amp;V&gt;0</label>
		<label kind="assignment" x="-416" y="8">t+=Tpoll, tUpd=0,
varsUpdate(v_max-a_max*t)</label>
	</transition>
	<transition>
		<source ref="id106"/>
		<target ref="id112"/>
		<label kind="guard" x="-527" y="-476">tUpd&gt;=Tpoll
&amp;&amp;V&lt;v_max</label>
		<label kind="assignment" x="-569" y="-442">t+=Tpoll, tUpd=0,
varsUpdate(a_max*t)</label>
	</transition>
	<transition>
		<source ref="id110"/>
		<target ref="id105"/>
		<label kind="guard" x="-119" y="-178">active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-331" y="-161">stop_r_action?</label>
		<label kind="assignment" x="-119" y="-144">tUpd=0, t=0,
active_robot[id-1] = false</label>
		<nail x="195" y="-144"/>
	</transition>
	<transition>
		<source ref="id110"/>
		<target ref="id107"/>
		<label kind="guard" x="-85" y="-365">Th&gt;=fabs(ort*PI/180)</label>
		<label kind="assignment" x="-85" y="-348">tUpd = 0, Th = 0,
needsTurning = false</label>
		<nail x="195" y="-348"/>
		<nail x="-161" y="-348"/>
	</transition>
	<transition>
		<source ref="id111"/>
		<target ref="id110"/>
		<label kind="guard" x="67" y="-263">needsTurning</label>
		<label kind="assignment" x="67" y="-246">Th=0</label>
	</transition>
	<transition>
		<source ref="id107"/>
		<target ref="id111"/>
		<label kind="guard" x="-110" y="-280">tUpd&gt;=Tpoll</label>
		<label kind="assignment" x="-119" y="-263">varsUpdate(v_max)</label>
	</transition>
	<transition>
		<source ref="id105"/>
		<target ref="id106"/>
		<label kind="guard" x="-416" y="-323">V&gt;0 &amp;&amp;
active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-416" y="-289">start_r_action?</label>
		<label kind="assignment" x="-416" y="-272">t=0, tUpd=0,
plan_traj(),
active_robot[id-1] = false</label>
	</transition>
	<transition>
		<source ref="id106"/>
		<target ref="id105"/>
		<label kind="guard" x="-603" y="-289">V&lt;v_max &amp;&amp;
active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-603" y="-255">stop_r_action?</label>
		<label kind="assignment" x="-603" y="-238">t=0, tUpd=0,
active_robot[id-1] = false</label>
		<nail x="-459" y="-323"/>
		<nail x="-459" y="-161"/>
	</transition>
	<transition>
		<source ref="id109"/>
		<target ref="id104"/>
		<label kind="guard" x="-816" y="-510">active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-816" y="-493">stop_recharging?</label>
		<label kind="assignment" x="-816" y="-476">tUpd=0,
active_robot[id-1] = false</label>
		<nail x="-629" y="-459"/>
	</transition>
	<transition>
		<source ref="id104"/>
		<target ref="id109"/>
		<label kind="synchronisation" x="-842" y="-416">start_recharging[id]?</label>
		<nail x="-850" y="-348"/>
	</transition>
	<transition>
		<source ref="id115"/>
		<target ref="id104"/>
		<label kind="synchronisation" x="-680" y="-221">r_still!</label>
		<label kind="assignment" x="-680" y="-204">t=0,
tUpd = 0,
V=0</label>
		<nail x="-629" y="-161"/>
		<nail x="-629" y="-161"/>
	</transition>
	<transition>
		<source ref="id107"/>
		<target ref="id105"/>
		<label kind="guard" x="-331" y="-178">active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-119" y="-161">stop_r_action?</label>
		<label kind="assignment" x="-331" y="-144">tUpd=0, t=0,
active_robot[id-1] = false</label>
		<nail x="-160" y="-144"/>
	</transition>
	<transition>
		<source ref="id106"/>
		<target ref="id107"/>
		<label kind="guard" x="-246" y="-331">V &gt;= v_max</label>
		<label kind="assignment" x="-238" y="-314">t+=Tpoll,
tUpd=0,
V=v_max</label>
		<nail x="-161" y="-348"/>
	</transition>
	<transition>
		<source ref="id104"/>
		<target ref="id106"/>
		<label kind="guard" x="-620" y="-391">active_robot[id-1] == true</label>
		<label kind="synchronisation" x="-578" y="-374">start_r_action?</label>
		<label kind="assignment" x="-603" y="-348">t=0, tUpd=0,
plan_traj(),
active_robot[id-1] = false</label>
	</transition>
	<transition>
		<source ref="id108"/>
		<target ref="id104"/>
		<label kind="assignment" x="-621" y="-484">initRobot()</label>
	</transition>
</template>
<template>
    <name>Battery</name>
    <parameter>int id, double Cstart</parameter>
    <declaration>
clock C, t, tUpd;

// BatteryStatus Sharing parameters
int dt = 0;

const double C_fail = 10.9;
const double C_100 = 12.6;

double d_0 = C_100;
const double d_1 = -3.05366882 * pow(10, -4);
const double d_2 = 2.46157427 * pow(10, -8);
const double d_3 = -8.33622587 * pow(10, -13);

double r_0 = C_100;
const double r_1 = +3.05366882 * pow(10, -4);
const double r_2 = +2.46157427 * pow(10, -8);
const double r_3 = -8.33622587 * pow(10, -13);


void updateCharge(bool charging) {
    if (charging) internal_charge[id - 1] = internal_charge[id - 1] +
                                  Tpoll * (r_1 + r_2 * Tpoll + 2 * r_2 * dt + r_3 * pow(Tpoll, 2)
                                    + 3 * r_3 * pow(dt, 2) + 3 * r_3 * dt * Tpoll);
    else
        internal_charge[id - 1] = internal_charge[id - 1] +
                                  Tpoll * (d_1 + d_2 * Tpoll + 2 * d_2 * dt + d_3 * pow(Tpoll, 2)
                                    + 3 * d_3 * pow(dt, 2) + 3 * d_3 * dt * Tpoll);
    dt += Tpoll;
}

void initBattery() {
    t = 0;
    C = Cstart;
    batteryCharge[id - 1] = Cstart;
    internal_charge[id - 1] = Cstart;
    tUpd = 0;
}
</declaration>
    <location id="id116" x="416" y="204">
        <name x="391" y="170">Init</name>
        <committed/>
    </location>
    <location id="id117" x="1071" y="204">
        <name x="1088" y="179">empty</name>
        <label kind="invariant" x="1088" y="196">C'==0</label>
        <label kind="exponentialrate" x="1088" y="162">1</label>
    </location>
    <location id="id118" x="688" y="204">
        <name x="696" y="179">discharging</name>
        <label kind="invariant" x="697" y="127">tUpd &lt;= Tpoll
&amp;&amp; C' == d_1 + 2*d_2*t + 3*d_3*t*t
&amp;&amp; C&gt;=C_fail</label>
    </location>
    <location id="id119" x="689" y="425">
        <name x="697" y="434">recharging</name>
        <label kind="invariant" x="697" y="451">C' == r_1 + 2*r_2*t + 3*r_3*t*t
&amp;&amp; tUpd &lt;= Tpoll</label>
    </location>
    <location id="id120" x="595" y="119">
        <committed/>
    </location>
    <location id="id121" x="595" y="519">
        <committed/>
    </location>
    <init ref="id116"/>
    <transition>
        <source ref="id118"/>
        <target ref="id117"/>
        <label kind="guard" x="901" y="204">C&lt;=C_fail</label>
        <label kind="synchronisation" x="875" y="221">dead_battery!</label>
        <label kind="assignment" x="799" y="238">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id121"/>
        <target ref="id119"/>
        <label kind="synchronisation" x="544" y="459">publish_m[0]!</label>
    </transition>
    <transition>
        <source ref="id119"/>
        <target ref="id121"/>
        <label kind="guard" x="621" y="519">tUpd&gt;=Tpoll</label>
        <label kind="assignment" x="621" y="536">tUpd=0, updateCharge(1)</label>
        <nail x="689" y="519"/>
    </transition>
    <transition>
        <source ref="id120"/>
        <target ref="id118"/>
        <label kind="synchronisation" x="536" y="153">publish_m[0]!</label>
    </transition>
    <transition>
        <source ref="id118"/>
        <target ref="id120"/>
        <label kind="guard" x="620" y="76">tUpd&gt;=Tpoll &amp;&amp; C&gt;C_fail</label>
        <label kind="assignment" x="620" y="93">tUpd=0, updateCharge(0)</label>
        <nail x="688" y="119"/>
    </transition>
    <transition>
        <source ref="id116"/>
        <target ref="id118"/>
        <label kind="assignment" x="442" y="178">initBattery()</label>
    </transition>
    <transition>
        <source ref="id119"/>
        <target ref="id118"/>
        <label kind="synchronisation" x="519" y="298">stop_recharging?</label>
        <label kind="assignment" x="519" y="315">d_0=C, t=0,
tUpd = 0, dt=0,
active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id118"/>
        <target ref="id119"/>
        <label kind="synchronisation" x="723" y="306">start_recharging[id]?</label>
        <label kind="assignment" x="723" y="323">r_0=C, t=0,
tUpd = 0, dt=0</label>
        <nail x="714" y="263"/>
        <nail x="714" y="374"/>
    </transition>
    <transition>
        <source ref="id117"/>
        <target ref="id117"/>
        <nail x="1088" y="247"/>
        <nail x="1113" y="230"/>
    </transition>
</template>
<template>
    <name>Orchestrator</name>
    <parameter>int id</parameter>
    <declaration>
clock ROS;

double latency = 1.5;
double eps = 0.0;

void update_eps() {
    eps = random_normal(0.5, 0.05);
}

void complete_leader() {
    if(served[currH-1] &amp;&amp; currH&lt;H &amp;&amp; patterns[currH]==1)
    currH++;
}

void complete_recipient() {
    served[currH-1] = true;
    if(currH&lt;H)
        currH++;
}

//This function change the current robot to fulfill the current task. The new coR should reach the recharge station and recharge itself.
void exchange_robots(){
    int tmp;
    tmp = coR;
    coR = currR;
    currR = tmp;

    currOp[currR-1] = 1;
    currOp[coR-1] = 4;
}
</declaration>
    <location id="id122" x="-1028" y="-1989">
        <committed/>
    </location>
    <location id="id123" x="-2711" y="-2218">
        <name x="-2779" y="-2235">o_init</name>
        <committed/>
    </location>
    <location id="id124" x="-1700" y="-2218">
        <name x="-1751" y="-2252">x_move</name>
        <label kind="invariant" x="-1776" y="-2218">ROS'==0</label>
    </location>
    <location id="id125" x="-2142" y="-2388">
        <name x="-2134" y="-2380">r_rech</name>
    </location>
    <location id="id126" x="-2312" y="-2218">
        <name x="-2337" y="-2252">r_start</name>
        <label kind="invariant" x="-2322" y="-2201">ROS &lt;= latency + eps</label>
    </location>
    <location id="id127" x="-1181" y="-2159">
        <name x="-1173" y="-2150">o_scs</name>
        <label kind="invariant" x="-1173" y="-2133">ROS'==0</label>
        <label kind="exponentialrate" x="-1139" y="-2176">1</label>
    </location>
    <location id="id128" x="-1181" y="-2278">
        <name x="-1173" y="-2269">o_fail_2</name>
        <label kind="invariant" x="-1173" y="-2252">ROS'==0</label>
        <label kind="exponentialrate" x="-1139" y="-2295">1</label>
    </location>
    <location id="id129" x="-1258" y="-2388">
        <name x="-1351" y="-2379">to_2nd_task</name>
        <committed/>
    </location>
    <location id="id130" x="-1666" y="-2387">
        <name x="-1657" y="-2379">starting_2</name>
        <committed/>
    </location>
    <location id="id131" x="-2303" y="-2388">
        <name x="-2295" y="-2380">stopping_2</name>
        <committed/>
    </location>
    <location id="id132" x="-2108" y="-2218">
        <name x="-2167" y="-2210">h_start</name>
        <committed/>
    </location>
    <location id="id133" x="-1572" y="-2218">
        <name x="-1582" y="-2252">x_stop</name>
        <label kind="invariant" x="-1581" y="-2269">ROS &lt;= latency + eps</label>
    </location>
    <location id="id134" x="-1258" y="-2219">
        <name x="-1241" y="-2235">stopping</name>
        <label kind="invariant" x="-1241" y="-2218">ROS'==0</label>
        <label kind="exponentialrate" x="-1275" y="-2210">1</label>
    </location>
    <location id="id135" x="-1853" y="-2218">
        <name x="-1844" y="-2210">starting</name>
        <committed/>
    </location>
    <location id="id136" x="-1377" y="-2142">
        <name x="-1394" y="-2176">h_stop</name>
        <committed/>
    </location>
    <location id="id137" x="-1666" y="-2456">
        <name x="-1657" y="-2448">delivering</name>
        <committed/>
    </location>
    <location id="id138" x="-2431" y="-2218">
        <name x="-2473" y="-2227">idle</name>
        <label kind="invariant" x="-2507" y="-2244">ROS'==0</label>
        <label kind="exponentialrate" x="-2441" y="-2184">1</label>
    </location>
    <location id="id139" x="-2431" y="-2116">
        <name x="-2507" y="-2082">o_fail_1</name>
        <label kind="invariant" x="-2507" y="-2099">ROS'==0</label>
        <label kind="exponentialrate" x="-2456" y="-2133">1</label>
    </location>
    <location id="id140" x="-2218" y="-2218">
        <committed/>
    </location>
    <location id="id141" x="-1802" y="-2218">
        <committed/>
    </location>
    <location id="id142" x="-1419" y="-2218">
        <committed/>
    </location>
    <location id="id143" x="-2431" y="-2388">
        <committed/>
    </location>
    <location id="id144" x="-1870" y="-2388">
        <committed/>
    </location>
    <location id="id145" x="-2609" y="-2218">
        <committed/>
    </location>
    <location id="id146" x="-2669" y="-2167">
        <committed/>
    </location>
    <location id="id147" x="-2550" y="-2167">
        <committed/>
    </location>
    <location id="id148" x="-2354" y="-1989">
        <name x="-2337" y="-2014">r_synch</name>
        <label kind="invariant" x="-2516" y="-1997">ROS &lt;= latency + eps</label>
    </location>
    <location id="id149" x="-2133" y="-1989">
        <committed/>
    </location>
    <location id="id150" x="-1946" y="-1989">
        <name x="-1956" y="-2023">r1</name>
        <label kind="invariant" x="-2023" y="-2014">ROS'==0</label>
    </location>
    <location id="id151" x="-1768" y="-1989">
        <name x="-1778" y="-2023">r2</name>
        <label kind="invariant" x="-1751" y="-2014">ROS &lt;= latency + eps</label>
    </location>
    <location id="id152" x="-1428" y="-1989">
        <name x="-1436" y="-2023">stopping_coR</name>
        <label kind="invariant" x="-1521" y="-2014">ROS'==0</label>
        <label kind="exponentialrate" x="-1428" y="-1997">1</label>
    </location>
    <location id="id153" x="-1564" y="-1989">
        <committed/>
    </location>
    <location id="id154" x="-1428" y="-1912">
        <name x="-1504" y="-1938">o_fail_3</name>
        <label kind="invariant" x="-1521" y="-1921">ROS'==0</label>
        <label kind="exponentialrate" x="-1428" y="-1921">1</label>
    </location>
    <location id="id155" x="-1207" y="-1989">
        <committed/>
    </location>
    <location id="id156" x="-1504" y="-2142">
        <committed/>
    </location>
    <init ref="id123"/>
    <transition>
        <source ref="id156"/>
        <target ref="id136"/>
        <label kind="synchronisation" x="-1487" y="-2142">stop_r_action!</label>
    </transition>
    <transition>
        <source ref="id125"/>
        <target ref="id131"/>
        <label kind="guard" x="-2269" y="-2422">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2244" y="-2456">opchk_scs?</label>
        <label kind="assignment" x="-2269" y="-2405">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id122"/>
        <target ref="id138"/>
        <label kind="synchronisation" x="-1708" y="-2091">opchk_start!</label>
        <label kind="assignment" x="-1691" y="-2065">ROS=0</label>
        <nail x="-1028" y="-2065"/>
        <nail x="-2303" y="-2074"/>
    </transition>
    <transition>
        <source ref="id155"/>
        <target ref="id122"/>
        <label kind="assignment" x="-1189" y="-1989">exchange_robots(),
        active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id152"/>
        <target ref="id155"/>
        <label kind="guard" x="-1377" y="-1972">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1334" y="-1989">r_still?</label>
        <label kind="assignment" x="-1377" y="-1955">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id154"/>
        <target ref="id154"/>
        <nail x="-1436" y="-1904"/>
        <nail x="-1436" y="-1887"/>
        <nail x="-1419" y="-1878"/>
        <nail x="-1402" y="-1895"/>
    </transition>
    <transition>
        <source ref="id152"/>
        <target ref="id154"/>
        <label kind="guard" x="-1419" y="-1963">fail</label>
        <label kind="synchronisation" x="-1419" y="-1946">r_still?</label>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id148"/>
        <label kind="guard" x="-2363" y="-2040">synch &amp;&amp; coR == id</label>
        <label kind="synchronisation" x="-2363" y="-2057">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id145"/>
        <target ref="id147"/>
        <label kind="assignment" x="-2652" y="-2150">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id123"/>
        <target ref="id146"/>
        <label kind="assignment" x="-2864" y="-2193">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id147"/>
        <target ref="id138"/>
        <label kind="assignment" x="-2532" y="-2192">ROS=0</label>
    </transition>
    <transition>
        <source ref="id146"/>
        <target ref="id145"/>
        <label kind="synchronisation" x="-2677" y="-2261">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id130"/>
        <target ref="id144"/>
        <label kind="assignment" x="-1853" y="-2431">currOp[id-1]=3,
        active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id131"/>
        <target ref="id143"/>
        <label kind="assignment" x="-2448" y="-2439">currOp[id-1]=1,
        active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id133"/>
        <target ref="id142"/>
        <label kind="guard" x="-1530" y="-2261">!stopHuman &amp;&amp;
        ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-1547" y="-2218">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id135"/>
        <target ref="id141"/>
        <label kind="assignment" x="-1921" y="-2269">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id140"/>
        <label kind="guard" x="-2269" y="-2295">ROS &gt;= latency + eps
        &amp;&amp; !exeRobot</label>
        <label kind="assignment" x="-2269" y="-2244">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id123"/>
        <label kind="guard" x="-2167" y="-2609">currOp[id-1]==6 || currOp[id-1] == 7</label>
        <label kind="assignment" x="-2091" y="-2592">currOp[id-1]=1</label>
        <nail x="-1258" y="-2235"/>
        <nail x="-1258" y="-2575"/>
        <nail x="-2711" y="-2575"/>
    </transition>
    <transition>
        <source ref="id126"/>
        <target ref="id132"/>
        <label kind="guard" x="-2244" y="-2176">ROS &gt;= latency + eps
        &amp;&amp; exeRobot</label>
        <nail x="-2218" y="-2159"/>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id127"/>
        <label kind="synchronisation" x="-2133" y="-2125">opchk_scs?</label>
        <nail x="-2371" y="-2108"/>
        <nail x="-1181" y="-2108"/>
    </transition>
    <transition>
        <source ref="id139"/>
        <target ref="id139"/>
        <nail x="-2431" y="-2056"/>
        <nail x="-2405" y="-2056"/>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id139"/>
        <label kind="synchronisation" x="-2516" y="-2176">opchk_fail?</label>
    </transition>
    <transition>
        <source ref="id138"/>
        <target ref="id126"/>
        <label kind="guard" x="-2456" y="-2261">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2414" y="-2244">opchk_stop?</label>
        <label kind="assignment" x="-2397" y="-2210">ROS = 0,
        update_eps(),
        active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id137"/>
        <target ref="id123"/>
        <label kind="synchronisation" x="-2040" y="-2507">stop_h_action!</label>
        <label kind="assignment" x="-2040" y="-2490">currOp[id-1]=1,
        complete_recipient()</label>
        <nail x="-2711" y="-2456"/>
    </transition>
    <transition>
        <source ref="id129"/>
        <target ref="id137"/>
        <label kind="guard" x="-1632" y="-2490">currOp[id-1]==4 &amp;&amp; patterns[currH-1]==2</label>
        <label kind="synchronisation" x="-1632" y="-2473">start_h_action!</label>
        <nail x="-1258" y="-2456"/>
    </transition>
    <transition>
        <source ref="id132"/>
        <target ref="id135"/>
        <label kind="guard" x="-2048" y="-2193">!startHuman</label>
        <nail x="-1989" y="-2192"/>
    </transition>
    <transition>
        <source ref="id136"/>
        <target ref="id134"/>
        <label kind="synchronisation" x="-1360" y="-2159">stop_h_action!</label>
        <nail x="-1258" y="-2142"/>
    </transition>
    <transition>
        <source ref="id133"/>
        <target ref="id156"/>
        <label kind="guard" x="-1564" y="-2201">stopHuman &amp;&amp;
        ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-1564" y="-2167">active_robot[id-1] = true</label>
        <nail x="-1572" y="-2142"/>
    </transition>
    <transition>
        <source ref="id141"/>
        <target ref="id124"/>
        <label kind="synchronisation" x="-1793" y="-2235">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id132"/>
        <target ref="id135"/>
        <label kind="guard" x="-2048" y="-2252">startHuman</label>
        <label kind="synchronisation" x="-2048" y="-2235">start_h_action!</label>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id129"/>
        <label kind="guard" x="-1224" y="-2414">stop [id-1]&amp;&amp; (currOp[id-1]==2 ||
        (currOp[id-1]==4 &amp;&amp;
        patterns[currH-1]==2)) &amp;&amp;
        active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1224" y="-2431">r_still?</label>
        <label kind="assignment" x="-1224" y="-2346">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id127"/>
        <label kind="guard" x="-1232" y="-2159">scs</label>
        <nail x="-1232" y="-2159"/>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id128"/>
        <label kind="guard" x="-1232" y="-2295">fail</label>
        <nail x="-1232" y="-2278"/>
    </transition>
    <transition>
        <source ref="id124"/>
        <target ref="id133"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1674" y="-2286">opchk_scs?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
        update_eps(),
        active_robot[id-1] = false</label>
        <nail x="-1640" y="-2227"/>
    </transition>
    <transition>
        <source ref="id124"/>
        <target ref="id133"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1674" y="-2269">opchk_fail?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
        update_eps(),
        active_robot[id-1] = false</label>
        <nail x="-1640" y="-2235"/>
    </transition>
    <transition>
        <source ref="id134"/>
        <target ref="id123"/>
        <label kind="guard" x="-2065" y="-2354">stop[id-1] &amp;&amp; !(currOp[id-1]==2 ||
        (currOp[id-1]==4 &amp;&amp;
        patterns[currH-1]==2)) &amp;&amp;
        active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2244" y="-2363">r_still?</label>
        <label kind="assignment" x="-2252" y="-2346">currOp[id-1]=1,
        complete_leader(),
        active_robot[id-1] = -1</label>
        <nail x="-1258" y="-2303"/>
        <nail x="-2711" y="-2303"/>
    </transition>
    <transition>
        <source ref="id142"/>
        <target ref="id134"/>
        <label kind="synchronisation" x="-1394" y="-2235">stop_r_action!</label>
    </transition>
    <transition>
        <source ref="id124"/>
        <target ref="id133"/>
        <label kind="guard" x="-1708" y="-2303">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1683" y="-2252">opchk_stop?</label>
        <label kind="assignment" x="-1759" y="-2193">ROS = 0,
        update_eps(),
        active_robot[id-1] = false</label>
        <nail x="-1640" y="-2218"/>
    </transition>
    <transition>
        <source ref="id140"/>
        <target ref="id132"/>
        <label kind="synchronisation" x="-2269" y="-2261">start_r_action!</label>
    </transition>
    <transition>
        <source ref="id143"/>
        <target ref="id123"/>
        <label kind="synchronisation" x="-2609" y="-2414">stop_recharging!</label>
        <nail x="-2711" y="-2388"/>
    </transition>
    <transition>
        <source ref="id125"/>
        <target ref="id131"/>
        <label kind="guard" x="-2269" y="-2422">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-2244" y="-2439">opchk_stop?</label>
        <label kind="assignment" x="-2269" y="-2405">active_robot[id-1] = false</label>
    </transition>
    <transition>
        <source ref="id144"/>
        <target ref="id125"/>
        <label kind="synchronisation" x="-2006" y="-2414">opchk_start!</label>
    </transition>
    <transition>
        <source ref="id129"/>
        <target ref="id130"/>
        <label kind="guard" x="-1632" y="-2422">currOp[id-1]==2</label>
        <label kind="synchronisation" x="-1632" y="-2405">start_recharging[id]!</label>
    </transition>
    <transition>
        <source ref="id127"/>
        <target ref="id127"/>
        <nail x="-1122" y="-2159"/>
        <nail x="-1122" y="-2184"/>
    </transition>
    <transition>
        <source ref="id128"/>
        <target ref="id128"/>
        <nail x="-1122" y="-2303"/>
        <nail x="-1122" y="-2278"/>
    </transition>
    <transition>
        <source ref="id149"/>
        <target ref="id150"/>
        <label kind="synchronisation" x="-2116" y="-1989">start_r_action!</label>
    </transition>
    <transition>
        <source ref="id148"/>
        <target ref="id149"/>
        <label kind="guard" x="-2329" y="-1980">ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-2329" y="-1963">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id150"/>
        <target ref="id151"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1912" y="-1963">opchk_scs?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
        update_eps()</label>
        <nail x="-1870" y="-1997"/>
    </transition>
    <transition>
        <source ref="id150"/>
        <target ref="id151"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1912" y="-1946">opchk_fail?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
        update_eps()</label>
        <nail x="-1870" y="-2006"/>
    </transition>
    <transition>
        <source ref="id150"/>
        <target ref="id151"/>
        <label kind="guard" x="-1946" y="-1980">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-1921" y="-1929">opchk_stop?</label>
        <label kind="assignment" x="-1904" y="-2048">ROS = 0,
        update_eps()</label>
        <nail x="-1870" y="-1989"/>
    </transition>
    <transition>
        <source ref="id151"/>
        <target ref="id153"/>
        <label kind="guard" x="-1734" y="-1989">ROS &gt;= latency + eps</label>
        <label kind="assignment" x="-1734" y="-1972">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id153"/>
        <target ref="id152"/>
        <label kind="synchronisation" x="-1547" y="-1989">stop_r_action!</label>
    </transition>
</template>
<template>
    <name>OpChk</name>
    <parameter>int id, int T_int, int T_proc</parameter>
    <declaration>
clock t_act;


//Human-Robot Distance Parameters
const double safetyDistance = 2.0;
const double stopDistance = 6.0;
const double restartDistance = 3.0;
int recipientStages = 0;

//Recharging Policy Parameters
const double rechargingTh = 11.1;
const double stopRechargingTh = 11.4;
const double failBattery = 11.0;

//Fatigue-Monitoring Parameters
const double failFatigue = 0.97;
const double stopFatigue = 0.6;
const double resumeFatigue = 0.3;


/**
* Init
**/

void initialize() {
    if (currR == id) stop[currR-1] = false;
    else if (coR == id) stop[coR-1] = false;
    exeRobot=false;
    stopHuman= false;
    startHuman=false;
}

/**
* Pattern-Specific Logics
**/

bool getStart(int pattern) {
    double humanRobotDist = calculateDistance();
    double dist_to_dest = pt_dist(robPositionX[currR-1], dX[currR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 100.0*1.2;

    if(pattern==0) { //start cond. for follower
        if (humanRobotDist&gt;=stopDistance)  //if human and robot are too distant
            return batteryCharge[id-1]&gt;=rechargingTh; //starts if battery is sufficient
        else return batteryCharge[id-1]&gt;=rechargingTh &amp;&amp; //starts if battery is sufficient,
                ((!stopHuman &amp;&amp; humanRobotDist&lt;=restartDistance) || //if human and robot are close again,
                (stopHuman &amp;&amp; humanFatigue[currH-1]&lt;=resumeFatigue)); //or if human has rested enough
    }
    else if(pattern==1) // start cond. for leader
        return hExe; //starts if human has started
    else if(pattern==2) // start cond. for recipient
        return batteryCharge[id-1]&gt;=rechargingTh; // starts if battery is sufficient
    else if(pattern==3)
        return batteryCharge[id-1]&gt;rechargingTh &amp;&amp;
    (pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]) &lt;= dist &amp;&amp;
    pt_dist(humanPositionX[currH-1], destX[currH-1], humanPositionY[currH-1], destY[currH-1]) &lt;= dist ||
                                                                                                    pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]) &gt; dist) ;
    else if(pattern == 10)// start cond. for interdependence by contract
        return batteryCharge[id-1]&gt;=rechargingTh;//start if battery is sufficient
    else if(pattern == 12) // start cond. for competition
        return batteryCharge[id-1]&gt;=rechargingTh;
    else
    return false;
}

double humanRobotDist;
void setOpParams(int pattern) {
    humanRobotDist = calculateDistance();
    exeRobot= false;
    // operational parameters (destination for robot, and op. state)
    if (pattern==0) { //follower
        currOp[currR-1] = 4;
        if (humanRobotDist&lt;=stopDistance) { //if human and robot are close,
            dX[currR-1] = destX[currH-1]; // move towards destination
            dY[currR-1] = destY[currH-1];
        } else { // !! ONLINE RECONFIGURATION FEATURE !!
            dX[currR-1] = humanPositionX[currH-1]; //if human and robot are distant,
            dY[currR-1] = humanPositionY[currH-1]; //move towards human
        }
    } else if (pattern==1) { //leader
        currOp[currR-1] = 5;
        dX[currR-1] = humanPositionX[currH-1]; // follow human
        dY[currR-1] = humanPositionY[currH-1];
    } else if (pattern==2) { //recipient
        currOp[currR-1] = 4;
        recipientStages = 1;
        dX[currR-1] = destX[currH-1]; // move towards object location
        dY[currR-1] = destY[currH-1];
    } else if (pattern==3){
        double dist_to_dest = pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]);
        if (dist_to_dest &gt; 50.0) {
            currOp[id-1]=4;
            dX[currR-1] = destX[currH-1];
            dY[currR-1] = destY[currH-1];
        }
        else {
            currOp[currR-1]=6;
            exeRobot=true;
        }
    } else if(pattern==10) { // interdependence by contract
        currOp[currR-1] = 4;
        //The robot shouldn't move ==&gt; set dest to initial position of robot
        dX[currR-1] = destX[currH-1];
        dY[currR-1] = destY[currH-1];
    } else if(pattern==12) { // competition
        currOp[currR-1] = 4;
        dX[currR-1] = destX[currH-1]; // move towards object location
        dY[currR-1] = destY[currH-1];
    }
}

bool getStop(int pattern) {
    double humanRobotDist = pt_dist(robPositionX[currR-1], humanPositionX[currH-1], robPositionY[currR-1],
                                    humanPositionY[currH-1])/100;
    double dist_to_dest = pt_dist(robPositionX[currR-1], dX[currR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 100.0*2.0;

    if(pattern==0) { // stop cond. for follower
        if(dX[currR-1]==destX[currH-1] &amp;&amp; dY[currR-1]==destY[currH-1]) { //if currently moving towards destination
            stopHuman = humanFatigue[currH-1]&gt;=stopFatigue; //stop human if too fatigued
            // stop robot if close to destination, human is too tired or too distant
            return dist_to_dest&lt;=dist || stopHuman || humanRobotDist&gt;=stopDistance;
        } else
        return humanRobotDist&lt;=restartDistance ||
            (dX[currR-1] == rechargeStation[0] &amp;&amp; dY[currR-1] == rechargeStation[1] &amp;&amp; dist_to_dest&lt;=dist); // else stop if close to human or recharge station
    } else if (pattern==1) // stop cond. for leader
        return dist_to_dest&lt;=dist || (!hExe &amp;&amp; dist_to_dest&lt;=dist); // stop if human has stopped
    else if (pattern==2 || pattern==3){ // stop cond. for recipient
        return dist_to_dest&lt;=dist; // stop if close to destination
    } else if (pattern==10)// interdependence by contract
        return !hExe;
    else if (pattern==12) // competition
        return dist_to_dest&lt;=dist;
    else
    return false;
}

/**
* Operating Mode Checks
**/

void check_r_rech(){
    if(batteryCharge[currR-1]&gt;=stopRechargingTh) //if recharging, stop when recharged
    stop[currR-1] = true;
}

void check_fail(){
    // mission fails if battery gets to 0, or human passes out
    if(batteryCharge[id-1]&lt;=failBattery ||
                               humanFatigue[currH-1]&gt;=failFatigue) {
        fail = true;
        currOp[currR-1] = 0;
    }
}

void check_scs(){
    // mission is accomplished if all humans are served
    if(served[H-1]) {
        scs = true;
        currOp[currR-1] = 0;
    }
}

void check_h_move(){
    stop[currR-1] = getStop(patterns[currH-1]);

    if(!stop[currR-1]) {
        dX[currR-1] = humanPositionX[currH-1];
        dY[currR-1] = humanPositionY[currH-1];
    }
}

void check_r_move(){
    // stop moving if battery is low and start task handover
    if(currOp[currR-1]==4 &amp;&amp; batteryCharge[currR-1]&lt;=rechargingTh) {
        stop[currR-1] = true;
        if (patterns[currH-1]==3 || patterns[currH-1]==0) stopHuman=true;
        return;
    }

    stop[currR-1] = getStop(patterns[currH-1]);

    // if human is a recipient, and robot has arrived to
    // its current destination
    if(patterns[currH-1]==2 &amp;&amp; stop[currR-1]) {
        // if it is the first stage, move on to the second one
        // and reach the human
        if(recipientStages==1) {
            stop[currR-1] = false;
            stopHuman = false;
            dX[currR-1] = humanPositionX[currH-1];
            dY[currR-1] = humanPositionY[currH-1];
            recipientStages++;
        }
    }
}

int select_coR() {
    int i, closest= -1;
    double dist, min_dist = 100000.0;
    if(R&gt;=2) {
        for(i=0; i &lt; R; i++) {
            dist = pt_dist(robPositionX[currR-1], robPositionX[i], robPositionY[currR-1], robPositionY[i]);
            if(dist &lt; min_dist &amp;&amp; i != (currR-1) &amp;&amp; !busy[i]) {
                min_dist = dist;
                closest = i;
            }
        }
        return closest+1;
    } else return closest;
}

bool start;
void check_start(){
    int tmp, coR_choice;
    bool isCoRobotAvailable;

    // if battery charge is low, move to rech. mode
    if(batteryCharge[currR-1]&lt;=rechargingTh) {
        dX[currR-1] = rechargeStation[0];
        dY[currR-1] = rechargeStation[1];
        coR_choice = select_coR();
        isCoRobotAvailable = coR_choice &gt; 0;
        if (isCoRobotAvailable){
            currOp[currR-1] = 7;
            coR = coR_choice;
            //if (currR == 1) coR = 2;
            //else coR = 1;
            currOp[coR-1] = 7;
            dX[coR-1] = robPositionX[currR-1];
            dY[coR-1] = robPositionY[currR-1];
            active_robot[coR-1] = true;
            synch = true;
        }
        else{
            currOp[currR-1] = 2;
            stop[currR-1] = true;
        }
        return;
    }

    start = getStart(patterns[currH-1]);
    if(start) {
        setOpParams(patterns[currH-1]);
        // human can start if it is a follower, rob is not recharging
        // and everybody is moving towards the destination (i.e., robot is not going back towards the human)
        // note: the leader does not need this boolean, because it does not "wait" for start_h_action to fire
        startHuman = (currOp[currR-1]==4 &amp;&amp; patterns[currH-1]!=2 &amp;&amp; patterns[currH-1]!=3 &amp;&amp;
        dX[currR-1]==destX[currH-1] &amp;&amp; dY[currR-1]==destY[currH-1]) || currOp[currR-1]==6;
        stop[currR-1] = true;
    }
}

void check_hr_mission(){
    if (served[currH-1]){
        stop[currR-1] = true;
        stopHuman=false;
        return;
    }
    if (batteryCharge[id-1]&lt;=rechargingTh){
        stop[currR-1]=true;
        stopHuman=true;
        return;
    }
    if (!hExe) stop[currR-1]=true;
}

void check_service_provided() {
    double eps = 200.0, dist_to_dest, humanRobotDist;

    dist_to_dest = pt_dist(robPositionX[currR-1], destX[currH-1], robPositionY[currR-1], destY[currH-1]);
    humanRobotDist = calculateDistance();

    if(patterns[currH-1]==0
       &amp;&amp; dist_to_dest &lt;= eps
                                     &amp;&amp; humanRobotDist &lt;= eps/100*2) { // if follower is close to robot and both are close to destination
        served[currH-1] = true;
        stopHuman = true;
        if(currH&lt;H &amp;&amp; patterns[currH]!=1)
        currH++;
    }
    else if((patterns[currH-1]==1 || patterns[currH-1]==3 || patterns[currH-1]==12) &amp;&amp; served[currH-1]) // if leader has set themselves as served
        currH++;
    else if(patterns[currH-1]==10 &amp;&amp; task_size &lt;= task_completion){
        served[currH-1] = true;
        stopHuman = true;
        if(currH&lt;H &amp;&amp; patterns[currH]!=1)
        currH++;
    }
}

/***********coR functions**************/

void check_r_move_coR(){
    //check if the coR has reached the recharging station
    double dist_to_dest = pt_dist(robPositionX[coR-1], dX[coR-1], robPositionY[coR-1], dY[coR-1]);
    double dist = 150.0;
    stop[coR-1] = dist_to_dest &lt;= dist;
}

void check_r_rech_coR(){
    if(batteryCharge[coR-1]&gt;=stopRechargingTh) //if recharging, stop when recharged
    stop[coR-1] = true;
}

void needs_recharging_coR(){
    stop[coR-1] = true;
    currOp[coR-1] = 2;
    dX[coR-1] = rechargeStation[0];
    dY[coR-1] = rechargeStation[1];
}


void check_r_sync(){
    double dist_to_dest = pt_dist(robPositionX[coR-1], dX[coR-1], robPositionY[currR-1], dY[currR-1]);
    double dist = 150.0;
    if (dist_to_dest &lt;= dist) {
        synch = false;
        stop[coR-1] = true;
    }
}

/**
* SAFETY DISTANCE ERROR
**/

void check_crit_op() {
    double humanRobotDist;
    humanRobotDist = calculateDistance();
    is_crit = humanRobotDist &lt;= safetyDistance;
}

/**
* MAIN LOOP
**/

void check_actions() {
    if (currR == id) {
        check_scs();
        if( scs )
            return;

        check_fail();
        if( fail )
            return;

        check_crit_op();

        if( currOp[currR-1]==1 ) // system idle, waiting for an action to start
            check_start();
        else if( currOp[currR-1]==2 || currOp[currR-1]==4 ) // robot moving to rech. station (currOp=2), or leading (currOp=4)
            check_r_move();
        else if( currOp[currR-1]==3 ) // robot recharging
            check_r_rech();
        else if( currOp[currR-1]==5 ) // robot following
            check_h_move();
        else if ( currOp[currR-1]==6 )
            check_hr_mission();
        else if ( currOp[currR-1]==7 )
            /*waiting co-robot synchronization*/;

        check_service_provided();
    }
    else if (coR == id){
        if( currOp[currR-1]==1 ) // system idle, waiting for an eventual synchronization with the current robot
            /*nothing*/;
        else if ( currOp[coR-1]==2 ) // co-robot moving to rech. station
            check_r_move_coR();
        else if ( currOp[coR-1]==3 ) // co-robot recharging
            check_r_rech_coR();
        else if ( currOp[coR-1]==4 )
            needs_recharging_coR();
        else if ( currOp[coR-1]==7 ) //// co-robot reaching current robot
            check_r_sync();
    }
}
</declaration>
    <location id="id157" x="-663" y="-366">
        <name x="-705" y="-399">op</name>
        <label kind="invariant" x="-773" y="-374">t_act&lt;=T_int</label>
    </location>
    <location id="id158" x="-238" y="-366">
        <name x="-221" y="-391">chk</name>
        <label kind="invariant" x="-221" y="-365">t_act&lt;=T_proc</label>
    </location>
    <location id="id159" x="-442" y="-527">
        <name x="-452" y="-561">off</name>
    </location>
    <location id="id160" x="-451" y="-222">
        <committed/>
    </location>
    <location id="id161" x="-238" y="-459">
        <committed/>
    </location>
    <location id="id162" x="-136" y="-459">
        <committed/>
    </location>
    <init ref="id159"/>
    <transition>
        <source ref="id162"/>
        <target ref="id159"/>
        <label kind="synchronisation" x="-195" y="-518">opchk_scs!</label>
        <nail x="-144" y="-467"/>
        <nail x="-238" y="-527"/>
    </transition>
    <transition>
        <source ref="id158"/>
        <target ref="id162"/>
        <label kind="guard" x="-127" y="-450">!stop[id-1] &amp;&amp; scs
        &amp;&amp; t_act&gt;=T_proc</label>
        <label kind="assignment" x="-127" y="-416">active_robot[id-1] = true</label>
        <nail x="-136" y="-365"/>
    </transition>
    <transition>
        <source ref="id158"/>
        <target ref="id161"/>
        <label kind="guard" x="-382" y="-459">stop[id-1] &amp;&amp; !scs
        &amp;&amp; t_act&gt;=T_proc</label>
        <label kind="assignment" x="-382" y="-425">active_robot[id-1] = true</label>
    </transition>
    <transition>
        <source ref="id160"/>
        <target ref="id159"/>
        <label kind="synchronisation" x="-25" y="-552">opchk_fail!</label>
        <label kind="assignment" x="-25" y="-527">fail = true</label>
        <label kind="comments" x="-433" y="-200">active_robot[id-1] is not set true because the synch messagge
        opchk_fail is not received by anyone</label>
        <nail x="59" y="-229"/>
        <nail x="59" y="-527"/>
    </transition>
    <transition>
        <source ref="id158"/>
        <target ref="id160"/>
        <label kind="guard" x="-229" y="-314">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-289" y="-255">h_fail?</label>
        <label kind="assignment" x="-229" y="-297">active_robot[id-1] = false</label>
        <nail x="-238" y="-263"/>
    </transition>
    <transition>
        <source ref="id157"/>
        <target ref="id160"/>
        <label kind="guard" x="-824" y="-314">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-629" y="-246">h_fail?</label>
        <label kind="assignment" x="-824" y="-297">active_robot[id-1] = false</label>
        <nail x="-663" y="-263"/>
    </transition>
    <transition>
        <source ref="id161"/>
        <target ref="id159"/>
        <label kind="synchronisation" x="-331" y="-501">opchk_stop!</label>
        <nail x="-238" y="-527"/>
    </transition>
    <transition>
        <source ref="id159"/>
        <target ref="id157"/>
        <label kind="guard" x="-748" y="-578">active_robot[id-1] == true &amp;&amp;
        (currR == id || coR == id)</label>
        <label kind="synchronisation" x="-697" y="-544">opchk_start?</label>
        <label kind="assignment" x="-748" y="-527">initialize(), t_act=0,
        active_robot[id-1] = false</label>
        <nail x="-663" y="-527"/>
    </transition>
    <transition>
        <source ref="id158"/>
        <target ref="id160"/>
        <label kind="guard" x="-229" y="-314">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-365" y="-297">dead_battery?</label>
        <label kind="assignment" x="-229" y="-297">active_robot[id-1] = false</label>
        <nail x="-263" y="-280"/>
    </transition>
    <transition>
        <source ref="id157"/>
        <target ref="id160"/>
        <label kind="guard" x="-824" y="-314">active_robot[id-1] == true</label>
        <label kind="synchronisation" x="-629" y="-297">dead_battery?</label>
        <label kind="assignment" x="-824" y="-297">active_robot[id-1] = false</label>
        <nail x="-637" y="-280"/>
    </transition>
    <transition>
        <source ref="id158"/>
        <target ref="id157"/>
        <label kind="guard" x="-527" y="-340">!stop[id-1] &amp;&amp; !scs
        &amp;&amp; t_act&gt;=T_proc</label>
        <label kind="assignment" x="-476" y="-306">t_act=0</label>
        <nail x="-450" y="-323"/>
    </transition>
    <transition>
        <source ref="id157"/>
        <target ref="id158"/>
        <label kind="guard" x="-501" y="-408">t_act&gt;=T_int</label>
        <label kind="assignment" x="-501" y="-391">check_actions(), t_act=0</label>
    </transition>
</template>
<template>
    <name>ROS_SensPub</name>
    <parameter>int id, double l_avg, double l_dev</parameter>
    <declaration>
clock L;

double latency = 0.0;
int buff_pos = 0;

double buffer[MAX_BUFF_SIZE];
double buffer2[MAX_BUFF_SIZE];

int buffer3[MAX_BUFF_SIZE];
int cached_id;

void update_lat() {
    latency = random_normal(l_avg, l_dev);
}

void add_to_buffer() {
    cached_id = currH;
    if(id==0){
        buffer[buff_pos] = internal_charge[0];
        buffer3[buff_pos] = 0;
        if(R&gt;=2) {
            buff_pos++;
            buffer[buff_pos] = internal_charge[1];
            buffer3[buff_pos] = 1;
        }
    }
    else if(id==1) {
        //update robot position (currR or coR)
        buffer[buff_pos] = internalRobX[id-1];
        buffer2[buff_pos] = internalRobY[id-1];
    }
    else if(id==2) {
        buffer[buff_pos] = internalHumX[currH-1];
        buffer2[buff_pos] = internalHumY[currH-1];
        buffer3[buff_pos] = -1;
    }
    else if(id==3){
        buffer[buff_pos] = internalFatigue[currH-1];
        buffer3[buff_pos] = -1;
    }

    buff_pos += 1;
}

void shift_buffer(){
    int i;

    // Shift buffer
    for(i=0; i&lt;MAX_BUFF_SIZE-1 &amp;&amp; buffer[i+1] &gt; 0.0; i++) {
        buffer[i] = buffer[i+1];
        buffer2[i] = buffer2[i+1];
        buffer3[i] = buffer3[i+1];
    }

    buffer[i+1] = -1.0;
    buffer2[i+1] = -1.0;
    buffer3[i+1] = -1;

    buff_pos = buff_pos-1;
    if(buff_pos &lt; 0)
        buff_pos = 0;
}

void publish() {
    int i;

    // Publish
    if(id==0){
        batteryCharge[buffer3[0]] = buffer[0];
        shift_buffer();
        batteryCharge[buffer3[0]] = buffer[0];
    }
    else if(id==1) {
        //update robot position (currR or coR)
        robPositionX[id-1] = buffer[0];
        robPositionY[id-1] = buffer2[0];
        /*shift_buffer();
        robPositionX[buffer3[0]] = buffer[0];
        robPositionY[buffer3[0]] = buffer2[0];*/
    }
    else if(id==2 &amp;&amp; cached_id==currH)
        for(i=0; i&lt;H &amp;&amp; SAME_H_IDs[currH-1][i]!=-1; i++) {
            humanPositionX[SAME_H_IDs[currH-1][i]-1] = buffer[0];
            humanPositionY[SAME_H_IDs[currH-1][i]-1] = buffer2[0];
        }
    else if(id==3 &amp;&amp; cached_id==currH) humanFatigue[currH-1] = buffer[0];

    shift_buffer();
}
        </declaration>
    <location id="id163" x="-34" y="-8">
        <name x="-42" y="8">idle</name>
        <label kind="invariant" x="-42" y="25">L'==0</label>
    </location>
    <location id="id164" x="-34" y="-195">
        <name x="-17" y="-204">sending</name>
        <label kind="invariant" x="-17" y="-187">L &lt;= latency</label>
    </location>
    <init ref="id163"/>
    <transition>
        <source ref="id164"/>
        <target ref="id164"/>
        <label kind="synchronisation" x="-8" y="-289">publish_m[id]?</label>
        <label kind="assignment" x="17" y="-272">add_to_buffer()</label>
        <nail x="-34" y="-280"/>
        <nail x="34" y="-246"/>
    </transition>
    <transition>
        <source ref="id164"/>
        <target ref="id164"/>
        <label kind="guard" x="-153" y="-314">L&gt;=latency
    &amp;&amp; buff_pos&gt;1</label>
        <label kind="assignment" x="-178" y="-280">publish(),
    update_lat(),
    L=0</label>
        <nail x="-34" y="-280"/>
        <nail x="-102" y="-238"/>
    </transition>
    <transition>
        <source ref="id164"/>
        <target ref="id163"/>
        <label kind="guard" x="-204" y="-144">L&gt;=latency
    &amp;&amp; buff_pos&lt;=1</label>
        <label kind="assignment" x="-153" y="-93">publish()</label>
        <nail x="-93" y="-102"/>
    </transition>
    <transition>
        <source ref="id163"/>
        <target ref="id164"/>
        <label kind="synchronisation" x="34" y="-127">publish_m[id]?</label>
        <label kind="assignment" x="34" y="-110">add_to_buffer(),
    L=0, update_lat()</label>
        <nail x="34" y="-102"/>
    </transition>
</template>
<system>
/////// HF_1 ///////
//args  HF_1
//vecArg
const double arg_us_HF_1[n_arg_all] = {
50.0,//upd_weight_ref [0]
0.0,//caso_upd_weight_ref [1]
1.0,//stm_weight_ref [2]
2.0,//ltm_weight_ref [3]
1.0,//caso_weight_entity_ref [4]
1.0,//caso_weight_sense_ref [5]
2.0,//caso_event_ref [6]
1.0,//caso_deelay_ref [7]
1.0,//n_deelay_index_ref [8]
1.0,//last_id_extracted_output_ref [9]
2.0,//caso_last_id_ref [10]
0.0,//caso_obj_ref [11]
0.0,//obj_selected_ref [12]
400.0,//distance_threshold_ref [13]
3.0,//caso_stm_ltm_ref [14]
10.0,//n_stm_ref [15]
6.0,//n_ltm_ref [16]
1.0,//id_robot [17]
1.0,//id_walk [18]
2.0,//id_sit [19]
3.0,//id_run [20]
4.0//id_stand [21]
};
////////////////////////////////////////////////
////////////////////////////////////////////////
//args_ad  HF_1
const int arg_ad_HF_1[nr_argAd]={
35,//nr_seeao
1,//n_sense
11,//n_entity
11,//n_event
20,//n_action
4,//n_output
7//nr_obj
};
////////////////////////////////////////////////
//matrix seeao num HF_1
const int SEEAO_HF_1[nr_seeao_max][nc_seeao]={
{1,1,1,1,1},
{1,1,1,2,4},
{1,1,1,3,2},
{1,1,1,5,4},
{1,1,1,4,1},
{1,2,2,1,1},
{1,2,2,2,4},
{1,2,2,3,2},
{1,2,2,5,4},
{1,3,3,1,1},
{1,3,3,2,4},
{1,3,3,3,2},
{1,3,3,5,4},
{1,4,4,1,1},
{1,4,4,6,2},
{1,4,4,3,4},
{1,5,5,1,1},
{1,6,6,7,1},
{1,6,6,15,4},
{1,6,6,8,1},
{1,6,6,9,4},
{1,7,7,10,4},
{1,7,7,11,1},
{1,7,7,12,4},
{1,8,8,7,1},
{1,8,8,15,4},
{1,8,8,8,3},
{1,8,8,9,4},
{1,9,9,10,4},
{1,9,9,11,1},
{1,9,9,12,4},
{1,10,10,13,3},
{1,10,10,14,4},
{1,11,11,19,4},
{1,11,11,20,1},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0}
};
////////////////////////////////////////////////
//matrix_obj_xye_num HF_1
const double obj_xye_HF_1[nr_obj_max][nc_obj] = {
{400.0,270.0,2.0},
{4000.0,270.0,2.0},
{1400.0,450.00,5.0},
{1200.0,680.0,2.0},
{3000.0,450.0,5.0},
{200.0,200.0,3.0},
{4000.0,700.0,3.0}
};
////////////////////////////////////////////////
//importance_matrix_num HF_1
//sense importance matrix
const double importance_sense_HF_1[nr_impSense_max] = {
10.0,
10.0,
10.0,
0.0,
0.0
};
//entity importance matrix
const double importance_entity_HF_1[nr_impEntity_max] = {
10.0,
10.0,
10.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0
};
////////////////////////////////////////////////
/////// HL_2 ///////
//args  HL_2
//vecArg
const double arg_us_HL_2[n_arg_all] = {
50.0,//upd_weight_ref [0]
0.0,//caso_upd_weight_ref [1]
1.0,//stm_weight_ref [2]
2.0,//ltm_weight_ref [3]
1.0,//caso_weight_entity_ref [4]
1.0,//caso_weight_sense_ref [5]
2.0,//caso_event_ref [6]
1.0,//caso_deelay_ref [7]
1.0,//n_deelay_index_ref [8]
1.0,//last_id_extracted_output_ref [9]
2.0,//caso_last_id_ref [10]
0.0,//caso_obj_ref [11]
0.0,//obj_selected_ref [12]
400.0,//distance_threshold_ref [13]
3.0,//caso_stm_ltm_ref [14]
10.0,//n_stm_ref [15]
6.0,//n_ltm_ref [16]
1.0,//id_robot [17]
1.0,//id_walk [18]
2.0,//id_sit [19]
3.0,//id_run [20]
4.0//id_stand [21]
};
////////////////////////////////////////////////
////////////////////////////////////////////////
//args_ad  HL_2
const int arg_ad_HL_2[nr_argAd]={
57,//nr_seeao
3,//n_sense
11,//n_entity
18,//n_event
20,//n_action
4,//n_output
7//nr_obj
};
////////////////////////////////////////////////
//matrix seeao num HL_2
const int SEEAO_HL_2[nr_seeao_max][nc_seeao]={
{1,1,1,1,1},
{1,1,1,2,4},
{1,1,1,3,2},
{1,1,1,5,4},
{1,1,1,4,1},
{1,2,2,1,1},
{1,2,2,2,4},
{1,2,2,3,2},
{1,2,2,5,4},
{1,3,3,1,1},
{1,3,3,2,4},
{1,3,3,3,2},
{1,3,3,5,4},
{1,4,4,1,1},
{1,4,4,6,2},
{1,4,4,3,4},
{1,5,5,1,1},
{1,6,6,7,1},
{1,6,6,15,4},
{1,6,6,8,1},
{1,6,6,9,4},
{1,7,7,10,4},
{1,7,7,11,1},
{1,7,7,12,4},
{1,8,8,7,1},
{1,8,8,15,4},
{1,8,8,8,3},
{1,8,8,9,4},
{1,9,9,10,4},
{1,9,9,11,1},
{1,9,9,12,4},
{1,10,10,13,3},
{1,10,10,14,4},
{1,11,11,19,4},
{1,11,11,20,1},
{2,1,12,1,1},
{2,1,12,2,4},
{2,1,12,3,4},
{2,1,12,5,4},
{2,1,12,4,1},
{2,2,13,1,1},
{2,2,13,2,4},
{2,2,13,3,4},
{2,2,13,5,2},
{2,3,14,1,1},
{2,3,14,2,4},
{2,3,14,3,4},
{2,3,14,5,4},
{2,3,14,16,1},
{2,4,15,1,1},
{2,4,15,6,2},
{2,4,15,3,4},
{2,5,16,1,1},
{3,10,17,13,3},
{3,10,17,14,4},
{3,11,18,18,4},
{3,11,18,17,1}
};
////////////////////////////////////////////////
//matrix_obj_xye_num HL_2
const double obj_xye_HL_2[nr_obj_max][nc_obj] = {
{400.0,270.0,2.0},
{4000.0,270.0,2.0},
{1400.0,450.00,5.0},
{1200.0,680.0,2.0},
{3000.0,450.0,5.0},
{200.0,200.0,3.0},
{4000.0,700.0,3.0}
};
////////////////////////////////////////////////
//importance_matrix_num HL_2
//sense importance matrix
const double importance_sense_HL_2[nr_impSense_max] = {
10.0,
10.0,
10.0,
10.0,
10.0
};
//entity importance matrix
const double importance_entity_HL_2[nr_impEntity_max] = {
10.0,
10.0,
10.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0
};
////////////////////////////////////////////////
/////// HL_3 ///////
//args  HL_3
//vecArg
const double arg_us_HL_3[n_arg_all] = {
50.0,//upd_weight_ref [0]
0.0,//caso_upd_weight_ref [1]
1.0,//stm_weight_ref [2]
2.0,//ltm_weight_ref [3]
1.0,//caso_weight_entity_ref [4]
1.0,//caso_weight_sense_ref [5]
2.0,//caso_event_ref [6]
1.0,//caso_deelay_ref [7]
1.0,//n_deelay_index_ref [8]
1.0,//last_id_extracted_output_ref [9]
2.0,//caso_last_id_ref [10]
0.0,//caso_obj_ref [11]
0.0,//obj_selected_ref [12]
400.0,//distance_threshold_ref [13]
3.0,//caso_stm_ltm_ref [14]
10.0,//n_stm_ref [15]
6.0,//n_ltm_ref [16]
1.0,//id_robot [17]
1.0,//id_walk [18]
2.0,//id_sit [19]
3.0,//id_run [20]
4.0//id_stand [21]
};
////////////////////////////////////////////////
////////////////////////////////////////////////
//args_ad  HL_3
const int arg_ad_HL_3[nr_argAd]={
57,//nr_seeao
3,//n_sense
11,//n_entity
18,//n_event
20,//n_action
4,//n_output
7//nr_obj
};
////////////////////////////////////////////////
//matrix seeao num HL_3
const int SEEAO_HL_3[nr_seeao_max][nc_seeao]={
{1,1,1,1,1},
{1,1,1,2,4},
{1,1,1,3,2},
{1,1,1,5,4},
{1,1,1,4,1},
{1,2,2,1,1},
{1,2,2,2,4},
{1,2,2,3,2},
{1,2,2,5,4},
{1,3,3,1,1},
{1,3,3,2,4},
{1,3,3,3,2},
{1,3,3,5,4},
{1,4,4,1,1},
{1,4,4,6,2},
{1,4,4,3,4},
{1,5,5,1,1},
{1,6,6,7,1},
{1,6,6,15,4},
{1,6,6,8,1},
{1,6,6,9,4},
{1,7,7,10,4},
{1,7,7,11,1},
{1,7,7,12,4},
{1,8,8,7,1},
{1,8,8,15,4},
{1,8,8,8,3},
{1,8,8,9,4},
{1,9,9,10,4},
{1,9,9,11,1},
{1,9,9,12,4},
{1,10,10,13,3},
{1,10,10,14,4},
{1,11,11,19,4},
{1,11,11,20,1},
{2,1,12,1,1},
{2,1,12,2,4},
{2,1,12,3,4},
{2,1,12,5,4},
{2,1,12,4,1},
{2,2,13,1,1},
{2,2,13,2,4},
{2,2,13,3,4},
{2,2,13,5,2},
{2,3,14,1,1},
{2,3,14,2,4},
{2,3,14,3,4},
{2,3,14,5,4},
{2,3,14,16,1},
{2,4,15,1,1},
{2,4,15,6,2},
{2,4,15,3,4},
{2,5,16,1,1},
{3,10,17,13,3},
{3,10,17,14,4},
{3,11,18,18,4},
{3,11,18,17,1}
};
////////////////////////////////////////////////
//matrix_obj_xye_num HL_3
const double obj_xye_HL_3[nr_obj_max][nc_obj] = {
{400.0,270.0,2.0},
{4000.0,270.0,2.0},
{1400.0,450.00,5.0},
{1200.0,680.0,2.0},
{3000.0,450.0,5.0},
{200.0,200.0,3.0},
{4000.0,700.0,3.0}
};
////////////////////////////////////////////////
//importance_matrix_num HL_3
//sense importance matrix
const double importance_sense_HL_3[nr_impSense_max] = {
10.0,
10.0,
10.0,
10.0,
10.0
};
//entity importance matrix
const double importance_entity_HL_3[nr_impEntity_max] = {
10.0,
10.0,
10.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0
};
////////////////////////////////////////////////
/////// HL_4 ///////
//args  HL_4
//vecArg
const double arg_us_HL_4[n_arg_all] = {
50.0,//upd_weight_ref [0]
0.0,//caso_upd_weight_ref [1]
1.0,//stm_weight_ref [2]
2.0,//ltm_weight_ref [3]
1.0,//caso_weight_entity_ref [4]
1.0,//caso_weight_sense_ref [5]
2.0,//caso_event_ref [6]
1.0,//caso_deelay_ref [7]
1.0,//n_deelay_index_ref [8]
1.0,//last_id_extracted_output_ref [9]
2.0,//caso_last_id_ref [10]
0.0,//caso_obj_ref [11]
0.0,//obj_selected_ref [12]
400.0,//distance_threshold_ref [13]
3.0,//caso_stm_ltm_ref [14]
10.0,//n_stm_ref [15]
6.0,//n_ltm_ref [16]
1.0,//id_robot [17]
1.0,//id_walk [18]
2.0,//id_sit [19]
3.0,//id_run [20]
4.0//id_stand [21]
};
////////////////////////////////////////////////
////////////////////////////////////////////////
//args_ad  HL_4
const int arg_ad_HL_4[nr_argAd]={
57,//nr_seeao
3,//n_sense
11,//n_entity
18,//n_event
20,//n_action
4,//n_output
7//nr_obj
};
////////////////////////////////////////////////
//matrix seeao num HL_4
const int SEEAO_HL_4[nr_seeao_max][nc_seeao]={
{1,1,1,1,1},
{1,1,1,2,4},
{1,1,1,3,2},
{1,1,1,5,4},
{1,1,1,4,1},
{1,2,2,1,1},
{1,2,2,2,4},
{1,2,2,3,2},
{1,2,2,5,4},
{1,3,3,1,1},
{1,3,3,2,4},
{1,3,3,3,2},
{1,3,3,5,4},
{1,4,4,1,1},
{1,4,4,6,2},
{1,4,4,3,4},
{1,5,5,1,1},
{1,6,6,7,1},
{1,6,6,15,4},
{1,6,6,8,1},
{1,6,6,9,4},
{1,7,7,10,4},
{1,7,7,11,1},
{1,7,7,12,4},
{1,8,8,7,1},
{1,8,8,15,4},
{1,8,8,8,3},
{1,8,8,9,4},
{1,9,9,10,4},
{1,9,9,11,1},
{1,9,9,12,4},
{1,10,10,13,3},
{1,10,10,14,4},
{1,11,11,19,4},
{1,11,11,20,1},
{2,1,12,1,1},
{2,1,12,2,4},
{2,1,12,3,4},
{2,1,12,5,4},
{2,1,12,4,1},
{2,2,13,1,1},
{2,2,13,2,4},
{2,2,13,3,4},
{2,2,13,5,2},
{2,3,14,1,1},
{2,3,14,2,4},
{2,3,14,3,4},
{2,3,14,5,4},
{2,3,14,16,1},
{2,4,15,1,1},
{2,4,15,6,2},
{2,4,15,3,4},
{2,5,16,1,1},
{3,10,17,13,3},
{3,10,17,14,4},
{3,11,18,18,4},
{3,11,18,17,1}
};
////////////////////////////////////////////////
//matrix_obj_xye_num HL_4
const double obj_xye_HL_4[nr_obj_max][nc_obj] = {
{400.0,270.0,2.0},
{4000.0,270.0,2.0},
{1400.0,450.00,5.0},
{1200.0,680.0,2.0},
{3000.0,450.0,5.0},
{200.0,200.0,3.0},
{4000.0,700.0,3.0}
};
////////////////////////////////////////////////
//importance_matrix_num HL_4
//sense importance matrix
const double importance_sense_HL_4[nr_impSense_max] = {
10.0,
10.0,
10.0,
10.0,
10.0
};
//entity importance matrix
const double importance_entity_HL_4[nr_impEntity_max] = {
10.0,
10.0,
10.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0
};
////////////////////////////////////////////////
/////// HF_5 ///////
//args  HF_5
//vecArg
const double arg_us_HF_5[n_arg_all] = {
50.0,//upd_weight_ref [0]
0.0,//caso_upd_weight_ref [1]
1.0,//stm_weight_ref [2]
2.0,//ltm_weight_ref [3]
1.0,//caso_weight_entity_ref [4]
1.0,//caso_weight_sense_ref [5]
2.0,//caso_event_ref [6]
1.0,//caso_deelay_ref [7]
1.0,//n_deelay_index_ref [8]
1.0,//last_id_extracted_output_ref [9]
2.0,//caso_last_id_ref [10]
0.0,//caso_obj_ref [11]
0.0,//obj_selected_ref [12]
400.0,//distance_threshold_ref [13]
3.0,//caso_stm_ltm_ref [14]
10.0,//n_stm_ref [15]
6.0,//n_ltm_ref [16]
1.0,//id_robot [17]
1.0,//id_walk [18]
2.0,//id_sit [19]
3.0,//id_run [20]
4.0//id_stand [21]
};
////////////////////////////////////////////////
////////////////////////////////////////////////
//args_ad  HF_5
const int arg_ad_HF_5[nr_argAd]={
35,//nr_seeao
1,//n_sense
11,//n_entity
11,//n_event
20,//n_action
4,//n_output
7//nr_obj
};
////////////////////////////////////////////////
//matrix seeao num HF_5
const int SEEAO_HF_5[nr_seeao_max][nc_seeao]={
{1,1,1,1,1},
{1,1,1,2,4},
{1,1,1,3,2},
{1,1,1,5,4},
{1,1,1,4,1},
{1,2,2,1,1},
{1,2,2,2,4},
{1,2,2,3,2},
{1,2,2,5,4},
{1,3,3,1,1},
{1,3,3,2,4},
{1,3,3,3,2},
{1,3,3,5,4},
{1,4,4,1,1},
{1,4,4,6,2},
{1,4,4,3,4},
{1,5,5,1,1},
{1,6,6,7,1},
{1,6,6,15,4},
{1,6,6,8,1},
{1,6,6,9,4},
{1,7,7,10,4},
{1,7,7,11,1},
{1,7,7,12,4},
{1,8,8,7,1},
{1,8,8,15,4},
{1,8,8,8,3},
{1,8,8,9,4},
{1,9,9,10,4},
{1,9,9,11,1},
{1,9,9,12,4},
{1,10,10,13,3},
{1,10,10,14,4},
{1,11,11,19,4},
{1,11,11,20,1},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0},
{0,0,0,0,0}
};
////////////////////////////////////////////////
//matrix_obj_xye_num HF_5
const double obj_xye_HF_5[nr_obj_max][nc_obj] = {
{400.0,270.0,2.0},
{4000.0,270.0,2.0},
{1400.0,450.00,5.0},
{1200.0,680.0,2.0},
{3000.0,450.0,5.0},
{200.0,200.0,3.0},
{4000.0,700.0,3.0}
};
////////////////////////////////////////////////
//importance_matrix_num HF_5
//sense importance matrix
const double importance_sense_HF_5[nr_impSense_max] = {
10.0,
10.0,
10.0,
0.0,
0.0
};
//entity importance matrix
const double importance_entity_HF_5[nr_impEntity_max] = {
10.0,
10.0,
10.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0,
5.0
};
////////////////////////////////////////////////
// Robot Instances
r_1 = Robot(1, 26.0, 26.0, 2500.00, 510.00);
b_r_1 = Battery(1, 12.3);
r_pub_1 = ROS_SensPub(1, 0.0, 0.00);
c_pub = ROS_SensPub(0, 0.5, 0.01);

//

// Controller Instances (one for each robot)
o_1 = Orchestrator(1);
opchk_1 = OpChk(1, 1, 0);

//

/**
* MISSION DEFINITION
**/

// Human Instances
// -&gt; DEFINE HUMAN PATTERNS
h_1 = Human_Follower(1, 26.0, 2, -1, -1, -1, arg_us_HF_1, arg_ad_HF_1, SEEAO_HF_1, importance_entity_HF_1, importance_sense_HF_1, obj_xye_HF_1);
h_2 = Human_Leader(2, 100.0, 3, -1, -1, -1, arg_us_HL_2, arg_ad_HL_2, SEEAO_HL_2, importance_entity_HL_2, importance_sense_HL_2, obj_xye_HL_2);
h_3 = Human_Leader(3, 100.0, 3, -1, 2, -1, arg_us_HL_3, arg_ad_HL_3, SEEAO_HL_3, importance_entity_HL_3, importance_sense_HL_3, obj_xye_HL_3);
h_4 = Human_Leader(4, 100.0, 2, -1, 1, -1, arg_us_HL_4, arg_ad_HL_4, SEEAO_HL_4, importance_entity_HL_4, importance_sense_HL_4, obj_xye_HL_4);
h_5 = Human_Follower(5, 26.0, 2, -1, 1, -1, arg_us_HF_5, arg_ad_HF_5, SEEAO_HF_5, importance_entity_HF_5, importance_sense_HF_5, obj_xye_HF_5);
h_pub_pos = ROS_SensPub(2, 0.5, 0.01);
h_pub_ftg = ROS_SensPub(3, 0.5, 0.01);

//

system
h_1,
h_2,
h_3,
h_4,
h_5,
r_1,
b_r_1,
r_pub_1,
o_1,
opchk_1,
c_pub,
h_pub_pos,
h_pub_ftg
;
</system>
	<queries>
	</queries>
</nta>
